mads 2.1.0 build 8 (23 Dec 19)
Source: C:\jac\wudsn\Workspace\Atari800\OS-snippets\Atari_XL_OS_Rev.2.asm
     1 				; Converted to MADS by Jakub 'Ilmenit' Debski 'Dec 2020
     2 				; in MADS compile with -fv:0 (by default fill value is $FF)
     3
     4 					OPT h- ; do not add file header
     5 					OPT f+ ; save as single block
     6
     7 					;TITLE	'OS - Operating System'
     8 					;;SUBTTL	' '
     9 					;LIST	-F,-M
    10
    11 				;	;SPACE	4,10
    12 				;*	Copyright 1984 ATARI.  Unauthorized reproduction, adaptation,
    13 				*	distribution, performance or display of this computer program
    14 				*	or the associated audiovisual work is strictly prohibited.
    15 				;	;SPACE	4,10
    16 				;*	OS - Operating System
    17 				*
    18 				*	NOTES
    19 				*		This represents an attempt to bring the OS :
    20 				*		into conformance with the Atari Internal So:
    21 				*		Standards as defined in the Software Develo:
    22 				*		Committee Report on Procedures And Standard:
    23 				*		(10/27/81).  Due to time constraints, the e:
    24 				*		source could not be brought up to the stand:
    25 				*		particularly in the area of subroutine head:
    26 				*		documentation (ENTRY, EXIT, CHANGES and CAL:
    27 				*		More complete and consistent conformance to:
    28 				*		standard is planned for the next revision o:
    29 				*		Operating System (Revision 3).
    30 				*
    31 				*	MODS
    32 				*		Revision A (400/800)
    33 				*		D. Crane/A. Miller/L. Kaplan/R. Whitehead
    34 				*
    35 				*		Revision B (400/800)
    36 				*		Fix several problems.
    37 				*		M. Mahar/R. S. Scheiman
    38 				*
    39 				*		Revision 10 (1200XL)
    40 				*		Support 1200XL, add new features.
    41 				*		H. Stewart/L. Winner/R. S. Scheiman/
    42 				*		Y. M. Chen/M. W. Colburn	10/26/82
    43 				*
    44 				*		Revision 11 (1200XL)
    45 				*		Fix several problems.
    46 				*		R. S. Scheiman	12/23/82
    47 				*
    48 				*		Revision 1 (600XL/800XL)
    49 				*		Support PBI and on-board BASIC.
    50 				*		R. S. Scheiman/R. K. Nordin/Y. M. Chen	03/11/83
    51 				*
    52 				*		Revision 2 (600XL/800XL)
    53 				*		Fix several problems.
    54 				*		R. S. Scheiman	05/10/83
    55 				*		Bring closer to Coding Standard (object unchanged).
    56 				*		R. K. Nordin	11/01/83
    57
    58
    59 				;	;SPACE	4,10
    60 				;	Program Structure
    61 				*
    62 				*	The sections of the OS appear in the following order with
    63 				*	corresponding subtitles:
    64 				*
    65 				*	Equates and Definitions
    66 				*
    67 				*		System Symbol Equates
    68 				*		System Address Equates
    69 				*		Miscellaneous Address Equates
    70 				*		Macro Definitions
    71 				*
    72 				*	Code and Data
    73 				*
    74 				*		First 8K ROM Identification and Checksum
    75 				*
    76 				*		Interrupt Handler
    77 				*		Initialization
    78 				*		Disk Input/Ouput
    79 				*		Relocating Loader
    80 				*		Self-test, Part 1
    81 				*		Parallel Input/Output
    82 				*		Peripheral Handler Loading Facility, Part 1
    83 				*		Self-test, Part 2
    84 				*		Peripheral Handler Loading Facility, Part 2
    85 				*
    86 				*		International Character Set
    87 				*
    88 				*		Self-test, Part 3
    89 				*		Floating Point Package
    90 				*
    91 				*		Domestic Character Set
    92 				*
    93 				*		Device Handler Vector Tables
    94 				*		Jump Vectors
    95 				*		Generic Parallel Device Handler Vector Table
    96 				*
    97 				*		$E4C0 Patch
    98 				*		Central Input/Output
    99 				*		Peripheral Handler Loading Facility, Part 3
   100 				*		$E912 Patch
   101 				*		Peripheral Handler Loading Facility, Part 4
   102 				*		$E959 Patch
   103 				*		Serial Input/Output
   104 				*		Keyboard, Editor and Screen Handler, Part 1
   105 				*		Peripheral Handler Loading Facility, Part 5
   106 				*		$EF6B Patch
   107 				*		Keyboard, Editor and Screen Handler, Part 2
   108 				*		$F223 Patch
   109 				*		Keyboard, Editor and Screen Handler, Part 3
   110 				*		$FCD8 Patch
   111 				*		Cassette Handler
   112 				*		Printer Handler
   113 				*		Self-test, Part 4
   114 				*
   115 				*		Second 8K ROM Identification and Checksum
   116 				*		6502 Machine Vectors
   117 				;	;SUBTTL	'System Symbol Equates'
   118 				;	;SPACE	4,10
   119 				;	Assembly Option Equates
   120
   121 = 0000			FALSE	EQU	0
   122 				;!!!TRUE	EQU	not FALSE
   123 = 0001			TRUE	EQU	1
   124
   125 = 0001			VGC	=	TRUE	;virtual game controllers
   126 = 0000			RAMSYS	=	FALSE	;not RAM based system
   127 = 0000			LNBUG	=	FALSE	;no LNBUG interface
   128 = 0000			ACMI	=	FALSE	;no asynchronous communications mod:
   129 					;SPACE	4,10
   130 				;	Identification Equates
   131
   132
   133 = 0002			IDREV	EQU	$02	;identification revision number
   134 = 0010			IDDAY	EQU	$10	;identification day
   135 = 0005			IDMON	EQU	$05	;identification month
   136 = 0083			IDYEAR	EQU	$83	;identification year
   137 = 0002			IDCPU	EQU	$02	;identification CPU series
   138 = 0042			IDPN1	EQU	'B'	;identification part number field 1
   139 = 0042			IDPN2	EQU	'B'	;identification part number field 2
   140 = 0000			IDPN3	EQU	$00	;identification part number field 3
   141 = 0000			IDPN4	EQU	$00	;identification part number field 4
   142 = 0001			IDPN5	EQU	$01	;identification part number field 5
   143 					;SPACE	4,10
   144 				;	Configuration Equates
   145 				*
   146 				*	NOTES
   147 				*		Problem: last byte of HATABS (as defined by:
   148 				*		overlaps first power-up validation byte.
   149
   150
   151 = 0021			MAXDEV	EQU	33	;offset to last possible entry of HATABS
   152 = 0010			IOCBSZ	EQU	16	;length of IOCB
   153
   154 = 0000			SEIOCB	EQU	0*IOCBSZ	;screen editor IOCB index
   155 = 0080			MAXIOC	EQU	8*IOCBSZ	;first invalid IOCB index
   156
   157 = 0080			DSCTSZ	EQU	128	;disk sector size
   158
   159 = 0002			LEDGE	EQU	2	;left edge
   160 = 0027			REDGE	EQU	39	;right edge
   161
   162 = 0700			INIML	EQU	$0700	;initial MEMLO
   163
   164 = CC00			ICSORG	EQU	$CC00	;international character set origin
   165 = E000			DCSORG	EQU	$E000	;domestic character set origin
   166 					;SPACE	4,10
   167 				;	IOCB Command Code Equates
   168
   169
   170 = 0003			OPEN	EQU	$03	;open
   171 = 0005			GETREC	EQU	$05	;get record
   172 = 0007			GETCHR	EQU	$07	;get character(s)
   173 = 0009			PUTREC	EQU	$09	;put record
   174 = 000B			PUTCHR	EQU	$0B	;put character(s)
   175 = 000C			CLOSE	EQU	$0C	;close
   176 = 000D			STATIS	EQU	$0D	;status
   177 = 000E			SPECIL	EQU	$0E	;special
   178 					;SPACE	4,10
   179 				;	Special Entry Command Equates
   180
   181
   182 				;	Screen Commands
   183
   184 = 0011			DRAWLN	EQU	$11	;draw line
   185 = 0012			FILLIN	EQU	$12	;draw line with right fill
   186 					;SPACE	4,10
   187 				;	ICAX1 Auxiliary Byte 1 Equates
   188
   189
   190 = 0001			APPEND	EQU	$01	;open write append (D:) or screen read (E:)
   191 = 0002			DIRECT	EQU	$02	;open for directory access (D:)
   192 = 0004			OPNIN	EQU	$04	;open for input (all devices)
   193 = 0008			OPNOT	EQU	$08	;open for output (all devices)
   194 = 0010			MXDMOD	EQU	$10	;open for mixed mode (E:, S:)
   195 = 0020			INSCLR	EQU	$20	;open for input without clearing screen (E:, S:)
   196 					;SPACE	4,10
   197 				;	Device Code Equates
   198
   199
   200 = 0043			CASSET	EQU	'C'	;cassette
   201 = 0044			DISK	EQU	'D'	;disk
   202 = 0045			SCREDT	EQU	'E'	;screen editor
   203 = 004B			KBD	EQU	'K'	;keyboard
   204 = 0050			PRINTR	EQU	'P'	;printer
   205 = 0053			DISPLY	EQU	'S'	;screen display
   206 					;SPACE	4,10
   207 				;	Character and Key Code Equates
   208
   209
   210 = 007D			CLS	EQU	$7D	;clear screen
   211 = 009B			EOL	EQU	$9B	;end of line (RETURN)
   212
   213 = 0011			HELP	EQU	$11	;key code for HELP
   214 = 0083			CNTLF1	EQU	$83	;key code for CTRL-F1
   215 = 0084			CNTLF2	EQU	$84	;key code for CTRL-F2
   216 = 0093			CNTLF3	EQU	$93	;key code for CTRL-F3
   217 = 0094			CNTLF4	EQU	$94	;key code for CTRL-F4
   218 = 009F			CNTL1	EQU	$9F	;key code for CTRL-1
   219 					;SPACE	4,10
   220 				;	Status Code Equates
   221
   222
   223 = 0001			SUCCES	EQU	1	;successful operation
   224
   225 = 0080			BRKABT	EQU	128	;BREAK key abort
   226 = 0081			PRVOPN	EQU	129	;IOCB already open error
   227 = 0082			NONDEV	EQU	130	;nonexistent device error
   228 = 0083			WRONLY	EQU	131	;IOCB opened for write only error
   229 = 0084			NVALID	EQU	132	;invalid command error
   230 = 0085			NOTOPN	EQU	133	;device/file not open error
   231 = 0086			BADIOC	EQU	134	;invalid IOCB index error
   232 = 0087			RDONLY	EQU	135	;IOCB opened for read only error
   233 = 0088			EOFERR	EQU	136	;end of file error
   234 = 0089			TRNRCD	EQU	137	;truncated record error
   235 = 008A			TIMOUT	EQU	138	;peripheral device timeout error
   236 = 008B			DNACK	EQU	139	;device does not acknowledge command error
   237 = 008C			FRMERR	EQU	140	;serial bus framing error
   238 = 008D			CRSROR	EQU	141	;cursor overrange error
   239 = 008E			OVRRUN	EQU	142	;serial bus data overrun error
   240 = 008F			CHKERR	EQU	143	;serial bus checksum error
   241 = 0090			DERROR	EQU	144	;device done (operation incomplete) error
   242 = 0091			BADMOD	EQU	145	;bad screen mode number error
   243 = 0092			FNCNOT	EQU	146	;function not implemented in handler error
   244 = 0093			SCRMEM	EQU	147	;insufficient memory for screen mode error
   245
   246 				;	DCB Device Bus ID Equates
   247
   248
   249 = 0031			DISKID	EQU	$31	;disk bus ID
   250 = 0040			PDEVN	EQU	$40	;printer bus ID
   251 = 0060			CASET	EQU	$60	;cassette bus ID
   252 					;SPACE	4,10
   253 				;	Bus Command Equates
   254
   255
   256 = 0021			FOMAT	EQU	'!'	;format command
   257 = 0050			PUTSEC	EQU	'P'	;put sector command
   258 = 0052			READ	EQU	'R'	;read command
   259 = 0053			STATC	EQU	'S'	;status command
   260 = 0057			WRITE	EQU	'W'	;write command
   261 					;SPACE	4,10
   262 				;	Command Auxiliary Byte Equates
   263
   264
   265 = 0044			DOUBLE	EQU	'D'	;print 20 characters double width
   266 = 004E			NORMAL	EQU	'N'	;print 40 characters normally
   267 = 0050			PLOT	EQU	'P'	;plot
   268 = 0053			SIDWAY	EQU	'S'	;print 16 characters sideways
   269 					;SPACE	4,10
   270 				;	Bus Response Equates
   271
   272
   273 = 0041			ACK	EQU	'A'	;device acknowledged
   274 = 0043			COMPLT	EQU	'C'	;device successfully completed operation
   275 = 0045			ERROR	EQU	'E'	;device incurred error in attempted operation
   276 = 004E			NACK	EQU	'N'	;device did not understand
   277 					;SPACE	4,10
   278 				;	Floating Point Package Miscellaneous Equates
   279
   280
   281 = 0006			FPREC	EQU	6	;precision
   282
   283 = 0005			FMPREC	EQU	FPREC-1	;length of mantissa
   284 					;SPACE	4,10
   285 				;	Cassette Record Type Equates
   286
   287
   288 = 00FB			HDR	EQU	$FB	;header
   289 = 00FC			DTA	EQU	$FC	;data record
   290 = 00FA			DT1	EQU	$FA	;last data record
   291 = 00FE			EOT	EQU	$FE	;end of tape (file)
   292
   293 = 0002			TONE1	EQU	2	;record
   294 = 0001			TONE2	EQU	1	;playback
   295 					;SPACE	4,10
   296 				;	Cassette Timing Equates
   297
   298
   299 = 0480			WLEADN	EQU	1152	;NTSC 19.2 second WRITE file leader
   300 = 0240			RLEADN	EQU	576	;NTSC 9.6 second READ file leader
   301 = 00B4			WIRGLN	EQU	180	;NTSC 3.0 second WRITE IRG
   302 = 0078			RIRGLN	EQU	120	;NTSC 2.0 second READ IRG
   303 = 000F			WSIRGN	EQU	15	;NTSC 0.25 second WRITE short IRG
   304 = 000A			RSIRGN	EQU	10	;NTSC 0.16 second READ short IRG
   305 = 001E			BEEPNN	EQU	30	;NTSC 0.5 second beep duration
   306 = 000A			BEEPFN	EQU	10	;NTSC 0.16 second beep separation
   307
   308 = 03C0			WLEADP	EQU	960	;PAL 19.2 second WRITE file leader
   309 = 01E0			RLEADP	EQU	480	;PAL 9.6 second READ file leader
   310 = 0096			WIRGLP	EQU	150	;PAL 3.0 second WRITE IRG
   311 = 0064			RIRGLP	EQU	100	;PAL 2.0 second READ IRG
   312 = 000D			WSIRGP	EQU	13	;PAL 0.25 second WRITE short IRG
   313 = 0008			RSIRGP	EQU	8	;PAL 0.16 second READ short IRG
   314 = 0019			BEEPNP	EQU	25	;PAL 0.5 second beep duration
   315 = 0008			BEEPFP	EQU	8	;PAL 0.16 second beep separation
   316
   317 = 0000			WIRGHI	EQU	0	;high WRITE IRG
   318 = 0000			RIRGHI	EQU	0	;high READ IRG
   319 					;SPACE	4,10
   320 				;	Power-up Validation Byte Value Equates
   321
   322
   323 = 005C			PUPVL1	EQU	$5C	;power-up validation value 1
   324 = 0093			PUPVL2	EQU	$93	;power-up validation value 2
   325 = 0025			PUPVL3	EQU	$25	;power-up validation value 3
   326 					;SPACE	4,10
   327 				;	Relocating Loader Miscellaneous Equates
   328
   329
   330 = 009C			DATAER	EQU	156	;end of record appears before END r:
   331 = 009D			MEMERR	EQU	157	;memory insufficient for load error
   332 					;SPACE	4,10
   333 				;	Miscellaneous Equates
   334
   335
   336 = 00FF			IOCFRE	EQU	$FF	;IOCB free indicator
   337
   338 = 0028			B19200	EQU	$0028	;19200 baud POKEY counter value
   339 = 05CC			B00600	EQU	$05CC	;600 baud POKEY counter value
   340
   341 = 0005			HITONE	EQU	$05	;FSK high freq. POKEY counter value (5326 Hz)
   342 = 0007			LOTONE	EQU	$07	;FSK low freq. POKEY counter value (3995 Hz)
   343
   344 = 0034			NCOMLO	EQU	$34	;PIA lower NOT COMMAND line command
   345 = 003C			NCOMHI	EQU	$3C	;PIA raise NOT COMMAND line command
   346
   347 = 0034			MOTRGO	EQU	$34	;PIA cassette motor ON command
   348 = 003C			MOTRST	EQU	$3C	;PIA cassette motor OFF command
   349
   350 = 0000			NODAT	EQU	$00	;SIO immediate operation
   351 = 0040			GETDAT	EQU	$40	;SIO read data frame
   352 = 0080			PUTDAT	EQU	$80	;SIO write data frame
   353
   354 = 000D			CRETRI	EQU	13	;number of command frame retries
   355 = 0001			DRETRI	EQU	1	;number of device retries
   356 = 0002			CTIM	EQU	2	;command frame ACK timeout
   357
   358 = 0028			NBUFSZ	EQU	40	;print normal buffer size
   359 = 0014			DBUFSZ	EQU	20	;print double buffer size
   360 = 001D			SBUFSZ	EQU	29	;print sideways buffer size
   361 				;	;SUBTTL	'System Address Equates'
   362 					;SPACE	4,10
   363 				;	Page Zero Address Equates
   364
   365
   366 = 0000			LNFLG	EQU	$0000	;1-byte LNBUG flag (0 = not LNBUG)
   367 = 0001			NGFLAG	EQU	$0001	;1-byte memory status (0 = failure)
   368
   369 				;	Not Cleared
   370
   371 = 0002			CASINI	EQU	$0002	;2-byte cassette program initialization address
   372 = 0004			RAMLO	EQU	$0004	;2-byte RAM address for memory test
   373 = 0006			TRAMSZ	EQU	$0006	;1-byte RAM size temporary
   374 = 0007			CMCMD	EQU	$0007	;1-byte command communications
   375
   376 				;	Cleared upon Coldstart Only
   377
   378 = 0008			WARMST	EQU	$0008	;1-byte warmstart flag (0 = coldstart)
   379 = 0009			BOOT?	EQU	$0009	;1-byte successful boot flags
   380 = 000A			DOSVEC	EQU	$000A	;2-byte disk program start vector
   381 = 000C			DOSINI	EQU	$000C	;2-byte disk program initialization address
   382 = 000E			APPMHI	EQU	$000E	;2-byte applications memory high limit
   383
   384 				;	Cleared upon Coldstart or Warmstart
   385
   386 = 0010			INTZBS	EQU	$0010	;first page zero location to clear
   387
   388 = 0010			POKMSK	EQU	$0010	;1-byte IRQEN shadow
   389 = 0011			BRKKEY	EQU	$0011	;1-byte BREAK key flag (0 = no BREAK)
   390 = 0012			RTCLOK	EQU	$0012	;3-byte real time clock (16 millisecond units)
   391 = 0015			BUFADR	EQU	$0015	;2-byte disk interface buffer address
   392 = 0017			ICCOMT	EQU	$0017	;1-byte CIO command table index
   393 = 0018			DSKFMS	EQU	$0018	;2-byte DOS File Management System pointer
   394 = 001A			DSKUTL	EQU	$001A	;2-byte DOS utility pointer
   395 = 001C			ABUFPT	EQU	$001C	;4-byte ACMI buffer pointer area
   396
   397 = 0020			ZIOCB	EQU	$0020	;address of page zero IOCB
   398 = 0020			IOCBAS	EQU	$0020	;16-byte page zero IOCB
   399 = 0020			ICHIDZ	EQU	$0020	;1-byte handler ID ($FF = IOCB free)
   400 = 0021			ICDNOZ	EQU	$0021	;1-byte device number
   401 = 0022			ICCOMZ	EQU	$0022	;1-byte command code
   402 = 0023			ICSTAZ	EQU	$0023	;1-byte status of last action
   403 = 0024			ICBALZ	EQU	$0024	;1-byte low buffer address
   404 = 0025			ICBAHZ	EQU	$0025	;1-byte high buffer address
   405 = 0026			ICPTLZ	EQU	$0026	;1-byte low PUT-BYTE routine address-1
   406 = 0027			ICPTHZ	EQU	$0027	;1-byte high PUT-BYTE routine address-1
   407 = 0028			ICBLLZ	EQU	$0028	;1-byte low buffer length
   408 = 0029			ICBLHZ	EQU	$0029	;1-byte high buffer length
   409 = 002A			ICAX1Z	EQU	$002A	;1-byte first auxiliary information
   410 = 002B			ICAX2Z	EQU	$002B	;1-byte second auxiliary information
   411 = 002C			ICSPRZ	EQU	$002C	;4-byte spares
   412
   413 = 002C			ENTVEC	EQU	$002C	;2-byte (not used)
   414 = 002E			ICIDNO	EQU	$002E	;1-byte IOCB index (IOCB number times IOCBSZ)
   415 = 002F			CIOCHR	EQU	$002F	;1-byte character for current CIO operation
   416
   417 = 0030			STATUS	EQU	$0030	;1-byte SIO operation status
   418 = 0031			CHKSUM	EQU	$0031	;1-byte checksum (single byte sum with carry)
   419 = 0032			BUFRLO	EQU	$0032	;1-byte low data buffer address
   420 = 0033			BUFRHI	EQU	$0033	;1-byte high data buffer address
   421 = 0034			BFENLO	EQU	$0034	;1-byte low data buffer end address
   422 = 0035			BFENHI	EQU	$0035	;1-byte high data buffer end address
   423 = 0036			LTEMP	EQU	$0036	;2-byte relocating loader temporary
   424 = 0038			BUFRFL	EQU	$0038	;1-byte data buffer full flag (0 = not full)
   425 = 0039			RECVDN	EQU	$0039	;1-byte receive-frame done flag (0 = not done)
   426 = 003A			XMTDON	EQU	$003A	;1-byte transmit-frame done flag (0 = not done)
   427 = 003B			CHKSNT	EQU	$003B	;1-byte checksum sent flag (0 = not sent)
   428 = 003C			NOCKSM	EQU	$003C	;1-byte no checksum follows data flag (0 = does)
   429 = 003D			BPTR	EQU	$003D	;1-byte cassette buffer pointer
   430 = 003E			FTYPE	EQU	$003E	;1-byte cassette IRG type (neg. = continuous)
   431 = 003F			FEOF	EQU	$003F	;1-byte cassette EOF flag (0 = no EOF)
   432 = 0040			FREQ	EQU	$0040	;1-byte cassette beep counter
   433 = 0041			SOUNDR	EQU	$0041	;1-byte noisy I/O flag (0 = quiet)
   434
   435 = 0042			CRITIC	EQU	$0042	;1-byte critical section flag (0 = not critical)
   436
   437 = 0043			FMSZPG	EQU	$0043	;7-byte reserved for DOS File Management System
   438
   439 = 004A			ZCHAIN	EQU	$004A	;2-byte handler linkage chain point:
   440 = 004C			DSTAT	EQU	$004C	;1-byte display status
   441 = 004D			ATRACT	EQU	$004D	;1-byte attract-mode timer and flag
   442 = 004E			DRKMSK	EQU	$004E	;1-byte attract-mode dark (luminance) mask
   443 = 004F			COLRSH	EQU	$004F	;1-byte attract-mode color shift
   444 = 0050			TMPCHR	EQU	$0050	;1-byte	temporary character
   445 = 0051			HOLD1	EQU	$0051	;1-byte	temporary
   446 = 0052			LMARGN	EQU	$0052	;1-byte text column left margin
   447 = 0053			RMARGN	EQU	$0053	;1-byte text column right margin
   448 = 0054			ROWCRS	EQU	$0054	;1-byte cursor row
   449 = 0055			COLCRS	EQU	$0055	;2-byte cursor column
   450 = 0057			DINDEX	EQU	$0057	;1-byte display mode
   451 = 0058			SAVMSC	EQU	$0058	;2-byte saved memory scan counter
   452 = 005A			OLDROW	EQU	$005A	;1-byte prior row
   453 = 005B			OLDCOL	EQU	$005B	;2-byte prior column
   454 = 005D			OLDCHR	EQU	$005D	;1-byte saved character under cursor
   455 = 005E			OLDADR	EQU	$005E	;2-byte saved cursor memory address
   456 = 0060			FKDEF	EQU	$0060	;2-byte function key definition tab:
   457 = 0062			PALNTS	EQU	$0062	;1-byte PAL/NTSC indicator (0 = NTS:
   458 = 0063			LOGCOL	EQU	$0063	;1-byte logical line cursor column
   459 = 0064			ADRESS	EQU	$0064	;2-byte temporary address
   460
   461 = 0066			MLTTMP	EQU	$0066	;1-byte temporary
   462 = 0066			OPNTMP	EQU	$0066	;1-byte open temporary
   463 = 0066			TOADR	EQU	$0066	;2-byte destination address
   464
   465 = 0068			SAVADR	EQU	$0068	;2-byte saved address
   466 = 0068			FRMADR	EQU	$0068	;2-byte source address
   467
   468 = 006A			RAMTOP	EQU	$006A	;1-byte RAM size
   469 = 006B			BUFCNT	EQU	$006B	;1-byte buffer count (logical line size)
   470 = 006C			BUFSTR	EQU	$006C	;2-byte buffer start pointer
   471 = 006E			BITMSK	EQU	$006E	;1-byte bit mask for bit map operation
   472 = 006F			SHFAMT	EQU	$006F	;1-byte shift amount for pixel justification
   473 = 0070			ROWAC	EQU	$0070	;2-byte draw working row
   474 = 0072			COLAC	EQU	$0072	;2-byte draw working column
   475 = 0074			ENDPT	EQU	$0074	;2-byte end point
   476 = 0076			DELTAR	EQU	$0076	;1-byte row difference
   477 = 0077			DELTAC	EQU	$0077	;2-byte column difference
   478 = 0079			KEYDEF	EQU	$0079	;2-byte key definition table addres:
   479 = 007B			SWPFLG	EQU	$007B	;1-byte split screen swap flag (0 = not swapped)
   480 = 007C			HOLDCH	EQU	$007C	;1-byte temporary character
   481 = 007D			INSDAT	EQU	$007D	;1-byte temporary
   482 = 007E			COUNTR	EQU	$007E	;2-byte draw iteration count
   483
   484 				;	Reserved for Application and Floating Point Package
   485
   486 				;	EQU	$0080	;128 bytes reserved for application and FPP
   487 					;SPACE	4,10
   488 				;	Floating Point Package Page Zero Address Equates
   489
   490
   491 = 00D4			FR0	EQU	$00D4	;6-byte register 0
   492 = 00D5			FR0M	EQU	$00D5	;5-byte register 0 mantissa
   493 = 00D9			QTEMP	EQU	$00D9	;1-byte temporary
   494
   495 = 00DA			FRE	EQU	$00DA	;6-byte (internal) register E
   496
   497 = 00E0			FR1	EQU	$00E0	;6-byte register 1
   498 = 00E1			FR1M	EQU	$00E1	;5-byte register 1 mantissa
   499
   500 = 00E6			FR2	EQU	$00E6	;6-byte (internal) register 2
   501
   502 = 00EC			FRX	EQU	$00EC	;1-byte temporary
   503
   504 = 00ED			EEXP	EQU	$00ED	;1-byte value of exponent
   505
   506 = 00EE			FRSIGN	EQU	$00EE	;1-byte floating point sign
   507 = 00EE			NSIGN	EQU	$00EE	;1-byte sign of number
   508
   509 = 00EF			PLYCNT	EQU	$00EF	;1-byte polynomial degree
   510 = 00EF			ESIGN	EQU	$00EF	;1-byte sign of exponent
   511
   512 = 00F0			SGNFLG	EQU	$00F0	;1-byte sign flag
   513 = 00F0			FCHFLG	EQU	$00F0	;1-byte first character flag
   514
   515 = 00F1			XFMFLG	EQU	$00F1	;1-byte transform flag
   516 = 00F1			DIGRT	EQU	$00F1	;1-byte number of digits after decimal point
   517
   518 = 00F2			CIX	EQU	$00F2	;1-byte current input index
   519 = 00F3			INBUFF	EQU	$00F3	;2-byte line input buffer
   520
   521 = 00F5			ZTEMP1	EQU	$00F5	;2-byte temporary
   522 = 00F7			ZTEMP4	EQU	$00F7	;2-byte temporary
   523 = 00F9			ZTEMP3	EQU	$00F9	;2-byte temporary
   524
   525 = 00FC			FLPTR	EQU	$00FC	;2-byte floating point number pointer
   526 = 00FE			FPTR2	EQU	$00FE	;2-byte floating point number pointer
   527 					;SPACE	4,10
   528 				;	Page One (Stack) Address Equates
   529
   530
   531 				;	EQU	$0100	;256-byte stack
   532 					;SPACE	4,10
   533 				;	Page Two Address Equates
   534
   535
   536 = 0200			INTABS	EQU	$0200	;42-byte interrupt handler table
   537
   538 = 0200			VDSLST	EQU	$0200	;2-byte display list NMI vector
   539 = 0202			VPRCED	EQU	$0202	;2-byte serial I/O proceed line IRQ vector
   540 = 0204			VINTER	EQU	$0204	;2-byte serial I/O interrupt line IRQ vector
   541 = 0206			VBREAK	EQU	$0206	;2-byte BRK instruction IRQ vector
   542 = 0208			VKEYBD	EQU	$0208	;2-byte keyboard IRQ vector
   543 = 020A			VSERIN	EQU	$020A	;2-byte serial input ready IRQ vector
   544 = 020C			VSEROR	EQU	$020C	;2-byte serial output ready IRQ vector
   545 = 020E			VSEROC	EQU	$020E	;2-byte serial output complete IRQ vector
   546 = 0210			VTIMR1	EQU	$0210	;2-byte POKEY timer 1 IRQ vector
   547 = 0212			VTIMR2	EQU	$0212	;2-byte POKEY timer 2 IRQ vector
   548 = 0214			VTIMR4	EQU	$0214	;2-byte POKEY timer 4 IRQ vector
   549 = 0216			VIMIRQ	EQU	$0216	;2-byte immediate IRQ vector
   550 = 0218			CDTMV1	EQU	$0218	;2-byte countdown timer 1 value
   551 = 021A			CDTMV2	EQU	$021A	;2-byte countdown timer 2 value
   552 = 021C			CDTMV3	EQU	$021C	;2-byte countdown timer 3 value
   553 = 021E			CDTMV4	EQU	$021E	;2-byte countdown timer 4 value
   554 = 0220			CDTMV5	EQU	$0220	;2-byte countdown timer 5 value
   555 = 0222			VVBLKI	EQU	$0222	;2-byte immediate VBLANK NMI vector
   556 = 0224			VVBLKD	EQU	$0224	;2-byte deferred VBLANK NMI vector
   557 = 0226			CDTMA1	EQU	$0226	;2-byte countdown timer 1 vector
   558 = 0228			CDTMA2	EQU	$0228	;2-byte countdown timer 2 vector
   559
   560 = 022A			CDTMF3	EQU	$022A	;1-byte countdown timer 3 flag (0 = expired)
   561 = 022B			SRTIMR	EQU	$022B	;1-byte software key repeat timer
   562 = 022C			CDTMF4	EQU	$022C	;1-byte countdown timer 4 flag (0 = expired)
   563 = 022D			INTEMP	EQU	$022D	;1-byte temporary
   564 = 022E			CDTMF5	EQU	$022E	;1-byte countdown timer 5 flag (0 = expired)
   565 = 022F			SDMCTL	EQU	$022F	;1-byte DMACTL shadow
   566 = 0230			SDLSTL	EQU	$0230	;1-byte DLISTL shadow
   567 = 0231			SDLSTH	EQU	$0231	;1-byte DLISTH shadow
   568 = 0232			SSKCTL	EQU	$0232	;1-byte SKCTL shadow
   569 = 0233			LCOUNT	EQU	$0233	;1-byte relocating loader record le:
   570 = 0234			LPENH	EQU	$0234	;1-byte light pen horizontal value
   571 = 0235			LPENV	EQU	$0235	;1-byte light pen vertical value
   572 = 0236			BRKKY	EQU	$0236	;2-byte BREAK key vector
   573 = 0238			VPIRQ	EQU	$0238	;2-byte parallel device IRQ vector
   574 = 023A			CDEVIC	EQU	$023A	;1-byte command frame device ID
   575 = 023B			CCOMND	EQU	$023B	;1-byte command frame command
   576 = 023C			CAUX1	EQU	$023C	;1-byte command auxiliary 1
   577 = 023D			CAUX2	EQU	$023D	;1-byte command auxiliary 2
   578
   579 = 023E			TEMP	EQU	$023E	;1-byte temporary
   580
   581 				;!!!	ASSERT	low TEMP<>$FF	;may not be the last word on a page
   582
   583 = 023F			ERRFLG	EQU	$023F	;1-byte I/O error flag (0 = no error)
   584
   585 				;!!!	ASSERT	low ERRFLG<>$FF ;may not be the last word on a page
   586
   587 = 0240			DFLAGS	EQU	$0240	;1-byte disk flags from sector 1
   588 = 0241			DBSECT	EQU	$0241	;1-byte disk boot sector count
   589 = 0242			BOOTAD	EQU	$0242	;2-byte disk boot memory address
   590 = 0244			COLDST	EQU	$0244	;1-byte coldstart flag (0 = complete)
   591 = 0245			RECLEN	EQU	$0245	;1-byte relocating loader record le:
   592 = 0246			DSKTIM	EQU	$0246	;1-byte disk format timeout
   593 = 0247			PDVMSK	EQU	$0247	;1-byte parallel device selection mask
   594 = 0248			SHPDVS	EQU	$0248	;1-byte PDVS (parallel device selec:
   595 = 0249			PDIMSK	EQU	$0249	;1-byte parallel device IRQ selection mask
   596 = 024A			RELADR	EQU	$024A	;2-byte relocating loader relative :
   597 = 024C			PPTMPA	EQU	$024C	;1-byte parallel device handler tem:
   598 = 024D			PPTMPX	EQU	$024D	;1-byte parallel device handler tem:
   599
   600 				;	EQU	$024E	;6 bytes reserved for Atari
   601
   602 				;	EQU	$0254	;23 bytes reserved for Atari
   603
   604 = 026B			CHSALT	EQU	$026B	;1-byte character set alternate
   605 = 026C			VSFLAG	EQU	$026C	;1-byte fine vertical scroll count
   606 = 026D			KEYDIS	EQU	$026D	;1-byte keyboard disable
   607 = 026E			FINE	EQU	$026E	;1-byte fine scrolling mode
   608 = 026F			GPRIOR	EQU	$026F	;1-byte PRIOR shadow
   609
   610 = 0270			PADDL0	EQU	$0270	;1-byte potentiometer 0
   611 = 0271			PADDL1	EQU	$0271	;1-byte potentiometer 1
   612 = 0272			PADDL2	EQU	$0272	;1-byte potentiometer 2
   613 = 0273			PADDL3	EQU	$0273	;1-byte potentiometer 3
   614 = 0274			PADDL4	EQU	$0274	;1-byte potentiometer 4
   615 = 0275			PADDL5	EQU	$0275	;1-byte potentiometer 5
   616 = 0276			PADDL6	EQU	$0276	;1-byte potentiometer 6
   617 = 0277			PADDL7	EQU	$0277	;1-byte potentiometer 7
   618
   619 = 0278			STICK0	EQU	$0278	;1-byte joystick 0
   620 = 0279			STICK1	EQU	$0279	;1-byte joystick 1
   621 = 027A			STICK2	EQU	$027A	;1-byte joystick 2
   622 = 027B			STICK3	EQU	$027B	;1-byte joystick 3
   623
   624 = 027C			PTRIG0	EQU	$027C	;1-byte paddle trigger 0
   625 = 027D			PTRIG1	EQU	$027D	;1-byte paddle trigger 1
   626 = 027E			PTRIG2	EQU	$027E	;1-byte paddle trigger 2
   627 = 027F			PTRIG3	EQU	$027F	;1-byte paddle trigger 3
   628 = 0280			PTRIG4	EQU	$0280	;1-byte paddle trigger 4
   629 = 0281			PTRIG5	EQU	$0281	;1-byte paddle trigger 5
   630 = 0282			PTRIG6	EQU	$0282	;1-byte paddle trigger 6
   631 = 0283			PTRIG7	EQU	$0283	;1-byte paddle trigger 7
   632
   633 = 0284			STRIG0	EQU	$0284	;1-byte joystick trigger 0
   634 = 0285			STRIG1	EQU	$0285	;1-byte joystick trigger 1
   635 = 0286			STRIG2	EQU	$0286	;1-byte joystick trigger 2
   636 = 0287			STRIG3	EQU	$0287	;1-byte joystick trigger 3
   637
   638 = 0288			HIBYTE	EQU	$0288	;1-byte relocating loader high byte:
   639 = 0289			WMODE	EQU	$0289	;1-byte cassette WRITE mode ($80 = writing)
   640 = 028A			BLIM	EQU	$028A	;1-byte cassette buffer limit
   641 = 028B			IMASK	EQU	$028B	;1-byte (not used)
   642 = 028C			JVECK	EQU	$028C	;2-byte jump vector or temporary
   643 = 028E			NEWADR	EQU	$028E	;2-byte relocating address
   644 = 0290			TXTROW	EQU	$0290	;1-byte split screen text cursor row
   645 = 0291			TXTCOL	EQU	$0291	;2-byte split screen text cursor column
   646 = 0293			TINDEX	EQU	$0293	;1-byte split scree text mode
   647 = 0294			TXTMSC	EQU	$0294	;2-byte split screen memory scan counter
   648 = 0296			TXTOLD	EQU	$0296	;6-byte OLDROW, OLDCOL, OLDCHR, OLDADR for text
   649 = 029C			CRETRY	EQU	$029C	;1-byte number of command frame ret:
   650 = 029D			HOLD3	EQU	$029D	;1-byte temporary
   651 = 029E			SUBTMP	EQU	$029E	;1-byte temporary
   652 = 029F			HOLD2	EQU	$029F	;1-byte (not used)
   653 = 02A0			DMASK	EQU	$02A0	;1-byte display (pixel location) mask
   654 = 02A1			TMPLBT	EQU	$02A1	;1-byte (not used)
   655 = 02A2			ESCFLG	EQU	$02A2	;1-byte escape flag ($80 = ESC detected)
   656 = 02A3			TABMAP	EQU	$02A3	;15-byte (120-bit) tab stop bit map
   657 = 02B2			LOGMAP	EQU	$02B2	;8-byte (32-bit) logical line bit map
   658 = 02B6			INVFLG	EQU	$02B6	;1-byte inverse video flag ($80 = inverse)
   659 = 02B7			FILFLG	EQU	$02B7	;1-byte right fill flag (0 = no fill)
   660 = 02B8			TMPROW	EQU	$02B8	;1-byte temporary row
   661 = 02B9			TMPCOL	EQU	$02B9	;2-byte temporary column
   662 = 02BB			SCRFLG	EQU	$02BB	;1-byte scroll occurence flag (0 = not occurred)
   663 = 02BC			HOLD4	EQU	$02BC	;1-byte temporary
   664 = 02BD			DRETRY	EQU	$02BD	;1-byte number of device retries
   665 = 02BE			SHFLOK	EQU	$02BE	;1-byte shift/control lock flags
   666 = 02BF			BOTSCR	EQU	$02BF	;1-byte screen bottom (24 = normal, 4 = split)
   667
   668 = 02C0			PCOLR0	EQU	$02C0	;1-byte player-missle 0 color/luminance
   669 = 02C1			PCOLR1	EQU	$02C1	;1-byte player-missle 1 color/luminance
   670 = 02C2			PCOLR2	EQU	$02C2	;1-byte player-missle 2 color/luminance
   671 = 02C3			PCOLR3	EQU	$02C3	;1-byte player-missle 3 color/luminance
   672
   673 = 02C4			COLOR0	EQU	$02C4	;1-byte playfield 0 color/luminance
   674 = 02C5			COLOR1	EQU	$02C5	;1-byte playfield 1 color/luminance
   675 = 02C6			COLOR2	EQU	$02C6	;1-byte playfield 2 color/luminance
   676 = 02C7			COLOR3	EQU	$02C7	;1-byte playfield 3 color/luminance
   677
   678 = 02C8			COLOR4	EQU	$02C8	;1-byte background color/luminance
   679
   680 = 02C9			PARMBL	EQU	$02C9	;6-byte relocating loader parameter:
   681 = 02C9			RUNADR	EQU	$02C9	;2-byte run address
   682 = 02CB			HIUSED	EQU	$02CB	;2-byte highest non-zero page addre:
   683 = 02CD			ZHIUSE	EQU	$02CD	;2-byte highest zero page address
   684
   685 = 02CF			OLDPAR	EQU	$02CF	;6-byte relocating loader parameter:
   686 = 02CF			GBYTEA	EQU	$02CF	;2-byte GET-BYTE routine address
   687 = 02D1			LOADAD	EQU	$02D1	;2-byte non-zero page load address
   688 = 02D3			ZLOADA	EQU	$02D3	;2-byte zero page load address
   689
   690 = 02D5			DSCTLN	EQU	$02D5	;2-byte disk sector length
   691 = 02D7			ACMISR	EQU	$02D7	;2-byte ACMI interrupt service rout:
   692 = 02D9			KRPDEL	EQU	$02D9	;1-byte auto-repeat delay
   693 = 02DA			KEYREP	EQU	$02DA	;1-byte auto-repeat rate
   694 = 02DB			NOCLIK	EQU	$02DB	;1-byte key click disable
   695 = 02DC			HELPFG	EQU	$02DC	;1-byte HELP key flag (0 = no HELP)
   696 = 02DD			DMASAV	EQU	$02DD	;1-byte SDMCTL save/restore
   697 = 02DE			PBPNT	EQU	$02DE	;1-byte printer buffer pointer
   698 = 02DF			PBUFSZ	EQU	$02DF	;1-byte printer buffer size
   699
   700 				;	EQU	$02E0	;4 bytes reserved for DOS
   701
   702 = 02E4			RAMSIZ	EQU	$02E4	;1-byte high RAM size
   703 = 02E5			MEMTOP	EQU	$02E5	;2-byte top of available user memory
   704 = 02E7			MEMLO	EQU	$02E7	;2-byte bottom of available user memory
   705 = 02E9			HNDLOD	EQU	$02E9	;1-byte user load flag (0 = no hand:
   706 = 02EA			DVSTAT	EQU	$02EA	;4-byte device status buffer
   707 = 02EE			CBAUDL	EQU	$02EE	;1-byte low cassette baud rate
   708 = 02EF			CBAUDH	EQU	$02EF	;1-byte high cassette baud rate
   709 = 02F0			CRSINH	EQU	$02F0	;1-byte cursor inhibit (0 = cursor on)
   710 = 02F1			KEYDEL	EQU	$02F1	;1-byte key debounce delay timer
   711 = 02F2			CH1	EQU	$02F2	;1-byte prior keyboard character
   712 = 02F3			CHACT	EQU	$02F3	;1-byte CHACTL shadow
   713 = 02F4			CHBAS	EQU	$02F4	;1-byte CHBASE shadow
   714
   715 = 02F5			NEWROW	EQU	$02F5	;1-byte draw destination row
   716 = 02F6			NEWCOL	EQU	$02F6	;2-byte draw destination column
   717 = 02F8			ROWINC	EQU	$02F8	;1-byte draw row increment
   718 = 02F9			COLINC	EQU	$02F9	;1-byte	draw column increment
   719
   720 = 02FA			CHAR	EQU	$02FA	;1-byte internal character
   721 = 02FB			ATACHR	EQU	$02FB	;1-byte ATASCII character or plot point
   722 = 02FC			CH	EQU	$02FC	;1-byte keyboard code (buffer)
   723 = 02FD			FILDAT	EQU	$02FD	;1-byte right fill data
   724 = 02FE			DSPFLG	EQU	$02FE	;1-byte control character display flag (0 = no)
   725 = 02FF			SSFLAG	EQU	$02FF	;1-byte start/stop flag (0 = not stopped)
   726 					;SPACE	4,10
   727 				;	Page Three Address Equates
   728
   729
   730 = 0300			DCB	EQU	$0300	;12-byte device control block
   731 = 0300			DDEVIC	EQU	$0300	;1-byte unit 1 bus ID
   732 = 0301			DUNIT	EQU	$0301	;1-byte unit number
   733 = 0302			DCOMND	EQU	$0302	;1-byte bus command
   734 = 0303			DSTATS	EQU	$0303	;1-byte command type/status return
   735 = 0304			DBUFLO	EQU	$0304	;1-byte low data buffer address
   736 = 0305			DBUFHI	EQU	$0305	;1-byte high data buffer address
   737 = 0306			DTIMLO	EQU	$0306	;1-byte timeout (seconds)
   738 = 0307			DUNUSE	EQU	$0307	;1-byte (not used)
   739 = 0308			DBYTLO	EQU	$0308	;1-byte low number of bytes to transfer
   740 = 0309			DBYTHI	EQU	$0309	;1-byte high number of bytes to transfer
   741 = 030A			DAUX1	EQU	$030A	;1-byte first command auxiliary
   742 = 030B			DAUX2	EQU	$030B	;1-byte second command auxiliary
   743
   744 = 030C			TIMER1	EQU	$030C	;2-byte initial baud rate timer value
   745 = 030E			JMPERS	EQU	$030E	;1-byte jumper options
   746 = 030F			CASFLG	EQU	$030F	;1-byte cassette I/O flag (0 = not cassette I/O)
   747 = 0310			TIMER2	EQU	$0310	;2-byte final baud rate timer value
   748 = 0312			TEMP1	EQU	$0312	;2-byte temporary
   749 = 0313			TEMP2	EQU	$0313	;1-byte temporary
   750 = 0314			PTIMOT	EQU	$0314	;1-byte printer timeout
   751 = 0315			TEMP3	EQU	$0315	;1-byte temporary
   752 = 0316			SAVIO	EQU	$0316	;1-byte saved serial data input indicator
   753 = 0317			TIMFLG	EQU	$0317	;1-byte timeout flag (0 = timeout)
   754 = 0318			STACKP	EQU	$0318	;1-byte SIO saved stack pointer
   755 = 0319			TSTAT	EQU	$0319	;1-byte temporary status
   756
   757 = 031A			HATABS	EQU	$031A	;35-byte handler address table
   758
   759 = 033D			PUPBT1	EQU	$033D	;1-byte power-up validation byte 1
   760 = 033E			PUPBT2	EQU	$033E	;1-byte power-up validation byte 2
   761 = 033F			PUPBT3	EQU	$033F	;1-byte power-up validation byte 3
   762
   763 = 0340			IOCB	EQU	$0340	;128-byte I/O control blocks area
   764 = 0340			ICHID	EQU	$0340	;1-byte handler ID ($FF = free)
   765 = 0341			ICDNO	EQU	$0341	;1-byte device number
   766 = 0342			ICCOM	EQU	$0342	;1-byte command code
   767 = 0343			ICSTA	EQU	$0343	;1-byte status of last action
   768 = 0344			ICBAL	EQU	$0344	;1-byte low buffer address
   769 = 0345			ICBAH	EQU	$0345	;1-byte high buffer address
   770 = 0346			ICPTL	EQU	$0346	;1-byte low PUT-BYTE routine address-1
   771 = 0347			ICPTH	EQU	$0347	;1-byte high PUT-BYTE routine address-1
   772 = 0348			ICBLL	EQU	$0348	;1-byte low buffer length
   773 = 0349			ICBLH	EQU	$0349	;1-byte high buffer length
   774 = 034A			ICAX1	EQU	$034A	;1-byte first auxiliary information
   775 = 034B			ICAX2	EQU	$034B	;1-byte second auxiliary information
   776 = 034C			ICSPR	EQU	$034C	;4-byte work area
   777
   778 = 03C0			PRNBUF	EQU	$03C0	;40-byte printer buffer
   779 = 03E8			SUPERF	EQU	$03E8	;1-byte editor super function flag :
   780 = 03E9			CKEY	EQU	$03E9	;1-byte cassette boot request flag :
   781 = 03EA			CASSBT	EQU	$03EA	;1-byte cassette boot flag (0 = not:
   782 = 03EB			CARTCK	EQU	$03EB	;1-byte cartridge equivalence checksum
   783 = 03EC			DERRF	EQU	$03EC	;1-byte screen OPEN error flag (0 = not)
   784
   785 				;	Remainder of Page Three Not Cleared upon Reset
   786
   787 = 03ED			ACMVAR	EQU	$03ED	;11 bytes reserved for ACMI
   788 = 03F8			BASICF	EQU	$03F8	;1-byte BASIC switch flag (0 = BASIC enabled)
   789 = 03F9			MINTLK	EQU	$03F9	;1-byte ACMI module interlock
   790 = 03FA			GINTLK	EQU	$03FA	;1-byte cartridge interlock
   791 = 03FB			CHLINK	EQU	$03FB	;2-byte loaded handler chain link
   792 = 03FD			CASBUF	EQU	$03FD	;3-byte first 3 bytes of cassette buffer
   793 					;SPACE	4,10
   794 				;	Page Four Address Equates
   795
   796
   797 				;	EQU	$0400	;128-byte remainder of cassette buffer
   798
   799 				;	Reserved for Application
   800
   801 = 0480			USAREA	EQU	$0480	;128 bytes reserved for application
   802 					;SPACE	4,10
   803 				;	Page Five Address Equates
   804
   805
   806 				;	Reserved for Application and Floating Point Package
   807
   808 				;	EQU	$0500	;256 bytes reserved for application and FPP
   809 					;SPACE	4,10
   810 				;	Floating Point Package Address Equates
   811
   812
   813 = 057E			LBPR1	EQU	$057E	;1-byte LBUFF preamble
   814 = 057F			LBPR2	EQU	$057F	;1-byte LBUFF preamble
   815 = 0580			LBUFF	EQU	$0580	;128-byte line buffer
   816
   817 = 05E0			PLYARG	EQU	$05E0	;6-byte floating point polynomial argument
   818 = 05E6			FPSCR	EQU	$05E6	;6-byte floating point temporary
   819 = 05EC			FPSCR1	EQU	$05EC	;6-byte floating point temporary
   820 					;SPACE	4,10
   821 				;	Page Six Address Equates
   822
   823
   824 				;	Reserved for Application
   825
   826 				;	EQU	$0600	;256 bytes reserved for application
   827 					;SPACE	4,10
   828 				;	LNBUG Address Equates
   829
   830
   831 					.IF	LNBUG
   832 				LNORG	EQU	$6000	;LNBUG origin
   833 				LNIRQ	EQU	$6033	;LNBUG IRQ entry
   834 				LNNMI	EQU	$8351	;LNBUG NMI vector
   835 					.ENDIF
   836 					;SPACE	4,10
   837 				;	Cartridge Address Equates
   838
   839
   840 = BFFA			CARTCS	EQU	$BFFA	;2-byte cartridge coldstart address
   841 = BFFC			CART	EQU	$BFFC	;1-byte cartridge present indicator
   842 = BFFD			CARTFG	EQU	$BFFD	;1-byte cartridge flags
   843 = BFFE			CARTAD	EQU	$BFFE	;2-byte cartridge start vector
   844 					;SPACE	4,10
   845 				;	CTIA/GTIA Address Equates
   846
   847
   848 = D000			CTIA	EQU	$D000	;CTIA/GTIA area
   849
   850 				;	Read/Write Addresses
   851
   852 = D01F			CONSOL	EQU	$D01F	;console switches and speaker control
   853
   854 				;	Read Addresses
   855
   856 = D000			M0PF	EQU	$D000	;missle 0 and playfield collision
   857 = D001			M1PF	EQU	$D001	;missle 1 and playfield collision
   858 = D002			M2PF	EQU	$D002	;missle 2 and playfield collision
   859 = D003			M3PF	EQU	$D003	;missle 3 and playfield collision
   860
   861 = D004			P0PF	EQU	$D004	;player 0 and playfield collision
   862 = D005			P1PF	EQU	$D005	;player 1 and playfield collision
   863 = D006			P2PF	EQU	$D006	;player 2 and playfield collision
   864 = D007			P3PF	EQU	$D007	;player 3 and playfield collision
   865
   866 = D008			M0PL	EQU	$D008	;missle 0 and player collision
   867 = D009			M1PL	EQU	$D009	;missle 1 and player collision
   868 = D00A			M2PL	EQU	$D00A	;missle 2 and player collision
   869 = D00B			M3PL	EQU	$D00B	;missle 3 and player collision
   870
   871 = D00C			P0PL	EQU	$D00C	;player 0 and player collision
   872 = D00D			P1PL	EQU	$D00D	;player 1 and player collision
   873 = D00E			P2PL	EQU	$D00E	;player 2 and player collision
   874 = D00F			P3PL	EQU	$D00F	;player 3 and player collision
   875
   876 = D010			TRIG0	EQU	$D010	;joystick trigger 0
   877 = D011			TRIG1	EQU	$D011	;joystick trigger 1
   878
   879 = D012			TRIG2	EQU	$D012	;cartridge interlock
   880 = D013			TRIG3	EQU	$D013	;ACMI module interlock
   881
   882 = D014			PAL	EQU	$D014	;PAL/NTSC indicator
   883
   884 				;	Write Addresses
   885
   886 = D000			HPOSP0	EQU	$D000	;player 0 horizontal position
   887 = D001			HPOSP1	EQU	$D001	;player 1 horizontal position
   888 = D002			HPOSP2	EQU	$D002	;player 2 horizontal position
   889 = D003			HPOSP3	EQU	$D003	;player 3 horizontal position
   890
   891 = D004			HPOSM0	EQU	$D004	;missle 0 horizontal position
   892 = D005			HPOSM1	EQU	$D005	;missle 1 horizontal position
   893 = D006			HPOSM2	EQU	$D006	;missle 2 horizontal position
   894 = D007			HPOSM3	EQU	$D007	;missle 3 horizontal position
   895
   896 = D008			SIZEP0	EQU	$D008	;player 0 size
   897 = D009			SIZEP1	EQU	$D009	;player 1 size
   898 = D00A			SIZEP2	EQU	$D00A	;player 2 size
   899 = D00B			SIZEP3	EQU	$D00B	;player 3 size
   900
   901 = D00C			SIZEM	EQU	$D00C	;missle sizes
   902
   903 = D00D			GRAFP0	EQU	$D00D	;player 0 graphics
   904 = D00E			GRAFP1	EQU	$D00E	;player 1 graphics
   905 = D00F			GRAFP2	EQU	$D00F	;player 2 graphics
   906 = D010			GRAFP3	EQU	$D010	;player 3 graphics
   907
   908 = D011			GRAFM	EQU	$D011	;missle graphics
   909
   910 = D012			COLPM0	EQU	$D012	;player-missle 0 color/luminance
   911 = D013			COLPM1	EQU	$D013	;player-missle 1 color/luminance
   912 = D014			COLPM2	EQU	$D014	;player-missle 2 color/luminance
   913 = D015			COLPM3	EQU	$D015	;player-missle 3 color/luminance
   914
   915 = D016			COLPF0	EQU	$D016	;playfield 0 color/luminance
   916 = D017			COLPF1	EQU	$D017	;playfield 1 color/luminance
   917 = D018			COLPF2	EQU	$D018	;playfield 2 color/luminance
   918 = D019			COLPF3	EQU	$D019	;playfield 3 color/luminance
   919
   920 = D01A			COLBK	EQU	$D01A	;background color/luminance
   921
   922 = D01B			PRIOR	EQU	$D01B	;priority select
   923 = D01C			VDELAY	EQU	$D01C	;vertical delay
   924 = D01D			GRACTL	EQU	$D01D	;graphic control
   925 = D01E			HITCLR	EQU	$D01E	;collision clear
   926 					;SPACE	4,10
   927 				;	PBI Address Equates
   928
   929
   930 = D100			PBI	EQU	$D100	;parallel bus interface area
   931
   932 				;	Read Addresses
   933
   934 = D1FF			PDVI	EQU	$D1FF	;parallel device IRQ status
   935
   936 				;	Write Addresses
   937
   938 = D1FF			PDVS	EQU	$D1FF	;parallel device select
   939 					;SPACE	4,10
   940 				;	POKEY Address Equates
   941
   942
   943 = D200			POKEY	EQU	$D200	;POKEY area
   944
   945 				;	Read Addresses
   946
   947 = D200			POT0	EQU	$D200	;potentiometer 0
   948 = D201			POT1	EQU	$D201	;potentiometer 1
   949 = D202			POT2	EQU	$D202	;potentiometer 2
   950 = D203			POT3	EQU	$D203	;potentiometer 3
   951 = D204			POT4	EQU	$D204	;potentiometer 4
   952 = D205			POT5	EQU	$D205	;potentiometer 5
   953 = D206			POT6	EQU	$D206	;potentiometer 6
   954 = D207			POT7	EQU	$D207	;potentiometer 7
   955
   956 = D208			ALLPOT	EQU	$D208	;potentiometer port state
   957 = D209			KBCODE	EQU	$D209	;keyboard code
   958 = D20A			RANDOM	EQU	$D20A	;random number generator
   959 = D20D			SERIN	EQU	$D20D	;serial port input
   960 = D20E			IRQST	EQU	$D20E	;IRQ interrupt status
   961 = D20F			SKSTAT	EQU	$D20F	;serial port and keyboard status
   962
   963 				;	Write Addresses
   964
   965 = D200			AUDF1	EQU	$D200	;channel 1 audio frequency
   966 = D201			AUDC1	EQU	$D201	;channel 1 audio control
   967
   968 = D202			AUDF2	EQU	$D202	;channel 2 audio frequency
   969 = D203			AUDC2	EQU	$D203	;channel 2 audio control
   970
   971 = D204			AUDF3	EQU	$D204	;channel 3 audio frequency
   972 = D205			AUDC3	EQU	$D205	;channel 3 audio control
   973
   974 = D206			AUDF4	EQU	$D206	;channel 4 audio frequency
   975 = D207			AUDC4	EQU	$D207	;channel 4 audio control
   976
   977 = D208			AUDCTL	EQU	$D208	;audio control
   978 = D209			STIMER	EQU	$D209	;start timers
   979 = D20A			SKRES	EQU	$D20A	;reset SKSTAT status
   980 = D20B			POTGO	EQU	$D20B	;start potentiometer scan sequence
   981 = D20D			SEROUT	EQU	$D20D	;serial port output
   982 = D20E			IRQEN	EQU	$D20E	;IRQ interrupt enable
   983 = D20F			SKCTL	EQU	$D20F	;serial port and keyboard control
   984 					;SPACE	4,10
   985 				;	PIA Address Equates
   986
   987
   988 = D300			PIA	EQU	$D300	;PIA area
   989
   990 				;	Read/Write Addresses
   991
   992 = D300			PORTA	EQU	$D300	;port A direction register or jacks 0 and 1
   993 = D301			PORTB	EQU	$D301	;port B direction register or memory control
   994
   995 = D302			PACTL	EQU	$D302	;port A control
   996 = D303			PBCTL	EQU	$D303	;port B control
   997 					;SPACE	4,10
   998 				;	ANTIC Address Equates
   999
  1000
  1001 = D400			ANTIC	EQU	$D400	;ANTIC area
  1002
  1003 				;	Read Addresses
  1004
  1005 = D40B			VCOUNT	EQU	$D40B	;vertical line counter
  1006 = D40C			PENH	EQU	$D40C	;light pen horizontal position
  1007 = D40D			PENV	EQU	$D40D	;light pen vertical position
  1008 = D40F			NMIST	EQU	$D40F	;NMI interrupt status
  1009
  1010 				;	Write Addresses
  1011
  1012 = D400			DMACTL	EQU	$D400	;DMA control
  1013 = D401			CHACTL	EQU	$D401	;character control
  1014 = D402			DLISTL	EQU	$D402	;low display list address
  1015 = D403			DLISTH	EQU	$D403	;high disply list address
  1016 = D404			HSCROL	EQU	$D404	;horizontal scroll
  1017 = D405			VSCROL	EQU	$D405	;vertical scroll
  1018 = D407			PMBASE	EQU	$D407	;player-missle base address
  1019 = D409			CHBASE	EQU	$D409	;character base address
  1020 = D40A			WSYNC	EQU	$D40A	;wait for HBLANK synchronization
  1021 = D40E			NMIEN	EQU	$D40E	;NMI enable
  1022 = D40F			NMIRES	EQU	$D40F	;NMI interrupt status reset
  1023 					;SPACE	4,10
  1024 				;	PBI RAM Address Equates
  1025
  1026
  1027 = D600			PBIRAM	EQU	$D600	;parallel bus interface RAM area
  1028 					;SPACE	4,10
  1029 				;	ACMI Address Equates
  1030
  1031
  1032 					.IF	ACMI
  1033 					.ENDIF
  1034 					;SPACE	4,10
  1035 				;	Floating Point Package Address Equates
  1036
  1037
  1038 = D800			AFP	EQU	$D800	;convert ASCII to floating point
  1039 = D8E6			FASC	EQU	$D8E6	;convert floating point to ASCII
  1040 = D9AA			IFP	EQU	$D9AA	;convert integer to floating point
  1041 = D9D2			FPI	EQU	$D9D2	;convert floating point to integer
  1042 = DA44			ZFR0	EQU	$DA44	;zero FR0
  1043 = DA46			ZF1	EQU	$DA46	;zero floating point number
  1044 = DA60			FSUB	EQU	$DA60	;subtract floating point numbers
  1045 = DA66			FADD	EQU	$DA66	;add floating point numbers
  1046 = DADB			FMUL	EQU	$DADB	;multiply floating point numbers
  1047 = DB28			FDIV	EQU	$DB28	;divide floating point numbers
  1048 = DD40			PLYEVL	EQU	$DD40	;evaluate floating point polynomial
  1049 = DD89			FLD0R	EQU	$DD89	;load floating point number
  1050 = DD8D			FLD0P	EQU	$DD8D	;load floating point number
  1051 = DD98			FLD1R	EQU	$DD98	;load floating point number
  1052 = DD9C			FLD1P	EQU	$DD9C	;load floating point number
  1053 = DDA7			FST0R	EQU	$DDA7	;store floating point number
  1054 = DDAB			FST0P	EQU	$DDAB	;store floating point number
  1055 = DDB6			FMOVE	EQU	$DDB6	;move floating point number
  1056 = DECD			LOG	EQU	$DECD	;calculate floating point logarithm
  1057 = DED1			LOG10	EQU	$DED1	;calculate floating point base 10 logarithm
  1058 = DDC0			EXP	EQU	$DDC0	;calculate floating point exponentiation
  1059 = DDCC			EXP10	EQU	$DDCC	;calculate floating point base 10 exponentiation
  1060 					;SPACE	4,10
  1061 				;	Parallel Device Address Equates
  1062
  1063
  1064 = D803			PDID1	EQU	$D803	;parallel device ID 1
  1065 = D805			PDIOV	EQU	$D805	;parallel device I/O vector
  1066 = D808			PDIRQV	EQU	$D808	;parallel device IRQ vector
  1067 = D80B			PDID2	EQU	$D80B	;parallel device ID 2
  1068 = D80D			PDVV	EQU	$D80D	;parallel device vector table
  1069 					;SPACE	4,10
  1070 				;	Device Handler Vector Table Address Equates
  1071
  1072
  1073 = E400			EDITRV	EQU	$E400	;editor handler vector table
  1074 = E410			SCRENV	EQU	$E410	;screen handler vector table
  1075 = E420			KEYBDV	EQU	$E420	;keyboard handler vector table
  1076 = E430			PRINTV	EQU	$E430	;printer handler vector table
  1077 = E440			CASETV	EQU	$E440	;cassette handler vector table
  1078 					;SPACE	4,10
  1079 				;	Jump Vector Address Equates
  1080
  1081
  1082 = E450			DINITV	EQU	$E450	;vector to initialize DIO
  1083 = E453			DSKINV	EQU	$E453	;vector to DIO
  1084 = E456			CIOV	EQU	$E456	;vector to CIO
  1085 = E459			SIOV	EQU	$E459	;vector to SIO
  1086 = E45C			SETVBV	EQU	$E45C	;vector to set VBLANK parameters
  1087 = E45F			SYSVBV	EQU	$E45F	;vector to process immediate VBLANK NMI
  1088 = E462			XITVBV	EQU	$E462	;vector to process deferred VBLANK NMI
  1089 = E465			SIOINV	EQU	$E465	;vector to initialize SIO
  1090 = E468			SENDEV	EQU	$E468	;vector to enable SEND
  1091 = E46B			INTINV	EQU	$E46B	;vector to initialize interrupt handler
  1092 = E46E			CIOINV	EQU	$E46E	;vector to initialize CIO
  1093 = E471			BLKBDV	EQU	$E471	;vector to power-up display (formerly memo pad)
  1094 = E474			WARMSV	EQU	$E474	;vector to warmstart
  1095 = E477			COLDSV	EQU	$E477	;vector to coldstart
  1096 = E47A			RBLOKV	EQU	$E47A	;vector to read cassette block
  1097 = E47D			CSOPIV	EQU	$E47D	;vector to open cassette for input
  1098 = E480			PUPDIV	EQU	$E480	;vector to power-up display
  1099 = E483			SLFTSV	EQU	$E483	;vector to self-test
  1100 = E486			PHENTV	EQU	$E486	;vector to enter peripheral handler
  1101 = E489			PHUNLV	EQU	$E489	;vector to unlink peripheral handler
  1102 = E48C			PHINIV	EQU	$E48C	;vector to initialize peripheral handler
  1103 					;SPACE	4,10
  1104 				;	Generic Parallel Device Handler Vector Table Address Equates
  1105
  1106
  1107 = E48F			GPDVV	EQU	$E48F	;generic parallel device handler vector table
  1108 				;	;SUBTTL	'Miscellaneous Address Equates'
  1109 					;SPACE	4,10
  1110 				;	Self-test Page Zero Address Equates
  1111
  1112
  1113 = 0080			STTIME	EQU	$0080	;2-byte main screen timeout timer
  1114 = 0082			STAUT	EQU	$0082	;1-byte auto-mode flag
  1115 = 0083			STJMP	EQU	$0083	;3-byte ANTIC jump instruction
  1116 = 0086			STSEL	EQU	$0086	;1-byte selection
  1117 = 0087			STPASS	EQU	$0087	;1-byte pass
  1118 = 0088			STSPP	EQU	$0088	;1-byte SELECT previously pressed flag
  1119 				;	EQU	$0089	;1-byte (not used)
  1120 = 008A			STKST	EQU	$008A	;1-byte keyboard self-test flag (0 = not)
  1121 = 008B			STCHK	EQU	$008B	;2-byte checksum
  1122 = 008D			STSMM	EQU	$008D	;1-byte screen memory mask
  1123 = 008E			STSMP	EQU	$008E	;1-byte screen memory pointer
  1124 = 008F			ST1K	EQU	$008F	;1-byte current 1K of memory to test
  1125 = 0090			STPAG	EQU	$0090	;2-byte current page to test
  1126 = 0092			STPC	EQU	$0092	;1-byte page count
  1127 = 0093			STMVAL	EQU	$0093	;1-byte correct value for memory test
  1128 = 0094			STSKP	EQU	$0094	;1-byte simulated keypress index
  1129 = 0095			STTMP1	EQU	$0095	;2-byte temporary
  1130 = 0097			STVOC	EQU	$0097	;1-byte current voice indicator
  1131 = 0098			STNOT	EQU	$0098	;1-byte current note counter
  1132 = 0099			STCDI	EQU	$0099	;1-byte cleft display pointer
  1133 = 009A			STCDA	EQU	$009A	;1-byte cleft data pointer
  1134 = 009B			STTMP2	EQU	$009B	;2-byte temporary
  1135 = 009D			STTMP3	EQU	$009D	;1-byte temporary
  1136 = 009E			STADR1	EQU	$009E	;2-byte temporary address
  1137 = 00A0			STADR2	EQU	$00A0	;2-byte temporary address
  1138 = 00A2			STBL	EQU	$00A2	;1-byte blink counter
  1139 = 00A3			STTMP4	EQU	$00A3	;1-byte temporary
  1140 = 00A4			STLM	EQU	$00A4	;1-byte LED mask
  1141 = 00A5			STTMP5	EQU	$00A5	;1-byte temporary
  1142 					;SPACE	4,10
  1143 				;	Self-test Address Equates
  1144
  1145
  1146 = 3000			ST3000	EQU	$3000	;screen memory
  1147 = 3002			ST3002	EQU	$3002	;cleft display
  1148 = 3004			ST3004	EQU	$3004	;"VOICE #" text display
  1149 = 300B			ST300B	EQU	$300B	;voice number display
  1150 = 301C			ST301C	EQU	$301C	;START key display
  1151 = 301E			ST301E	EQU	$301E	;SELECT key display
  1152 = 3020			ST3020	EQU	$3020	;OPTION key display, first 8K ROM display
  1153 = 3021			ST3021	EQU	$3021	;keyboard character display
  1154 = 3022			ST3022	EQU	$3022	;keyboard text display
  1155 = 3024			ST3024	EQU	$3024	;second 8K ROM display
  1156 = 3028			ST3028	EQU	$3028	;"RAM" text display
  1157 = 3038			ST3038	EQU	$3038	;RAM display
  1158 = 303C			ST303C	EQU	$303C	;fifth note display
  1159 = 304C			ST304C	EQU	$304C	;"B S" text display
  1160 = 3052			ST3052	EQU	$3052	;tab key display
  1161 = 3062			ST3062	EQU	$3062	;cleft display
  1162 = 306D			ST306D	EQU	$306D	;return key display
  1163 = 3072			ST3072	EQU	$3072	;control key display
  1164 = 3092			ST3092	EQU	$3092	;"SH" text display
  1165 = 309E			ST309E	EQU	$309E	;sixth note display
  1166 = 30AB			ST30AB	EQU	$30AB	;"SH" text display
  1167 = 30B7			ST30B7	EQU	$30B7	;"S P A C E   B A R" text display
  1168 = 30C1			ST30C1	EQU	$30C1	;cleft display
  1169 = 30C2			ST30C2	EQU	$30C2	;cleft display
  1170 = 30C7			ST30C7	EQU	$30C7	;third note display
  1171 = 30CA			ST30CA	EQU	$30CA	;fourth note display
  1172 = 30F8			ST30F8	EQU	$30F8	;third note display
  1173 = 3100			ST3100	EQU	$3100	;screen memory
  1174 = 3121			ST3121	EQU	$3121	;cleft display
  1175 = 3122			ST3122	EQU	$3122	;cleft display
  1176 = 313C			ST313C	EQU	$313C	;fifth note display
  1177 = 3150			ST3150	EQU	$3150	;first line of staff display
  1178 = 3154			ST3154	EQU	$3154	;first note display
  1179 = 3181			ST3181	EQU	$3181	;cleft display
  1180 = 3182			ST3182	EQU	$3182	;cleft display
  1181 = 3186			ST3186	EQU	$3186	;second note display
  1182 = 318C			ST318C	EQU	$318C	;fifth note display
  1183 = 31B0			ST31B0	EQU	$31B0	;second line of staff display
  1184 = 31C2			ST31C2	EQU	$31C2	;cleft display
  1185 = 31CA			ST31CA	EQU	$31CA	;fourth note display
  1186 = 31EE			ST31EE	EQU	$31EE	;sixth note display
  1187 = 31F1			ST31F1	EQU	$31F1	;cleft display
  1188 = 3210			ST3210	EQU	$3210	;third line of staff display
  1189 = 321A			ST321A	EQU	$321A	;fourth note display
  1190 = 3248			ST3248	EQU	$3248	;third note display
  1191 = 3270			ST3270	EQU	$3270	;fourth line of staff display
  1192 = 32D0			ST32D0	EQU	$32D0	;fifth line of staff display
  1193 				;	;SUBTTL	'Macro Definitions'
  1194 				;	;SPACE	4,10
  1195 				;	ORG - Fix Address
  1196 				*
  1197 				*	ORG sets the origin counter to the value specified as an
  1198 				*	argument.  If the current origin counter is less than the
  1199 				*	argument, ORG fills the intervening bytes with zero and
  1200 				*	issues a message to document the location and number of
  1201 				*	bytes that are zero filled.
  1202 				*
  1203 				*	ENTRY	ORG	address
  1204 				*
  1205 				*
  1206 				*	EXIT
  1207 				*		Origin counter set to specified address.
  1208 				*		Message issued if zero fill required.
  1209 				*
  1210 				*	CHANGES
  1211 				*		-none-
  1212 				*
  1213 				*	CALLS
  1214 				*		-none-
  1215 				*
  1216 				*	NOTES
  1217 				*		Due to ECHO limitiation of 255 iterations, ORG is
  1218 				*		recursive.
  1219 				*		If the current origin counter value is beyond the
  1220 				*		argument, ORG generates an error.
  1221 				*
  1222 				*	MODS
  1223 				*		R. K. Nordin	11/01/83
  1224
  1225 				;	;SUBTTL	'First 8K ROM Identification and Checksum'
  1226 					;SPACE	4,10
  1227 					ORG	$C000
  1228 					;SPACE	4,10
  1229 				;	First 8K ROM Identification and Checksum
  1230
  1231
  1232 C000 11 92			.word	$9211				;reserved for checksum
  1233 C002 10 05 83			.byte	IDDAY,IDMON,IDYEAR		;date (day, month, year)
  1234 C005 00				.byte	$00				;not used
  1235 C006 42 42 00 00 01		.byte	IDPN1,IDPN2,IDPN3,IDPN4,IDPN5	;part number
  1236 C00B 02				.byte	IDREV				;revision number
  1237 				;	;SUBTTL	'Interrupt Handler'
  1238 					;SPACE	4,10
  1239 				;	IIH - Initialize Interrupt Handler
  1240 				*
  1241 				*	ENTRY	JSR	IIH
  1242 				*		TRIG3 = ACMI module interlock
  1243 				*		TRIG2 = cartridge interlock
  1244 				*
  1245 				*	MODS
  1246 				*		Original Author Unknown
  1247 				*		1. Bring closer to Coding Standard (object unchanged).
  1248 				*		   R. K. Nordin	11/01/83
  1249
  1250
  1251 = C00C			IIH	=	*	;entry
  1252
  1253 C00C A9 40			LDA	#$40
  1254 C00E 8D 0E D4			STA	NMIEN	;disable DLI and enable VBLANK NMI
  1255
  1256 C011 AD 13 D0			LDA	TRIG3	;cartridge interlock
  1257 C014 8D FA 03			STA	GINTLK	;cartridge interlock status
  1258
  1259 					.IF	ACMI
  1260 					.ENDIF
  1261
  1262 C017 60				RTS		;return
  1263 					;SPACE	4,10
  1264 				;	NMI - Process NMI
  1265 				*
  1266 				*	ENTRY	JMP	NMI
  1267 				*
  1268 				*	EXIT
  1269 				*		Exits via appropriate vector to process NMI
  1270 				*
  1271 				*	MODS
  1272 				*		Original Author Unknown
  1273 				*		1. Bring closer to Coding Standard (object unchanged).
  1274 				*		   R. K. Nordin	11/01/83
  1275
  1276
  1277 = C018			NMI	=	*	;entry
  1278
  1279 				;	ASSERT	$C0=high NMI	;for compatibility with LNBUG
  1280
  1281 				;	Check for display list NMI.
  1282
  1283 C018 2C 0F D4			BIT	NMIST
  1284 C01B 10 03			BPL	NMI1		;if not display list NMI
  1285
  1286 C01D 6C 00 02			JMP	(VDSLST)	;process display list NMI, return
  1287
  1288 				;	Initialize.
  1289
  1290 C020 D8			NMI1	CLD
  1291
  1292 				;	Save registers.
  1293
  1294 C021 48				PHA		;save A
  1295 C022 8A				TXA
  1296 C023 48				PHA		;save X
  1297 C024 98				TYA
  1298 C025 48				PHA		;save Y
  1299
  1300 				;	Reset NMI status.
  1301
  1302 C026 8D 0F D4			STA	NMIRES		;reset NMI status
  1303
  1304 				;	Process NMI.
  1305
  1306 					.IF	LNBUG
  1307 					LDA	LNFLG		;LNBUG flag
  1308 					BNE	NMI2		;if LNBUG
  1309
  1310 					JMP	(VVBLKI)	;process immediate VBLANK NMI, return
  1311
  1312 				NMI2	JMP	(LNNMI)		;invoke LNBUG NMI routine, return
  1313 					.ELSE
  1314 C029 6C 22 02			JMP	(VVBLKI)	;process immediate VBLANK NMI, return
  1315 					.ENDIF
  1316 					;SPACE	4,10
  1317 				;	IRQ - Process IRQ
  1318 				*
  1319 				*	ENTRY	JMP	IRQ
  1320 				*
  1321 				*	EXIT
  1322 				*		Exits via VIMIRQ vector
  1323 				*
  1324 				*	MODS
  1325 				*		Original Author Unknown
  1326 				*		1. Bring closer to Coding Standard (object unchanged).
  1327 				*		   R. K. Nordin	11/01/83
  1328
  1329
  1330 = C02C			IRQ	=	*		;entry
  1331
  1332 				;	Initialize.
  1333
  1334 C02C D8				CLD
  1335
  1336 				;	Process IRQ.
  1337
  1338 					.IF	LNBUG
  1339 					BIT	LNFLG
  1340 					BMI	IRQ1		;if LNBUG on
  1341
  1342 					JMP	(VIMIRQ)	;process immediate IRQ, return
  1343
  1344 				IRQ1	JMP	LNIRQ		;invoke LNBUG IRQ routine, return
  1345 					.ELSE
  1346 C02D 6C 16 02			JMP	(VIMIRQ)	;process immediate IRQ, return
  1347 					.ENDIF
  1348 					;SPACE	4,10
  1349 				;	IIR - Process Immediate IRQ
  1350 				*
  1351 				*	ENTRY	JMP	IIR
  1352 				*
  1353 				*	EXIT
  1354 				*		Exits via appropriate vector to process IRQ
  1355 				*
  1356 				*	MODS
  1357 				*		Original Author Unknown
  1358 				*		1. Bring closer to Coding Standard (object unchanged).
  1359 				*		   R. K. Nordin	11/01/83
  1360
  1361
  1362 = C030			IIR	=	*	;entry
  1363
  1364 				;	Initialize.
  1365
  1366 C030 48				PHA		;save A
  1367
  1368 				;	Check for serial input ready IRQ.
  1369
  1370 C031 AD 0E D2			LDA	IRQST	;IRQ status
  1371 C034 29 20			AND	#$20	;serial input ready
  1372 C036 D0 0D			BNE	IIR1	;if not serial input ready
  1373
  1374 				;	Process serial input IRQ.
  1375
  1376 C038 A9 DF			LDA	#$DF	; .not($20)	;all other interrupts
  1377 C03A 8D 0E D2			STA	IRQEN		;enable all other interrupts
  1378 C03D A5 10			LDA	POKMSK
  1379 C03F 8D 0E D2			STA	IRQEN
  1380 C042 6C 0A 02			JMP	(VSERIN)	;process serial input ready IRQ, return
  1381
  1382 				;	Process possible ACMI IRQ.
  1383
  1384 C045			IIR1
  1385 					.IF	ACMI
  1386 					.ENDIF
  1387
  1388 				;	Initialize further.
  1389
  1390 C045 8A				TXA
  1391 C046 48				PHA		;save X
  1392
  1393 				;	Check for parallel device IRQ.
  1394
  1395 C047 AD FF D1			LDA	PDVI		;parallel device IRQ statuses
  1396 C04A 2D 49 02			AND	PDIMSK		;select desired IRQ statuses
  1397 C04D F0 03			BEQ	IIR2		;if no desired IRQ
  1398
  1399 				;	Process parallel device IRQ.
  1400
  1401 C04F 6C 38 02			JMP	(VPIRQ)		;process parallel device IR:
  1402
  1403 				;	Check other types of IRQ.
  1404
  1405 C052 A2 06		IIR2	LDX	#TIRQL-1-1	;offset to next to last entry
  1406
  1407 C054 BD CF C0		IIR3	LDA	TIRQ,X		;IRQ type
  1408 C057 E0 05			CPX	#5		;offset to serial out complete
  1409 C059 D0 04			BNE	IIR4		;if not serial out complete
  1410
  1411 C05B 25 10			AND	POKMSK		;and with POKEY IRQ enable
  1412 C05D F0 05			BEQ	IIR5		;if serial out complete not enabled
  1413
  1414 C05F 2C 0E D2		IIR4	BIT	IRQST		;IRQ interrupt status
  1415 C062 F0 06			BEQ	IIR6		;if interrupt found
  1416
  1417 C064 CA			IIR5	DEX
  1418 C065 10 ED			BPL	IIR3		;if not done
  1419
  1420 				;	Coninue IRQ processing.
  1421
  1422 C067 4C A0 C0			JMP	CIR		;continue IRQ processing, return
  1423
  1424 				;	Enable other interrupts.
  1425
  1426 C06A 49 FF		IIR6	EOR	#$FF		;complement mask
  1427 C06C 8D 0E D2			STA	IRQEN		;enable all others
  1428 C06F A5 10			LDA	POKMSK		;POKEY IRQ mask
  1429 C071 8D 0E D2			STA	IRQEN		;enable indicated IRQ's
  1430
  1431 				;	Check for BREAK key IRQ.
  1432
  1433 C074 E0 00			CPX	#0
  1434 C076 D0 05			BNE	IIR7		;if not BREAK key IRQ
  1435
  1436 				;	Check for keyboard disabled.
  1437
  1438 C078 AD 6D 02			LDA	KEYDIS
  1439 C07B D0 23			BNE	CIR		;if keyboard disabled, cont:
  1440
  1441 				;	Process IRQ.
  1442
  1443 C07D BD D7 C0		IIR7	LDA	TOIH,X		;offset to interrupt handler
  1444 C080 AA				TAX
  1445 C081 BD 00 02			LDA	INTABS,X	;interrupt handler address
  1446 C084 8D 8C 02			STA	JVECK
  1447 C087 BD 01 02			LDA	INTABS+1,X
  1448 C08A 8D 8D 02			STA	JVECK+1
  1449 C08D 68				PLA
  1450 C08E AA				TAX			;restore X
  1451 C08F 6C 8C 02			JMP	(JVECK)		;process interrupt, return
  1452 					;SPACE	4,10
  1453 				;	BIR - Process BREAK Key IRQ
  1454 				*
  1455 				*	ENTRY	JMP	BIR
  1456 				*
  1457 				*	EXIT
  1458 				*		Exits via RTI
  1459 				*
  1460 				*	MODS
  1461 				*		Original Author Unknown
  1462 				*		1. Bring closer to Coding Standard (object unchanged).
  1463 				*		   R. K. Nordin	11/01/83
  1464
  1465
  1466 = C092			BIR	=	*	;entry
  1467
  1468 				;	Process BREAK.
  1469
  1470 C092 A9 00			LDA	#0
  1471 C094 85 11			STA	BRKKEY	;clear BREAK key flag
  1472 C096 8D FF 02			STA	SSFLAG	;clear start/stop flag
  1473 C099 8D F0 02			STA	CRSINH	;enable cursor
  1474 C09C 85 4D			STA	ATRACT	;turn off attract-mode
  1475
  1476 				;	Exit.
  1477
  1478 C09E 68			BIR1	PLA		;restore A
  1479 C09F 40				RTI		;return
  1480 					;SPACE	4,10
  1481 				;	CIR - Continue IRQ Processing
  1482 				*
  1483 				*	ENTRY	JMP	CIR
  1484 				*
  1485 				*	EXIT
  1486 				*		Exits via appropriate vector to process IRQ or to XIR
  1487 				*
  1488 				*	MODS
  1489 				*		Original Author Unknown
  1490 				*		1. Bring closer to Coding Standard (object unchanged).
  1491 				*		   R. K. Nordin	11/01/83
  1492
  1493
  1494 = C0A0			CIR	=	*		;entry
  1495
  1496 				;	Initialize.
  1497
  1498 C0A0 68				PLA			;saved ???
  1499 C0A1 AA				TAX
  1500
  1501 				;	Check for port A interrupt.
  1502
  1503 C0A2 2C 02 D3			BIT	PACTL		;port A control
  1504 C0A5 10 06			BPL	CIR1		;if not port A interrupt
  1505
  1506 				;	Process proceed line IRQ.
  1507
  1508 C0A7 AD 00 D3			LDA	PORTA		;clear interrupt status bit
  1509 C0AA 6C 02 02			JMP	(VPRCED)	;process proceed line IRQ, return
  1510
  1511 				;	Check for port B interrupt.
  1512
  1513 C0AD 2C 03 D3		CIR1	BIT	PBCTL		;port B control
  1514 C0B0 10 06			BPL	CIR2		;if not port B interrupt
  1515
  1516 				;	Process interrupt line IRQ.
  1517
  1518 C0B2 AD 01 D3			LDA	PORTB		;clear interrupt status bit
  1519 C0B5 6C 04 02			JMP	(VINTER)	;process interrupt line IRQ, return
  1520
  1521 				;	Check for BRK instruction IRQ.
  1522
  1523 C0B8 68			CIR2	PLA
  1524 C0B9 8D 8C 02			STA	JVECK
  1525
  1526 C0BC 68				PLA			;saved P
  1527 C0BD 48				PHA			;resave P
  1528 C0BE 29 10			AND	#$10		;B bit of P register
  1529 C0C0 F0 07			BEQ	CIR3		;if not BRK instruction IRQ
  1530
  1531 				;	Process BRK instruction IRQ.
  1532
  1533 C0C2 AD 8C 02			LDA	JVECK
  1534 C0C5 48				PHA
  1535 C0C6 6C 06 02			JMP	(VBREAK)	;process BRK instruction IRQ, return
  1536
  1537 				;	Exit IRQ processing.
  1538
  1539 C0C9 AD 8C 02		CIR3	LDA	JVECK
  1540 C0CC 48				PHA
  1541 				;	JMP	XIR		;exit IRQ processing, return
  1542 					;SPACE	4,10
  1543 				;	XIR - Exit IRQ Processing
  1544 				*
  1545 				*	ENTRY	JMP	XIR
  1546 				*
  1547 				*	EXIT
  1548 				*		Exits to RIR
  1549 				*
  1550 				*	MODS
  1551 				*		Original Author Unknown
  1552 				*		1. Bring closer to Coding Standard (object unchanged).
  1553 				*		   R. K. Nordin	11/01/83
  1554
  1555
  1556 = C0CD			XIR	=	*	;entry
  1557 C0CD 68				PLA		;restore A
  1558 				;	JMP	RIR	;return from interrupt
  1559 					;SPACE	4,10
  1560 				;	RIR - Return from Interrupt
  1561 				*
  1562 				*	ENTRY	JMP	RIR
  1563 				*
  1564 				*	EXIT
  1565 				*		Exits via RTI
  1566 				*
  1567 				*	MODS
  1568 				*		Original Author Unknown
  1569 				*		1. Bring closer to Coding Standard (object unchanged).
  1570 				*		   R. K. Nordin	11/01/83
  1571
  1572
  1573 = C0CE			RIR	=	*	;entry
  1574 C0CE 40				RTI		;return
  1575 					;SPACE	4,10
  1576 				;	AIR - Process ACMI IRQ
  1577 				*
  1578 				*	ENTRY	JMP	AIR
  1579 				*
  1580 				*	EXIT	Exits via ASMISR vector
  1581 				*
  1582 				*	MODS
  1583 				*		Original Author Unknown
  1584 				*		1. Bring closer to Coding Standard (object unchanged).
  1585 				*		   R. K. Nordin	11/01/83
  1586
  1587
  1588 					.IF	ACMI
  1589 					.ENDIF
  1590 					;SPACE	4,10
  1591 				;	TIRQ - Table of IRQ Types
  1592 				*
  1593 				*	Entry n is the interrupt indicator of priority n (0 is lowest).
  1594 				*
  1595 				*	NOTES
  1596 				*		Problem: entry 7 (serial input ready) not used.
  1597
  1598
  1599 C0CF 80			TIRQ	.byte	$80	;0 - BREAK key IRQ
  1600 C0D0 40				.byte	$40	;1 - keyboard IRQ
  1601 C0D1 04				.byte	$04	;2 - timer 4 IRQ
  1602 C0D2 02				.byte	$02	;3 - timer 2 IRQ
  1603 C0D3 01				.byte	$01	;4 - timer 1 IRQ
  1604 C0D4 08				.byte	$08	;5 - serial output complete IRQ
  1605 C0D5 10				.byte	$10	;6 - serial output ready IRQ
  1606 C0D6 20				.byte	$20	;7 - serial input ready IRQ
  1607
  1608 = 0008			TIRQL	=	*-TIRQ	;length
  1609 					;SPACE	4,10
  1610 				;	TOIH - Table of Offsets to Interrupt Handlers
  1611 				*
  1612 				*	Entry n is the offset to the interrupt handler vector
  1613 				*	corresponding to entry n of TIRQ.
  1614 				*
  1615 				*	NOTES
  1616 				*		Problem: entry 7 (serial input ready) not used.
  1617
  1618
  1619 C0D7 36			TOIH	.byte	BRKKY-INTABS	;0 - BREAK key IRQ
  1620 C0D8 08				.byte	VKEYBD-INTABS	;1 - keyboard IRQ
  1621 C0D9 14				.byte	VTIMR4-INTABS	;2 - timer 4 IRQ
  1622 C0DA 12				.byte	VTIMR2-INTABS	;3 - timer 2 IRQ
  1623 C0DB 10				.byte	VTIMR1-INTABS	;4 - timer 1 IRQ
  1624 C0DC 0E				.byte	VSEROC-INTABS	;5 - serial output complete IRQ
  1625 C0DD 0C				.byte	VSEROR-INTABS	;6 - serial output ready IRQ
  1626 C0DE 0A				.byte	VSERIN-INTABS	;7 - serial input ready IRQ
  1627 					;SPACE	4,10
  1628 				;	WFR - Wait for RESET
  1629 				*
  1630 				*	WFR loops forever.
  1631 				*
  1632 				*	ENTRY	JMP	WFR
  1633 				*
  1634 				*	EXIT
  1635 				*		Does not exit
  1636 				*
  1637 				*	MODS
  1638 				*		Original Author Unknown
  1639 				*		1. Bring closer to Coding Standard (object unchanged).
  1640 				*		   R. K. Nordin	11/01/83
  1641
  1642
  1643 = C0DF			WFR	=	*	;entry
  1644
  1645 				;	Loop forever, waiting for RESET.
  1646
  1647 C0DF 4C DF C0		WFR1	JMP	WFR1	;loop
  1648 					;SPACE	4,10
  1649 				;	IVNM - Process Immediate VBLANK NMI
  1650 				*
  1651 				*	ENTRY	JMP	IVNM
  1652 				*
  1653 				*	EXIT
  1654 				*		Exits to DVNM or via VVBLKD vector
  1655 				*
  1656 				*	MODS
  1657 				*		Original Author Unknown
  1658 				*		1. Bring closer to Coding Standard (object unchanged).
  1659 				*		   R. K. Nordin	11/01/83
  1660
  1661
  1662 = C0E2			IVNM	=	*		;entry
  1663
  1664 				;	Increment frame counter and attract-mode counter.
  1665
  1666 C0E2 E6 14			INC	RTCLOK+2	;increment low frame counter
  1667 C0E4 D0 08			BNE	IVN1		;if low counter not zero
  1668
  1669 C0E6 E6 4D			INC	ATRACT		;increment attract-mode counter/flag
  1670 C0E8 E6 13			INC	RTCLOK+1	;increment middle frame counter
  1671 C0EA D0 02			BNE	IVN1		;if middle counter not zero
  1672
  1673 C0EC E6 12			INC	RTCLOK		;increment high frame counter
  1674
  1675 				;	Set attract-mode effects.
  1676
  1677 C0EE A9 FE		IVN1	LDA	#$FE		;select no luminance change
  1678 C0F0 A2 00			LDX	#0		;select no color shift
  1679 C0F2 A4 4D			LDY	ATRACT		;attract-mode timer/flag
  1680 C0F4 10 06			BPL	IVN2		;if not attract-mode
  1681
  1682 C0F6 85 4D			STA	ATRACT		;ensure continued attract-mode
  1683 C0F8 A6 13			LDX	RTCLOK+1	;select color shift
  1684 C0FA A9 F6			LDA	#$F6		;select lower luminance
  1685
  1686 C0FC 85 4E		IVN2	STA	DRKMSK		;attract-mode luminance
  1687 C0FE 86 4F			STX	COLRSH		;attract-mode color shift
  1688
  1689 				;	Update COLPF1 (in case fine scrolling and critical :
  1690
  1691 C100 AD C5 02			LDA	COLOR1		;playfield 1 color
  1692 C103 45 4F			EOR	COLRSH		;modify color with attract-:
  1693 C105 25 4E			AND	DRKMSK		;modify with attract-mode l:
  1694 C107 8D 17 D0			STA	COLPF1		;set playfield 1 color/lumi:
  1695
  1696 				;	Process countdown timer 1.
  1697
  1698 C10A A2 00			LDX	#0		;indicate countdown timer 1
  1699 C10C 20 55 C2			JSR	DCT		;decrement countdown timer
  1700 C10F D0 03			BNE	IVN3		;if timer not expired
  1701
  1702 C111 20 4F C2			JSR	PTO		;process countdown timer 1 expiration
  1703
  1704 				;	Check for critical sction.
  1705
  1706 C114 A5 42		IVN3	LDA	CRITIC
  1707 C116 D0 08			BNE	IVN4		;if critical section
  1708
  1709 				;	Check for IRQ enabled.
  1710
  1711 C118 BA				TSX			;stack pointer
  1712 C119 BD 04 01			LDA	$0104,X		;stacked P
  1713 C11C 29 04			AND	#$04		;I (IRQ disable) bit
  1714 C11E F0 03			BEQ	IVN5		;if IRQ enabled
  1715
  1716 				;	Exit.
  1717
  1718 C120 4C 8A C2		IVN4	JMP	DVNM		;process deferred VBLANK NMI, return
  1719
  1720 				;	Process IRQ enabled non-critical section.
  1721
  1722 C123			IVN5
  1723
  1724 				;	Check for ACMI module change.
  1725
  1726 					.IF	ACMI
  1727 					.ENDIF
  1728
  1729 				;	Check for cartridge change.
  1730
  1731 C123 AD 13 D0			LDA	TRIG3		;cartridge interlock
  1732 C126 CD FA 03			CMP	GINTLK		;previous cartridge interlock status
  1733 C129 D0 B4			BNE	WFR		;if cartridge change, wait for RESET
  1734
  1735 				;	Set hardware registers from shadows.
  1736
  1737 C12B AD 0D D4			LDA	PENV
  1738 C12E 8D 35 02			STA	LPENV		;light pen vertical position
  1739 C131 AD 0C D4			LDA	PENH
  1740 C134 8D 34 02			STA	LPENH		;light pen vertical position
  1741 C137 AD 31 02			LDA	SDLSTH
  1742 C13A 8D 03 D4			STA	DLISTH		;high display list address
  1743 C13D AD 30 02			LDA	SDLSTL
  1744 C140 8D 02 D4			STA	DLISTL		;low display list address
  1745 C143 AD 2F 02			LDA	SDMCTL
  1746 C146 8D 00 D4			STA	DMACTL		;DMA control
  1747 C149 AD 6F 02			LDA	GPRIOR
  1748 C14C 8D 1B D0			STA	PRIOR		;prioritty select
  1749
  1750 				;	Check for vertical scroll enabled.
  1751
  1752 C14F AD 6C 02			LDA	VSFLAG		;vertical scroll count
  1753 C152 F0 0E			BEQ	IVN6		;if vertical scroll not ena:
  1754
  1755 				;	Scroll one line.
  1756
  1757 C154 CE 6C 02			DEC	VSFLAG		;decrement vertical scroll :
  1758 C157 A9 08			LDA	#8		;scroll one line
  1759 C159 38				SEC
  1760 C15A ED 6C 02			SBC	VSFLAG		;subtract vertical scroll c:
  1761 C15D 29 07			AND	#07
  1762 C15F 8D 05 D4			STA	VSCROL		;set vertical scroll
  1763
  1764 				;	Turn off speaker.
  1765
  1766 C162 A2 08		IVN6	LDX	#$08		;speaker off
  1767 C164 8E 1F D0			STX	CONSOL		;set speaker control
  1768
  1769 				;	Set color registers from shadows.
  1770
  1771 				;	LDX	#8		;offset to background color
  1772
  1773 C167 58			IVN7	CLI
  1774 C168 BD C0 02			LDA	PCOLR0,X	;color register shadow
  1775 C16B 45 4F			EOR	COLRSH		;modify with attract-mode color shift
  1776 C16D 25 4E			AND	DRKMSK		;modify with attract-mode luminance
  1777 C16F 9D 12 D0			STA	COLPM0,X	;set color register
  1778 C172 CA				DEX
  1779 C173 10 F2			BPL	IVN7		;if not done
  1780
  1781 				;	Set character set control.
  1782
  1783 C175 AD F4 02			LDA	CHBAS
  1784 C178 8D 09 D4			STA	CHBASE
  1785 C17B AD F3 02			LDA	CHACT
  1786 C17E 8D 01 D4			STA	CHACTL
  1787
  1788 				;	Process countdown timer 2.
  1789
  1790 C181 A2 02			LDX	#2		;indicate countdown timer 2
  1791 C183 20 55 C2			JSR	DCT		;decrement countdown timer
  1792 C186 D0 03			BNE	IVN8		;if timer not expired
  1793
  1794 C188 20 52 C2			JSR	PTT		;process countdown timer 2 expiration
  1795
  1796 				;	Process timers 3, 4 and 5.
  1797
  1798 C18B A2 02		IVN8	LDX	#2		;preset offset to timer 2
  1799
  1800 C18D E8			IVN9	INX
  1801 C18E E8				INX			;offset to countdown timer
  1802 C18F BD 18 02			LDA	CDTMV3-4,X	;countdown timer
  1803 C192 1D 19 02			ORA	CDTMV3+1-4,X
  1804 C195 F0 06			BEQ	IVN10		;if countdown timer already expired
  1805
  1806 C197 20 55 C2			JSR	DCT		;decrement countdown timer
  1807 C19A 9D 26 02			STA	CDTMF3-4,X	;indicate timer expiration status
  1808
  1809 C19D E0 08		IVN10	CPX	#8		;offset to timer 5
  1810 C19F D0 EC			BNE	IVN9		;if all timers not done
  1811
  1812 				;	Check debounce counter.
  1813
  1814 C1A1 AD 0F D2			LDA	SKSTAT		;keyboard status
  1815 C1A4 29 04			AND	#$04		;key down indicator
  1816 C1A6 F0 08			BEQ	IVN11		;if key down
  1817
  1818 				;	Process key up.
  1819
  1820 C1A8 AD F1 02			LDA	KEYDEL		;key delay counter
  1821 C1AB F0 03			BEQ	IVN11		;if counted down already
  1822
  1823 C1AD CE F1 02			DEC	KEYDEL		;decrement key delay counter
  1824
  1825 				;	Check software key repeat timer.
  1826
  1827 C1B0 AD 2B 02		IVN11	LDA	SRTIMR		;key repeat timer
  1828 C1B3 F0 3E			BEQ	IVN13		;if key repeat timer expired
  1829
  1830 C1B5 AD 0F D2			LDA	SKSTAT		;keyboard status
  1831 C1B8 29 04			AND	#$04		;key down indicator
  1832 C1BA D0 32			BNE	IVN12		;if key no longer down
  1833
  1834 C1BC CE 2B 02			DEC	SRTIMR		;decrement key repeat timer
  1835 C1BF D0 32			BNE	IVN13		;if key repeat timer not expired
  1836
  1837 				;	Process key repeat timer expiration.
  1838
  1839 C1C1 AD 6D 02			LDA	KEYDIS		;keyboard disable flag
  1840 C1C4 D0 2D			BNE	IVN13		;if keyboard disabled, no r:
  1841
  1842 C1C6 AD DA 02			LDA	KEYREP		;initial timer value
  1843 C1C9 8D 2B 02			STA	SRTIMR		;reset key repeat timer
  1844 C1CC AD 09 D2			LDA	KBCODE		;key code
  1845
  1846 				;	Check for hidden codes.
  1847
  1848 C1CF C9 9F			CMP	#CNTL1
  1849 C1D1 F0 20			BEQ	IVN13		;if CTRL-1
  1850
  1851 C1D3 C9 83			CMP	#CNTLF1
  1852 C1D5 F0 1C			BEQ	IVN13		;if CTRL-F1
  1853
  1854 C1D7 C9 84			CMP	#CNTLF2
  1855 C1D9 F0 18			BEQ	IVN13		;if CTRL-F2
  1856
  1857 C1DB C9 94			CMP	#CNTLF4
  1858 C1DD F0 14			BEQ	IVN13		;if CTRL-F4
  1859
  1860 C1DF 29 3F			AND	#$3F
  1861 C1E1 C9 11			CMP	#HELP
  1862 C1E3 F0 0E			BEQ	IVN13		;if HELP
  1863
  1864 				;	Set key code.
  1865
  1866 C1E5 AD 09 D2			LDA	KBCODE		;key code
  1867 C1E8 8D FC 02			STA	CH		;set key code
  1868 C1EB 4C F3 C1			JMP	IVN13		;continue
  1869
  1870 				;	Zero key repeat timer.
  1871
  1872 C1EE A9 00		IVN12	LDA	#0
  1873 C1F0 8D 2B 02			STA	SRTIMR		;zero key repeat timer
  1874
  1875 				;	Read joysticks.
  1876
  1877 C1F3 AD 00 D3		IVN13	LDA	PORTA		;joystick readings
  1878 C1F6 4A				LSR
  1879 C1F7 4A				LSR
  1880 C1F8 4A				LSR
  1881 C1F9 4A				LSR		;joystick 1 reading
  1882 C1FA 8D 79 02			STA	STICK1		;set joystick 1 reading
  1883 					.IF	VGC
  1884 C1FD 8D 7B 02			STA	STICK3		;simulate joystick 3 reading
  1885 					.ENDIF
  1886 C200 AD 00 D3			LDA	PORTA		;joystick readings
  1887 C203 29 0F			AND	#$0F		;joystick 0 reading
  1888 C205 8D 78 02			STA	STICK0		;set joystick 0 reading
  1889 					.IF	VGC
  1890 C208 8D 7A 02			STA	STICK2		;simulate joystick 2 reading
  1891 					.ENDIF
  1892
  1893 				;	Read joystick triggers.
  1894
  1895 C20B AD 10 D0			LDA	TRIG0		;trigger 0 indicator
  1896 C20E 8D 84 02			STA	STRIG0		;set trigger 0 indicator
  1897 					.IF	VGC
  1898 C211 8D 86 02			STA	STRIG2		;simulate trigger 2 indicator
  1899 					.ENDIF
  1900 C214 AD 11 D0			LDA	TRIG1		;trigger 1 indicator
  1901 C217 8D 85 02			STA	STRIG1		;set trigger 1 indicator
  1902 					.IF	VGC
  1903 C21A 8D 87 02			STA	STRIG3		;simulate trigger 3 indicator
  1904 					.ENDIF
  1905
  1906 				;	Read potentiometers.
  1907
  1908 C21D A2 03			LDX	#3		;offset to last potentiometer
  1909
  1910 C21F BD 00 D2		IVN14	LDA	POT0,X		;potentiometer reading
  1911 C222 9D 70 02			STA	PADDL0,X	;set potentiometer reading
  1912 					.IF	VGC
  1913 C225 9D 74 02			STA	PADDL4,X	;simulate potentiometer reading
  1914 					.ENDIF
  1915 C228 CA				DEX
  1916 C229 10 F4			BPL	IVN14		;if not done
  1917
  1918 				;	Start potentiometers for next time.
  1919
  1920 C22B 8D 0B D2			STA	POTGO		;start potentiometers
  1921
  1922 				;	Read paddle triggers.
  1923
  1924 C22E A2 02			LDX	#2		;offset to paddle trigger reading
  1925 C230 A0 01			LDY	#1		;offset to joystick reading
  1926
  1927 C232 B9 78 02		IVN15	LDA	STICK0,Y	;joystick reading
  1928 C235 4A				LSR
  1929 C236 4A				LSR
  1930 C237 4A				LSR		;paddle trigger reading
  1931 C238 9D 7D 02			STA	PTRIG1,X	;set paddle trigger reading
  1932 					.IF	VGC
  1933 C23B 9D 81 02			STA	PTRIG5,X	;simulate paddle trigger reading
  1934 					.ENDIF
  1935
  1936 C23E A9 00			LDA	#0
  1937 C240 2A				ROL		;paddle trigger reading
  1938 C241 9D 7C 02			STA	PTRIG0,X	;set paddle trigger reading
  1939 					.IF	VGC
  1940 C244 9D 80 02			STA	PTRIG4,X	;simulate paddle trigger reading
  1941 					.ENDIF
  1942 C247 CA				DEX
  1943 C248 CA				DEX
  1944 C249 88				DEY
  1945 C24A 10 E6			BPL	IVN15		;if not done
  1946
  1947 				;	Exit.
  1948
  1949 C24C 6C 24 02			JMP	(VVBLKD)	;process deferred VBLANK NMI, return
  1950 					;SPACE	4,10
  1951 				;	PTO - Process Countdown Timer One Expiration
  1952 				*
  1953 				*	ENTRY	JSR	PTO
  1954 				*
  1955 				*	MODS
  1956 				*		Original Author Unknown
  1957 				*		1. Bring closer to Coding Standard (object unchanged).
  1958 				*		   R. K. Nordin	11/01/83
  1959
  1960
  1961 = C24F			PTO	=	*		;entry
  1962 C24F 6C 26 02			JMP	(CDTMA1)	;process countdown timer 1 expiration
  1963 					;SPACE	4,10
  1964 				;	PTT - Process Countdown Timer Two Expiration
  1965 				*
  1966 				*	ENTRY	JSR	PTT
  1967 				*
  1968 				*	MODS
  1969 				*		Original Author Unknown
  1970 				*		1. Bring closer to Coding Standard (object unchanged).
  1971 				*		   R. K. Nordin	11/01/83
  1972
  1973
  1974 = C252			PTT	=	*		;entry
  1975 C252 6C 28 02			JMP	(CDTMA2)	;process countdown timer 2 expiration
  1976 					;SPACE	4,10
  1977 				;	DCT - Decrement Countdown Timer
  1978 				*
  1979 				*	ENTRY	JSR	DCT
  1980 				*		X = offset to timer value
  1981 				*
  1982 				*	EXIT
  1983 				*		A = 0, if timer expired
  1984 				*		  = $FF, if timer did not expire
  1985 				*
  1986 				*	MODS
  1987 				*		Original Author Unknown
  1988 				*		1. Bring closer to Coding Standard (object unchanged).
  1989 				*		   R. K. Nordin	11/01/83
  1990
  1991
  1992 = C255			DCT	=	*		;entry
  1993 C255 BC 18 02			LDY	CDTMV1,X	;low timer value
  1994 C258 D0 08			BNE	DCT1		;if low timer value not zero
  1995
  1996 C25A BC 19 02			LDY	CDTMV1+1,X	;high timer value
  1997 C25D F0 10			BEQ	DCT2		;if timer value zero, exit
  1998
  1999 C25F DE 19 02			DEC	CDTMV1+1,X	;decrement high timer value
  2000
  2001 C262 DE 18 02		DCT1	DEC	CDTMV1,X	;decrement low timer value
  2002 C265 D0 08			BNE	DCT2		;if low timer value not zero
  2003
  2004 C267 BC 19 02			LDY	CDTMV1+1,X	;high timer value
  2005 C26A D0 03			BNE	DCT2		;if high timer value not zero
  2006
  2007 C26C A9 00			LDA	#0		;indicate timer expired
  2008 C26E 60				RTS			;return
  2009
  2010 C26F A9 FF		DCT2	LDA	#$FF		;indicate timer did not expire
  2011 C271 60				RTS			;return
  2012 					;SPACE	4,10
  2013 				;	SVP - Set Vertical Blank Parameters
  2014 				*
  2015 				*	SVP sets countdown timers and VBLANK vectors.
  2016 				*
  2017 				*	ENTRY	JSR	SVP
  2018 				*		X = high initial timer value or high vector address
  2019 				*		Y = low initial timer value or low vector address
  2020 				*		A = 1, if timer 1 value
  2021 				*		    2, if timer 2 value
  2022 				*		    3, if timer 3 value
  2023 				*		    4, if timer 4 value
  2024 				*		    5, if timer 5 value
  2025 				*		    6, if immediate VBLANK vector
  2026 				*		    7, if deferred VBLANK vector
  2027 				*
  2028 				*	MODS
  2029 				*		Original Author Unknown
  2030 				*		1. Bring closer to Coding Standard (object unchanged).
  2031 				*		   R. K. Nordin	11/01/83
  2032
  2033
  2034 = C272			SVP	=	*		;entry
  2035
  2036 				;	Initialize.
  2037
  2038 C272 0A				ASL		;compute offset+2 to value or vector
  2039 C273 8D 2D 02			STA	INTEMP		;offset+2 to value or vector
  2040 C276 8A				TXA			;high timer value or high vector address
  2041
  2042 				;	Ensure no VBLANK in progress by delaying after HBLANK.
  2043
  2044 C277 A2 05			LDX	#5		;20 CPU cycles
  2045 C279 8D 0A D4			STA	WSYNC		;wait for HBLANK synchronization
  2046
  2047 C27C CA			SVP1	DEX
  2048 C27D D0 FD			BNE	SVP1		;if not done delaying
  2049
  2050 				;	Set timer value or vector address.
  2051
  2052 C27F AE 2D 02			LDX	INTEMP		;offset+2 to value or vector
  2053 C282 9D 17 02			STA	CDTMV1-2+1,X	;high timer value or high vector address
  2054 C285 98				TYA
  2055 C286 9D 16 02			STA	CDTMV1-2,X	;low timer value or low vector address
  2056 C289 60				RTS			;return
  2057 					;SPACE	4,10
  2058 				;	DVNM - Process Deferred VBLANK NMI
  2059 				*
  2060 				*	ENTRY	JMP	DVNM
  2061 				*
  2062 				*	EXIT
  2063 				*		Exits via RTI
  2064 				*
  2065 				*	MODS
  2066 				*		Original Author Unknown
  2067 				*		1. Bring closer to Coding Standard (object unchanged).
  2068 				*		   R. K. Nordin	11/01/83
  2069
  2070
  2071 = C28A			DVNM	=	*	;entry
  2072 C28A 68				PLA
  2073 C28B A8				TAY		;restore Y
  2074 C28C 68				PLA
  2075 C28D AA				TAX		;restore X
  2076 C28E 68				PLA		;restore A
  2077 C28F 40				RTI		;return
  2078 				;	;SUBTTL	'Initialization'
  2079 					;SPACE	4,10
  2080 				;	PWS - Perform Warmstart
  2081 				*
  2082 				*	ENTRY	JMP	PWS
  2083 				*
  2084 				*	EXIT
  2085 				*		Exits to PCS or PRS
  2086 				*
  2087 				*	MODS
  2088 				*		Original Author Unknown
  2089 				*		1. Bring closer to Coding Standard (object unchanged).
  2090 				*		   R. K. Nordin	11/01/83
  2091
  2092
  2093 = C290			PWS	=	*	;entry
  2094
  2095 				;	Initialize.
  2096
  2097 C290 78				SEI
  2098
  2099 				;	Check for cartridge change.
  2100
  2101 C291 AD 13 D0			LDA	TRIG3	;cartridge interlock
  2102 C294 CD FA 03			CMP	GINTLK	;previous cartridge interlock status
  2103 C297 D0 2F			BNE	PCS	;if cartridge changed, perform coldstart
  2104
  2105 				;	Check for cartridge.
  2106
  2107 C299 6A				ROR
  2108 C29A 90 05			BCC	PWS1	;if no cartridge
  2109
  2110 				;	Verify no change in cartridge.
  2111
  2112 C29C 20 C9 C4			JSR	CCE	;check cartridge equivalence
  2113 C29F D0 27			BNE	PCS	;if different cartridge, coldstart
  2114
  2115 				;	Check coldstart status.
  2116
  2117 C2A1 AD 44 02		PWS1	LDA	COLDST	;coldstart status
  2118 C2A4 D0 22			BNE	PCS	;if coldstart was in progress, perform coldstart
  2119
  2120 				;	Perform warmstart.
  2121
  2122 C2A6 A9 FF			LDA	#$FF	;indicate warmstart
  2123 C2A8 D0 20			BNE	PRS	;preset memory, return
  2124 					;SPACE	4,10
  2125 				;	RES - Process RESET
  2126 				*
  2127 				*	ENTRY	JMP	RES
  2128 				*
  2129 				*	EXIT
  2130 				*		Exits to PCS, if coldstart, or PWS, if warmstart
  2131 				*
  2132 				*	MODS
  2133 				*		Original Author Unknown
  2134 				*		1. Bring closer to Coding Standard (object unchanged).
  2135 				*		   R. K. Nordin	11/01/83
  2136
  2137
  2138 = C2AA			RES	=	*	;entry
  2139
  2140 				;	Initialize.
  2141
  2142 C2AA 78				SEI
  2143
  2144 				;	Delay 0.1 second for RESET bounce.
  2145
  2146 C2AB A2 8C			LDX	#140	;0.1 second delay
  2147
  2148 C2AD 88			RES1	DEY
  2149 C2AE D0 FD			BNE	RES1	;if inner loop not done
  2150
  2151 C2B0 CA				DEX
  2152 C2B1 D0 FA			BNE	RES1	;if outer loop not done
  2153
  2154 				;	Check power-up validation bytes.
  2155
  2156 C2B3 AD 3D 03			LDA	PUPBT1
  2157 C2B6 C9 5C			CMP	#PUPVL1
  2158 C2B8 D0 0E			BNE	PCS	;if validation byte 1 differs, coldstart
  2159
  2160 C2BA AD 3E 03			LDA	PUPBT2
  2161 C2BD C9 93			CMP	#PUPVL2
  2162 C2BF D0 07			BNE	PCS	;if validation byte 2 differs, coldstart
  2163
  2164 C2C1 AD 3F 03			LDA	PUPBT3
  2165 C2C4 C9 25			CMP	#PUPVL3
  2166 C2C6 F0 C8			BEQ	PWS	;if all bytes validated, perform warmstart
  2167
  2168 				;	JMP	PCS	;perform coldstart, return
  2169 					;SPACE	4,10
  2170 				;	PCS - Perform Coldstart
  2171 				*
  2172 				*	ENTRY	JMP	PCS
  2173 				*
  2174 				*	EXIT
  2175 				*		Exits to PRS
  2176 				*
  2177 				*	MODS
  2178 				*		Original Author Unknown
  2179 				*		1. Bring closer to Coding Standard (object unchanged).
  2180 				*		   R. K. Nordin	11/01/83
  2181
  2182
  2183 = C2C8			PCS	=	*	;entry
  2184 C2C8 A9 00			LDA	#0	;indicate coldstart
  2185 				;	JMP	PRS	;preset memory, return
  2186 					;SPACE	4,10
  2187 				;	PRS - Preset Memory
  2188 				*
  2189 				*	ENTRY	JMP	PRS
  2190 				*
  2191 				*	EXIT
  2192 				*		Exits via CARTCS vector or DOSVEC vector
  2193 				*
  2194 				*	MODS
  2195 				*		Original Author Unknown
  2196 				*		1. Bring closer to Coding Standard (object unchanged).
  2197 				*		   R. K. Nordin	11/01/83
  2198
  2199
  2200 = C2CA			PRS	=	*		;entry
  2201
  2202 				;	Update warmstart flag.
  2203
  2204 C2CA 85 08			STA	WARMST		;update warmstart flag
  2205
  2206 				;	Set initial conditions.
  2207
  2208 C2CC 78				SEI
  2209 C2CD D8				CLD
  2210 C2CE A2 FF			LDX	#$FF	
  2211 C2D0 9A				TXS			;set stack pointer
  2212
  2213 				;	Initialize LNBUG flag, if necessary.
  2214
  2215 					.IF	LNBUG
  2216 					LDY	#0		;assume no LNBUG
  2217 					LDA	LNORG		;first byte of LNBUG
  2218 					CMP	#$4C		;JMP instruction
  2219 					BNE	PRS2		;if JMP not present, indicate no LNBUG
  2220
  2221 					INC	LNORG		;try to increment test byte
  2222 					CMP	LNORG		;original contents of test byte
  2223 					BEQ	PRS1		;if no change, LNBUG present
  2224
  2225 					DEC	LNORG		;restore test byte
  2226 					BNE	PRS2		;indicate no LNBUG
  2227
  2228 				PRS1	DEY			;LNBUG present indicator
  2229
  2230 				PRS2	STY	LNFLG		;LNBUG flag
  2231 					.ENDIF
  2232
  2233 				;	Perform miscellaneous initialization.
  2234
  2235 C2D1 20 71 C4			JSR	PMI		;perform miscellaneous initialization
  2236
  2237 				;	Initialize memory status.
  2238
  2239 C2D4 A9 01			LDA	#1		;no failure indicator
  2240 C2D6 85 01			STA	NGFLAG		;memory status flag
  2241
  2242 				;	Check type.
  2243
  2244 C2D8 A5 08			LDA	WARMST		;warmstart flag
  2245 C2DA D0 52			BNE	PRS8		;if warmstart
  2246
  2247 				;	Zero all RAM (except beginning of page zero).
  2248
  2249 C2DC A9 00			LDA	#0
  2250 C2DE A0 08			LDY	#WARMST		;initial offset into page zero
  2251 C2E0 85 04			STA	RAMLO
  2252 C2E2 85 05			STA	RAMLO+1		;initialize RAM pointer
  2253
  2254 C2E4 A9 FF		PRS3	LDA	#$FF
  2255 C2E6 91 04			STA	(RAMLO),Y	;attempt to store $FF
  2256 C2E8 D1 04			CMP	(RAMLO),Y
  2257 C2EA F0 02			BEQ	PRS4		;if $FF stored successfully
  2258
  2259 C2EC 46 01			LSR	NGFLAG		;indicate memory failure
  2260
  2261 C2EE A9 00		PRS4	LDA	#$00
  2262 C2F0 91 04			STA	(RAMLO),Y	;attempt to store $00
  2263 C2F2 D1 04			CMP	(RAMLO),Y
  2264 C2F4 F0 02			BEQ	PRS5		;if $00 stored successfully
  2265
  2266 C2F6 46 01			LSR	NGFLAG		;indicate memory failure
  2267
  2268 C2F8 C8			PRS5	INY
  2269 C2F9 D0 E9			BNE	PRS3		;if not end of page
  2270
  2271 				;	Advance to next page and check for completion.
  2272
  2273 C2FB E6 05			INC	RAMLO+1		;advance RAM pointer to next page
  2274 C2FD A6 05			LDX	RAMLO+1
  2275 C2FF E4 06			CPX	TRAMSZ		;RAM size
  2276 C301 D0 E1			BNE	PRS3		;if not at end of RAM
  2277
  2278 				;	Initialize DOSVEC.
  2279
  2280 C303 A9 23			LDA	#<PPD	;power-up display routine address
  2281 C305 85 0A			STA	DOSVEC		;initialize DOS vector
  2282 C307 A9 F2			LDA	#>PPD
  2283 C309 85 0B			STA	DOSVEC+1
  2284
  2285 				;	Verify ROM checksums.
  2286
  2287 C30B AD 01 D3			LDA	PORTB
  2288 C30E 29 7F			AND	#$7F		;select self-test ROM
  2289 C310 8D 01 D3			STA	PORTB		;port B memory control
  2290
  2291 C313 20 73 FF			JSR	VFR		;verify first 8K ROM
  2292 C316 B0 05			BCS	PRS6		;if first 8K ROM bad
  2293
  2294 C318 20 92 FF			JSR	VSR		;verify second 8K ROM
  2295 C31B 90 02			BCC	PRS7		;if seond 8K ROM good
  2296
  2297 C31D 46 01		PRS6	LSR	NGFLAG		;indicate memory bad
  2298
  2299 C31F AD 01 D3		PRS7	LDA	PORTB
  2300 C322 09 80			ORA	#$80		;disable self-test ROM
  2301 C324 8D 01 D3			STA	PORTB		;update port B memory control
  2302
  2303 				;	Indicate coldstart in progress.
  2304
  2305 C327 A9 FF			LDA	#$FF
  2306 C329 8D 44 02			STA	COLDST		;indicate coldstart in progress
  2307 C32C D0 22			BNE	PRS12		;continue with coldstart procedures
  2308
  2309 				;	Perform warmstart procedures.
  2310
  2311 C32E A2 00		PRS8	LDX	#0
  2312
  2313 C330 AD EC 03			LDA	DERRF		;screen OPEN error flag
  2314 C333 F0 07			BEQ	PRS9		;if in screen OPEN
  2315
  2316 				;	Clean up APPMHI.
  2317
  2318 C335 8E 0E 00			STX.w	APPMHI
  2319 				;!!!	VFD	8\$8E,8\low APPMHI,8\high APPMHI
  2320 C338 8E 0F 00			STX.w	APPMHI+1
  2321 				;!!!	VFD	8\$8E,8\low [APPMHI+1],8\high [APPMHI+1]
  2322
  2323 C33B 8A				TXA
  2324
  2325 				;	Clear page 2 and part of page 3.
  2326
  2327 C33C 9D 00 02		PRS9	STA	$0200,X		;clear byte of page 2
  2328
  2329 C33F E0 ED			CPX	#<ACMVAR	;start of page 3 locations not to clear
  2330 C341 B0 03			BCS	PRS10		;if not to clear this page 3 location
  2331
  2332 C343 9D 00 03			STA	$0300,X		;clear byte of page 3
  2333
  2334 C346 CA			PRS10	DEX
  2335 C347 D0 F3			BNE	PRS9		;if not done
  2336
  2337 				;	Clear part of page 0.
  2338
  2339 C349 A2 10			LDX	#INTZBS		;offset to first page 0 byte to clear
  2340
  2341 C34B 95 00		PRS11	STA	$0000,X		;clear byte of page 0
  2342 C34D E8				INX
  2343 C34E 10 FB			BPL	PRS11		;if not done
  2344
  2345 				;	Record BASIC status.
  2346
  2347 C350 A2 00		PRS12	LDX	#0		;initially assume BASIC enabled
  2348 C352 AD 01 D3			LDA	PORTB		;port B memory control
  2349 C355 29 02			AND	#$02		;BASIC enabled indicator
  2350 C357 F0 01			BEQ	PRS13		;if BASIC enabled
  2351
  2352 C359 E8				INX			;indicate BASIC disabled
  2353
  2354 C35A 8E F8 03		PRS13	STX	BASICF		;BASIC flag
  2355
  2356 				;	Establish power-up validation bytes.
  2357
  2358 C35D A9 5C			LDA	#PUPVL1
  2359 C35F 8D 3D 03			STA	PUPBT1		;validation byte 1
  2360 C362 A9 93			LDA	#PUPVL2
  2361 C364 8D 3E 03			STA	PUPBT2		;validation byte 2
  2362 C367 A9 25			LDA	#PUPVL3
  2363 C369 8D 3F 03			STA	PUPBT3		;validation byte 3
  2364
  2365 				;	Establish screen margins.
  2366
  2367 C36C A9 02			LDA	#LEDGE
  2368 C36E 85 52			STA	LMARGN		;left margin
  2369 C370 A9 27			LDA	#REDGE
  2370 C372 85 53			STA	RMARGN		;right margin
  2371
  2372 				;	Establish parameters for NTSC or PAL.
  2373
  2374 C374 AD 14 D0			LDA	PAL		;GTIA flag bits
  2375 C377 29 0E			AND	#$0E		;PAL/NTSC indicator
  2376 C379 D0 08			BNE	PRS14		;if NTSC
  2377
  2378 C37B A9 05			LDA	#5		;PAL key repeat delay
  2379 C37D A2 01			LDX	#1		;PAL indicator
  2380 C37F A0 28			LDY	#40		;PAL key repeat initial delay
  2381 C381 D0 06			BNE	PRS15		;set parameters
  2382
  2383 C383 A9 06		PRS14	LDA	#6		;NTSC key repeat delay
  2384 C385 A2 00			LDX	#0		;NTSC indicator
  2385 C387 A0 30			LDY	#48		;NTSC key repeat initial delay
  2386
  2387 C389 8D DA 02		PRS15	STA	KEYREP		;set key repeat rate
  2388 C38C 86 62			STX	PALNTS		;set PAL/NTSC status
  2389 C38E 8C D9 02			STY	KRPDEL		;set key repeat initial delay
  2390
  2391 				;	Initialize missing controller ports, if not simulated.
  2392
  2393 					.IF	.not VGC
  2394 					LDA	#$0F		;joystick centered
  2395 					STA	STICK2
  2396 					STA	STICK3
  2397 					LDA	#$01		;trigger not pressed
  2398 					STA	STRIG2
  2399 					STA	STRIG3
  2400
  2401 					LDX	#3		;offset to last controller
  2402
  2403 				PRS16	LDA	#$E4		;paddle fully counter-clockwise
  2404 					STA	PADDL4,X
  2405 					LDA	#$01		;trigger not pressed
  2406 					STA	PTRIG4,X
  2407 					DEX
  2408 					BPL	PRS16		;if not done
  2409 					.ENDIF
  2410
  2411 				;	Copy interrupt vector table from ROM to RAM.
  2412
  2413 C391 A2 25			LDX	#TIHVL-1	;offset to last byte of table
  2414
  2415 C393 BD 4B C4		PRS17	LDA	TIHV,X		;byte of table of interrupt vectors
  2416 C396 9D 00 02			STA	INTABS,X	;byte of RAM table
  2417 C399 CA				DEX
  2418 C39A 10 F7			BPL	PRS17		;if not done
  2419
  2420 				;	Copy handler vector table from ROM to RAM.
  2421
  2422 C39C A2 0E			LDX	#THAVL-1	;offset to last byte of table
  2423
  2424 C39E BD 2E C4		PRS18	LDA	THAV,X		;byte of handler vector table
  2425 C3A1 9D 1A 03			STA	HATABS,X	;byte of RAM table
  2426 C3A4 CA				DEX
  2427 C3A5 10 F7			BPL	PRS18		;if not done
  2428
  2429 				;	Initialize software.
  2430
  2431 C3A7 20 35 C5			JSR	ISW		;initialize software
  2432
  2433 				;	Initialize ACMI module, if present.
  2434
  2435 					.IF	ACMI
  2436 					.ENDIF
  2437
  2438 				;	Enable IRQ interrupts.
  2439
  2440 C3AA 58				CLI
  2441
  2442 				;	Check for memory problems.
  2443
  2444 C3AB A5 01			LDA	NGFLAG		;memory status
  2445 C3AD D0 15			BNE	PRS21		;if memory good
  2446
  2447 				;	Perform memory self-test on bad memory.
  2448
  2449 C3AF AD 01 D3			LDA	PORTB
  2450 C3B2 29 7F			AND	#$7F		;enable self-test ROM
  2451 C3B4 8D 01 D3			STA	PORTB		;update port B memory control
  2452 C3B7 A9 02			LDA	#2
  2453 C3B9 8D F3 02			STA	CHACT		;CHACTL (character control) shadow
  2454 C3BC A9 E0			LDA	#>DCSORG	;high domestic character set origin
  2455 C3BE 8D F4 02			STA	CHBAS		;CHBASE (character base) shadow
  2456 C3C1 4C 03 50			JMP	EMS		;execute memory self-test
  2457
  2458 				;	Check for cartridge.
  2459
  2460 C3C4 A2 00		PRS21	LDX	#0
  2461 C3C6 86 06			STX	TRAMSZ		;clear cartridge flag
  2462
  2463 C3C8 AE E4 02			LDX	RAMSIZ		;RAM size
  2464 C3CB E0 B0			CPX	#>$B000	;start of cartridge area
  2465 C3CD B0 0D			BCS	PRS22		;if RAM in cartridge area
  2466
  2467 C3CF AE FC BF			LDX	CART
  2468 C3D2 D0 08			BNE	PRS22		;if no cartridge
  2469
  2470 C3D4 E6 06			INC	TRAMSZ		;set cartridge flag
  2471 C3D6 20 C9 C4			JSR	CCE		;check cartridge equivalence
  2472 C3D9 20 29 C4			JSR	ICS		;initialize cartridge software
  2473
  2474 				;	Open screen editor.
  2475
  2476 C3DC A9 03		PRS22	LDA	#OPEN
  2477 C3DE A2 00			LDX	#SEIOCB		;screen editor IOCB index
  2478 C3E0 9D 42 03			STA	ICCOM,X		;command
  2479 C3E3 A9 48			LDA	#<SEDS	;screen editor device specification
  2480 C3E5 9D 44 03			STA	ICBAL,X		;buffer address
  2481 C3E8 A9 C4			LDA	#>SEDS
  2482 C3EA 9D 45 03			STA	ICBAH,X
  2483 C3ED A9 0C			LDA	#OPNIN+OPNOT	;open for input/output
  2484 C3EF 9D 4A 03			STA	ICAX1,X		;auxiliary informatin 1
  2485 C3F2 20 56 E4			JSR	CIOV		;vector to CIO
  2486 C3F5 10 03			BPL	PRS23		;if no error
  2487
  2488 				;	Process error (which should never happen).
  2489
  2490 C3F7 4C AA C2			JMP	RES		;retry power-up
  2491
  2492 				;	Delay, ensuring VBLANK.
  2493
  2494 C3FA E8			PRS23	INX
  2495 C3FB D0 FD			BNE	PRS23		;if inner loop not done
  2496
  2497 C3FD C8				INY
  2498 C3FE 10 FA			BPL	PRS23		;if outer loop not done
  2499
  2500 				;	Attempt cassette boot.
  2501
  2502 C400 20 6E C6			JSR	ACB		;attempt cassette boot
  2503
  2504 				;	Check cartridge for disk boot.
  2505
  2506 C403 A5 06			LDA	TRAMSZ
  2507 C405 F0 06			BEQ	PRS24		;if no cartridge
  2508
  2509 C407 AD FD BF			LDA	CARTFG		;cartridge mode flags
  2510 C40A 6A				ROR
  2511 C40B 90 06			BCC	PRS25		;if disk boot not desired
  2512
  2513 				;	Attempt disk boot.
  2514
  2515 C40D 20 8B C5		PRS24	JSR	ADB		;attempt disk boot
  2516
  2517 				;	Initialize peripheral handler loading facility.
  2518
  2519 C410 20 39 E7			JSR	PHR		;poll, load, relocate, init:
  2520
  2521 				;	Indicate coldstart complete.
  2522
  2523 C413 A9 00		PRS25	LDA	#0
  2524 C415 8D 44 02			STA	COLDST		;indicate coldstart complete
  2525
  2526 				;	Check cartridge for execution.
  2527
  2528 C418 A5 06			LDA	TRAMSZ
  2529 C41A F0 0A			BEQ	PRS26		;if no cartridge
  2530
  2531 C41C AD FD BF			LDA	CARTFG		;cartridge mode flags
  2532 C41F 29 04			AND	#$04
  2533 C421 F0 03			BEQ	PRS26		;if execution not desired
  2534
  2535 				;	Execute cartridge.
  2536
  2537 C423 6C FA BF			JMP	(CARTCS)	;execute cartridge
  2538
  2539 				;	Exit to power-up display or booted program.
  2540
  2541 C426 6C 0A 00		PRS26	JMP	(DOSVEC)	;vector to booted program
  2542 					;SPACE	4,10
  2543 				;	ICS - Initialize Cartridge Software
  2544 				*
  2545 				*	ENTRY	JSR	ICS
  2546 				*
  2547 				*	MODS
  2548 				*		Original Author Unknown
  2549 				*		1. Bring closer to Coding Standard (object unchanged).
  2550 				*		   R. K. Nordin	11/01/83
  2551
  2552
  2553 = C429			ICS	=	*	;entry
  2554 C429 6C FE BF			JMP	(CARTAD)	;initialize cartridge software
  2555 					;SPACE	4,10
  2556 				;	PAI - Process ACMI Interrupt
  2557 				*
  2558 				*	PAI does nothing.
  2559 				*
  2560 				*	ENTRY	JSR	PAI
  2561 				*
  2562 				*	NOTES
  2563 				*		Problem: this code is unneeded unless ACMI :
  2564 				*		option is selected.
  2565 				*
  2566 				*	MODS
  2567 				*		Original Author Unknown
  2568 				*		1. Bring closer to Coding Standard (object unchanged).
  2569 				*		   R. K. Nordin	11/01/83
  2570
  2571
  2572 = C42C			PAI	=	*	;entry
  2573 C42C 18				CLC
  2574 C42D 60				RTS		;return
  2575 					;SPACE	4,10
  2576 				;	THAV - Table of Handler Vectors
  2577 				*
  2578 				*	NOTES
  2579 				*		THAV is moved to RAM table HATABS.
  2580
  2581
  2582 C42E 50			THAV	.byte	PRINTR	;printer device code
  2583 C42F 30 E4			.word	PRINTV	;printer handler vector table
  2584
  2585 C431 43				.byte	CASSET	;cassette device code
  2586 C432 40 E4			.word	CASETV	;cassette handler vector table
  2587
  2588 C434 45				.byte	SCREDT	;editor device code
  2589 C435 00 E4			.word	EDITRV	;editor handler vector table
  2590
  2591 C437 53				.byte	DISPLY	;screen device code
  2592 C438 10 E4			.word	SCRENV	;screen handler vector table
  2593
  2594 C43A 4B				.byte	KBD	;keyboard device code
  2595 C43B 20 E4			.word	KEYBDV	;keyboard handler vector table
  2596
  2597 = 000F			THAVL	=	*-THAV	;length
  2598 					;SPACE	4,10
  2599 				;	BMSG - Boot Error Message
  2600
  2601
  2602 C43D 42 4F 4F 54 20 45 + BMSG	.byte	'BOOT ERROR',EOL
  2603 					;SPACE	4,10
  2604 				;	Screen Editor Device Specification
  2605
  2606
  2607 C448 45 3A 9B		SEDS	.byte	'E:',EOL
  2608 					;SPACE	4,10
  2609 				;	TIHV - Table of Interrupt Handler Vectors
  2610 				*
  2611 				*	NOTES
  2612 				*		TIHV is moved to RAM table INTABS.
  2613
  2614
  2615 C44B CE C0		TIHV	.word	RIR	;VDSLST - display list NMI vector
  2616 C44D CD C0			.word	XIR	;VPRCED - proceed line IRQ vector
  2617 C44F CD C0			.word	XIR	;VINTER - interrupt line IRQ vector
  2618 C451 CD C0			.word	XIR	;VBREAK - BRK instruction IRQ vector
  2619 C453 19 FC			.word	KIR	;VKEYBD - keyboard IRQ vector
  2620 C455 2C EB			.word	IRIR	;VSERIN - serial input ready IRQ vector
  2621 C457 AD EA			.word	ORIR	;VSEROR - serial output ready IRQ vector
  2622 C459 EC EA			.word	OCIR	;VSEROC - serial output complete IRQ vector
  2623 C45B CD C0			.word	XIR	;VTIMR1 - POKEY timer 1 IRQ vector
  2624 C45D CD C0			.word	XIR	;VTIMR2 - POKEY timer 2 IRQ vector
  2625 C45F CD C0			.word	XIR	;VTIMR4 - POKEY timer 4 IRQ vector
  2626 C461 30 C0			.word	IIR	;VIMIRQ - immediate IRQ vector
  2627 C463 00 00			.word	0	;CDTMV1 - countdown timer 1 vector
  2628 C465 00 00			.word	0	;CDTMV2 - countdown timer 2 vector
  2629 C467 00 00			.word	0	;CDTMV3 - countdown timer 3 vector
  2630 C469 00 00			.word	0	;CDTMV4 - countdown timer 4 vector
  2631 C46B 00 00			.word	0	;CDTMV5 - countdown timer 5 vector
  2632 C46D E2 C0			.word	IVNM	;VVBLKI - immediate VBLANK NMI vector
  2633 C46F 8A C2			.word	DVNM	;VVBLKD - deferred VBLANK NMI vector
  2634
  2635 = 0026			TIHVL	=	*-TIHV	;length
  2636 					;SPACE	4,10
  2637 				;	PMI - Perform Miscellaneous Initialization
  2638 				*
  2639 				*	ENTRY	JSR	PMI
  2640 				*
  2641 				*	NOTES
  2642 				*		Problem: initial address for sizing RAM sho:
  2643 				*		$4000 (16K) instead of $2800.
  2644 				*
  2645 				*	MODS
  2646 				*		Original Author Unknown
  2647 				*		1. Bring closer to Coding Standard (object unchanged).
  2648 				*		   R. K. Nordin	11/01/83
  2649
  2650
  2651 = C471			PMI	=	*	;entry
  2652
  2653 				;	Check for cartridge special execution case.
  2654
  2655 C471 AD 13 D0			LDA	TRIG3
  2656 C474 6A				ROR
  2657 C475 90 0D			BCC	PMI1	;if cartridge not inserted
  2658
  2659 C477 AD FC BF			LDA	CART
  2660 C47A D0 08			BNE	PMI1	;if not cartridge
  2661
  2662 C47C AD FD BF			LDA	CARTFG	;cartridge flags
  2663 C47F 10 03			BPL	PMI1	;if special execution not desired
  2664
  2665 				;	Execute cartridge.
  2666
  2667 C481 6C FE BF			JMP	(CARTAD)	;execute cartridge
  2668
  2669 				;	Initialize hardware.
  2670
  2671 C484 20 DA C4		PMI1	JSR	IHW	;initialize hardware
  2672
  2673 				;	Disable BASIC.
  2674
  2675 C487 AD 01 D3			LDA	PORTB
  2676 C48A 09 02			ORA	#$02	;disable BASIC
  2677 C48C 8D 01 D3			STA	PORTB	;update port B memory control
  2678
  2679 				;	If warmstart, check previous BASIC status.
  2680
  2681 C48F A5 08			LDA	WARMST
  2682 C491 F0 07			BEQ	PMI2	;if coldstart
  2683
  2684 C493 AD F8 03			LDA	BASICF	;BASIC flag
  2685 C496 D0 11			BNE	PMI4	;if BASIC not previously enabled
  2686
  2687 C498 F0 07			BEQ	PMI3	;enable BASIC
  2688
  2689 				;	Check OPTION key.
  2690
  2691 C49A AD 1F D0		PMI2	LDA	CONSOL	;console switches
  2692 C49D 29 04			AND	#$04	;OPTION key indicator
  2693 C49F F0 08			BEQ	PMI4	;if OPTION key pressed, do not enable BASIC
  2694
  2695 				;	Enable BASIC.
  2696
  2697 C4A1 AD 01 D3		PMI3	LDA	PORTB
  2698 C4A4 29 FD			AND	#$FD	;enable BASIC
  2699 C4A6 8D 01 D3			STA	PORTB	;update port B memory control
  2700
  2701 				;	Determine size of RAM.
  2702
  2703 					.IF	RAMSYS
  2704 				PMI4	LDA	#>$2800	;10K
  2705 					STA	TRAMSZ		;set RAM size
  2706 					RTS			;return
  2707 					.ELSE
  2708
  2709 C4A9 A9 00		PMI4	LDA	#<$2800	;initial low address
  2710 C4AB A8				TAY			;offset to first byte of page
  2711 C4AC 85 05			STA	TRAMSZ-1	;set initial low address
  2712
  2713 C4AE A9 28			LDA	#>$2800	;initial RAM size
  2714 C4B0 85 06			STA	TRAMSZ		;set initial RAM size (high address)
  2715
  2716 C4B2 B1 05		PMI5	LDA	(TRAMSZ-1),Y	;first byte of page
  2717 C4B4 49 FF			EOR	#$FF		;complement
  2718 C4B6 91 05			STA	(TRAMSZ-1),Y	;attempt to store complement
  2719 C4B8 D1 05			CMP	(TRAMSZ-1),Y
  2720 C4BA D0 0C			BNE	PMI6		;if complement not stored
  2721
  2722 C4BC 49 FF			EOR	#$FF		;original value
  2723 C4BE 91 05			STA	(TRAMSZ-1),Y	;attempt to store original value
  2724 C4C0 D1 05			CMP	(TRAMSZ-1),Y
  2725 C4C2 D0 04			BNE	PMI6		;if original value not stored
  2726
  2727 C4C4 E6 06			INC	TRAMSZ		;increment high address
  2728 C4C6 D0 EA			BNE	PMI5		;continue
  2729
  2730 				;	Exit.
  2731
  2732 C4C8 60			PMI6	RTS			;return
  2733 					.ENDIF
  2734 					;SPACE	4,10
  2735 				;	CCE - Check Cartridge Equivalence
  2736 				*
  2737 				*	ENTRY	JSR	CCE
  2738 				*
  2739 				*	NOTES
  2740 				*		Problem: this code checksums $BFF0 - $C0EF;:
  2741 				*		checksum $BF00 - $BFFF.
  2742 				*
  2743 				*	MODS
  2744 				*		Original Author Unknown
  2745 				*		1. Bring closer to Coding Standard (object unchanged).
  2746 				*		   R. K. Nordin	11/01/83
  2747
  2748
  2749 C4C9			CCE: ;	=	*	;entry
  2750
  2751 				;	Initialize.
  2752
  2753 C4C9 A9 00			LDA	#0	;initial sum
  2754 C4CB AA				TAX		;offset to first byte
  2755 C4CC 18				CLC
  2756
  2757 				;	Checksum 256 bytes of cartridge area.
  2758
  2759 C4CD 7D F0 BF		CCE1	ADC	$BFF0,X	;add in byte
  2760 C4D0 E8				INX
  2761 C4D1 D0 FA			BNE	CCE1	;if not done
  2762
  2763 				;	Exit.
  2764
  2765 C4D3 CD EB 03			CMP	CARTCK	;previous checksum
  2766 C4D6 8D EB 03			STA	CARTCK	;new checksum
  2767 C4D9 60				RTS		;return
  2768 					;SPACE	4,10
  2769 				;	IHW - Initialize Hardware
  2770 				*
  2771 				*	ENTRY	JSR	IHW
  2772 				*
  2773 				*	MODS
  2774 				*		Original Author Unknown
  2775 				*		1. Bring closer to Coding Standard (object unchanged).
  2776 				*		   R. K. Nordin	11/01/83
  2777
  2778
  2779 = C4DA			IHW	=	*	;entry
  2780
  2781 				;	Initialize CTIA, ANTIC and POKEY areas.
  2782
  2783 C4DA A9 00			LDA	#0		;initialization value
  2784 C4DC AA				TAX			;initial offset
  2785 C4DD 8D 03 D3			STA	PBCTL		;set for direction register first
  2786
  2787 C4E0 9D 00 D0		IHW1	STA	CTIA,X		;initialize CTIA/GTIA area register
  2788 C4E3 9D 00 D4			STA	ANTIC,X		;initialize ANTIC area register
  2789 C4E6 9D 00 D2			STA	POKEY,X		;initialize POKEY area register
  2790 C4E9 E0 01			CPX	#<PORTB
  2791 C4EB F0 03			BEQ	IHW2		;if port B, don't initialize
  2792
  2793 C4ED 9D 00 D3			STA	PIA,X		;initialize PIA area register
  2794
  2795 C4F0 E8			IHW2	INX
  2796 C4F1 D0 ED			BNE	IHW1		;if not done
  2797
  2798 				;	Initialize PIA.
  2799
  2800 C4F3 A9 3C			LDA	#$3C
  2801 C4F5 8D 03 D3			STA	PBCTL	;precondition port B outputs
  2802 C4F8 A9 FF			LDA	#$FF
  2803 C4FA 8D 01 D3			STA	PORTB	;all high
  2804 C4FD A9 38			LDA	#$38
  2805 C4FF 8D 02 D3			STA	PACTL	;select data direction register
  2806 C502 8D 03 D3			STA	PBCTL	;select data direction register
  2807 C505 A9 00			LDA	#$00
  2808 C507 8D 00 D3			STA	PORTA	;all inputs
  2809 C50A A9 FF			LDA	#$FF
  2810 C50C 8D 01 D3			STA	PORTB	;all outputs
  2811 C50F A9 3C			LDA	#$3C
  2812 C511 8D 02 D3			STA	PACTL	;back to port
  2813 C514 8D 03 D3			STA	PBCTL	;back to port
  2814 C517 AD 01 D3			LDA	PORTB	;clear interrupts
  2815 C51A AD 00 D3			LDA	PORTA	;clear interrupts
  2816
  2817 				;	Initialize POKEY.
  2818
  2819 C51D A9 22			LDA	#$22	;get POKEY out of initialize mode and set ch. 4
  2820 C51F 8D 0F D2			STA	SKCTL	;set serial port control
  2821
  2822 C522 A9 A0			LDA	#$A0	;pure tone, no volume
  2823 C524 8D 05 D2			STA	AUDC3	;turn off channel 3
  2824 C527 8D 07 D2			STA	AUDC4	;turn off channel 4
  2825
  2826 C52A A9 28			LDA	#$28	;clock ch. 3 with 1.79 MHz, ch. 4 with ch. 3
  2827 C52C 8D 08 D2			STA	AUDCTL	;set audio control
  2828
  2829 C52F A9 FF			LDA	#$FF
  2830 C531 8D 0D D2			STA	SEROUT	;start bit only
  2831
  2832 C534 60				RTS		;return
  2833 					;SPACE	4,10
  2834 				;	ISW - Initialize Software
  2835 				*
  2836 				*	ENTRY	JSR	ISW
  2837 				*
  2838 				*	MODS
  2839 				*		Original Author Unknown
  2840 				*		1. Bring closer to Coding Standard (object unchanged).
  2841 				*		   R. K. Nordin	11/01/83
  2842
  2843
  2844 = C535			ISW	=	*		;entry
  2845
  2846 				;	Initialize BREAK key handling.
  2847
  2848 C535 C6 11			DEC	BRKKEY		;turn off BREAK key flag
  2849
  2850 C537 A9 92			LDA	#<BIR
  2851 C539 8D 36 02			STA	BRKKY		;set BREAK key IRQ routine address
  2852 C53C A9 C0			LDA	#>BIR
  2853 C53E 8D 37 02			STA	BRKKY+1
  2854
  2855 				;	Initialize RAMSIZ and MEMTOP.
  2856
  2857 C541 A5 06			LDA	TRAMSZ		;determined size of RAM
  2858 C543 8D E4 02			STA	RAMSIZ		;size of RAM
  2859 C546 8D E6 02			STA	MEMTOP+1	;high top of memory
  2860 C549 A9 00			LDA	#$00
  2861 C54B 8D E5 02			STA	MEMTOP		;low top of memory
  2862
  2863 				;	Initialize MEMLO.
  2864
  2865 C54E A9 00			LDA	#<INIML	;initial MEMLO address
  2866 C550 8D E7 02			STA	MEMLO
  2867 C553 A9 07			LDA	#>INIML
  2868 C555 8D E8 02			STA	MEMLO+1
  2869
  2870 				;	Initialize device handlers.
  2871
  2872 C558 20 0C E4			JSR	EDITRV+12	;initialize editor handler
  2873 C55B 20 1C E4			JSR	SCRENV+12	;initialize screen handler
  2874 C55E 20 2C E4			JSR	KEYBDV+12	;initialize keyboard handler
  2875 C561 20 3C E4			JSR	PRINTV+12	;initialize printer handler
  2876 C564 20 4C E4			JSR	CASETV+12	;initialize cassette handler
  2877
  2878 				;	Initialize various routines.
  2879
  2880 C567 20 6E E4			JSR	CIOINV		;initialize CIO
  2881 C56A 20 65 E4			JSR	SIOINV		;initialize SIO
  2882 C56D 20 6B E4			JSR	INTINV		;initialize interrupt handler
  2883 C570 20 50 E4			JSR	DINITV		;initialize DIO
  2884
  2885 				;	Initialize generic parallel device handler.
  2886
  2887 C573 A9 6E			LDA	#<PIR
  2888 C575 8D 38 02			STA	VPIRQ		;parallel device IRQ routin:
  2889 C578 A9 C9			LDA	#>PIR
  2890 C57A 8D 39 02			STA	VPIRQ+1
  2891
  2892 C57D 20 9B E4			JSR	GPDVV+12	;initialize parallel device:
  2893 					
  2894 				;	Set status of START key.
  2895
  2896 C580 AD 1F D0			LDA	CONSOL		;console switches
  2897 C583 29 01			AND	#$01		;START key indicator
  2898 C585 49 01			EOR	#$01		;START key status
  2899 C587 8D E9 03			STA	CKEY		;cassette boot request flag
  2900
  2901 C58A 60				RTS			;return
  2902 					;SPACE	4,10
  2903 				;	ADB - Attempt Disk Boot
  2904 				*
  2905 				*	ENTRY	JSR	ADB
  2906 				*
  2907 				*	MODS
  2908 				*		Original Author Unknown
  2909 				*		1. Bring closer to Coding Standard (object unchanged).
  2910 				*		   R. K. Nordin	11/01/83
  2911
  2912
  2913 = C58B			ADB	=	*	;entry
  2914
  2915 				;	Check type of reset.
  2916
  2917 C58B A5 08			LDA	WARMST
  2918 C58D F0 09			BEQ	ADB1	;if not warmstart
  2919
  2920 				;	Process warmstart.
  2921
  2922 C58F A5 09			LDA	BOOT?	;successful boot flags
  2923 C591 29 01			AND	#$01	;successful disk boot indicator
  2924 C593 F0 33			BEQ	BAI2	;if disk boot not successful, return
  2925
  2926 				;	Initialize disk booted software.
  2927
  2928 C595 4C 3B C6			JMP	IBS	;initialize booted software
  2929
  2930 				;	Process coldstart.
  2931
  2932 C598 A9 01		ADB1	LDA	#1
  2933 C59A 8D 01 03			STA	DUNIT	;disk unit number
  2934 C59D A9 53			LDA	#STATC	;status
  2935 C59F 8D 02 03			STA	DCOMND	;command
  2936 C5A2 20 53 E4			JSR	DSKINV	;issue command
  2937 C5A5 30 21			BMI	BAI2	;if error, return
  2938
  2939 				;	Boot.
  2940
  2941 				;	JMP	ABI	;attempt boot and initialize
  2942 					;SPACE	4,10
  2943 				;	ABI - Attempt Boot and Initialize
  2944 				*
  2945 				*	ENTRY	JSR	ABI
  2946 				*
  2947 				*	MODS
  2948 				*		Original Author Unknown
  2949 				*		1. Bring closer to Coding Standard (object unchanged).
  2950 				*		   R. K. Nordin	11/01/83
  2951
  2952
  2953 = C5A7			ABI	=	*		;entry
  2954
  2955 C5A7 A9 00			LDA	#>1
  2956 C5A9 8D 0B 03			STA	DAUX2
  2957 C5AC A9 01			LDA	#<1		;sector number
  2958 C5AE 8D 0A 03			STA	DAUX1
  2959
  2960 C5B1 A9 00			LDA	#<[CASBUF+3]	;buffer address
  2961 C5B3 8D 04 03			STA	DBUFLO
  2962 C5B6 A9 04			LDA	#>[CASBUF+3]
  2963 C5B8 8D 05 03			STA	DBUFHI
  2964
  2965 				;	JMP	BAI		;boot and initialize
  2966 					;SPACE	4,10
  2967 				;	BAI - Boot and Initialize
  2968 				*
  2969 				*	ENTRY	JSR	BAI
  2970 				*
  2971 				*	MODS
  2972 				*		Original Author Unknown
  2973 				*		1. Bring closer to Coding Standard (object unchanged).
  2974 				*		   R. K. Nordin	11/01/83
  2975
  2976
  2977 = C5BB			BAI	=	*	;entry
  2978
  2979 				;	Read first sector.
  2980
  2981 C5BB 20 59 C6			JSR	GNS	;get next sector
  2982 C5BE 10 09			BPL	CBI	;if no error, complete boot and initialize
  2983
  2984 				;	Process error.
  2985
  2986 C5C0 20 3E C6		BAI1	JSR	DBE	;display boot error message
  2987
  2988 C5C3 AD EA 03			LDA	CASSBT
  2989 C5C6 F0 DF			BEQ	ABI	;if not cassette boot, try again
  2990
  2991 				;	Exit.
  2992
  2993 C5C8 60			BAI2	RTS		;return
  2994 					;SPACE	4,10
  2995 				;	CBI - Complete Boot and Initialize
  2996 				*
  2997 				*	ENTRY	JSR	CBI
  2998 				*
  2999 				*	MODS
  3000 				*		Original Author Unknown
  3001 				*		1. Bring closer to Coding Standard (object unchanged).
  3002 				*		   R. K. Nordin	11/01/83
  3003
  3004
  3005 = C5C9			CBI	=	*	;entry
  3006
  3007 				;	Transfer flags.
  3008
  3009 C5C9 A2 03			LDX	#3
  3010
  3011 C5CB BD 00 04		CBI1	LDA	CASBUF+3,X	;byte from buffer
  3012 C5CE 9D 40 02			STA	DFLAGS,X	;flag byte
  3013 C5D1 CA				DEX
  3014 C5D2 10 F7			BPL	CBI1		;if not done
  3015
  3016 				;	Transfer sector.
  3017
  3018 C5D4 AD 42 02			LDA	BOOTAD
  3019 C5D7 85 04			STA	RAMLO		;set boot address
  3020 C5D9 AD 43 02			LDA	BOOTAD+1
  3021 C5DC 85 05			STA	RAMLO+1
  3022
  3023 C5DE AD 04 04			LDA	CASBUF+7
  3024 C5E1 85 0C			STA	DOSINI		;establish initializtion address
  3025 C5E3 AD 05 04			LDA	CASBUF+8
  3026 C5E6 85 0D			STA	DOSINI+1
  3027
  3028 C5E8 A0 7F		CBI2	LDY	#127		;offset to last byte of sector
  3029
  3030 C5EA B9 00 04		CBI3	LDA	CASBUF+3,Y	;byte of sector buffer
  3031 C5ED 91 04			STA	(RAMLO),Y	;byte of boot program
  3032 C5EF 88				DEY
  3033 C5F0 10 F8			BPL	CBI3		;if not done
  3034
  3035 				;	Increment loader buffer pointer.
  3036
  3037 C5F2 18				CLC
  3038 C5F3 A5 04			LDA	RAMLO
  3039 C5F5 69 80			ADC	#$80
  3040 C5F7 85 04			STA	RAMLO
  3041 C5F9 A5 05			LDA	RAMLO+1
  3042 C5FB 69 00			ADC	#0
  3043 C5FD 85 05			STA	RAMLO+1		;increment boot loader buffer pointer
  3044
  3045 				;	Decrement and check number of sectors.
  3046
  3047 C5FF CE 41 02			DEC	DBSECT		;decrement number of sectors
  3048 C602 F0 12			BEQ	CBI5		;if no more sectors
  3049
  3050 				;	Get next sector.
  3051
  3052 C604 EE 0A 03			INC	DAUX1	;increment sector number
  3053
  3054 C607 20 59 C6		CBI4	JSR	GNS	;get next sector
  3055 C60A 10 DC			BPL	CBI2	;if status OK
  3056
  3057 				;	Process error.
  3058
  3059 C60C 20 3E C6			JSR	DBE	;display boot error message
  3060 C60F AD EA 03			LDA	CASSBT
  3061 C612 D0 AC			BNE	BAI1	;if cassette, start over
  3062
  3063 C614 F0 F1			BEQ	CBI4	;try sector again
  3064
  3065 				;	Clean up.
  3066
  3067 C616 AD EA 03		CBI5	LDA	CASSBT
  3068 C619 F0 03			BEQ	CBI6	;if not cassette boot
  3069
  3070 C61B 20 59 C6			JSR	GNS	;get EOF record (but do not use it)
  3071
  3072 				;	Execute boot loader.
  3073
  3074 C61E 20 29 C6		CBI6	JSR	EBL	;execute boot loader
  3075 C621 B0 9D			BCS	BAI1	;if bad boot, try again
  3076
  3077 				;	Initialize booted software.
  3078
  3079 C623 20 3B C6			JSR	IBS	;initialize booted software
  3080 C626 E6 09			INC	BOOT?	;indicate boot success
  3081 C628 60				RTS		;return
  3082 					;SPACE	4,10
  3083 				;	EBL - Execute Boot Loader
  3084 				*
  3085 				*	ENTRY	JSR	EBL
  3086 				*
  3087 				*	MODS
  3088 				*		Original Author Unknown
  3089 				*		1. Bring closer to Coding Standard (object unchanged).
  3090 				*		   R. K. Nordin	11/01/83
  3091
  3092
  3093 = C629			EBL	=	*		;entry
  3094
  3095 				;	Move boot loader start address to RAMLO.
  3096
  3097 C629 18				CLC
  3098 C62A AD 42 02			LDA	BOOTAD
  3099 C62D 69 06			ADC	#6
  3100 C62F 85 04			STA	RAMLO		;boot loader start address
  3101 C631 AD 43 02			LDA	BOOTAD+1
  3102 C634 69 00			ADC	#0
  3103 C636 85 05			STA	RAMLO+1
  3104
  3105 				;	Execute boot loader.
  3106
  3107 C638 6C 04 00			JMP	(RAMLO)		;execute boot loader
  3108 					;SPACE	4,10
  3109 				;	IBS - Initialize Booted Software
  3110 				*
  3111 				*	ENTRY	JSR	IBS
  3112 				*
  3113 				*	MODS
  3114 				*		Original Author Unknown
  3115 				*		1. Bring closer to Coding Standard (object unchanged).
  3116 				*		   R. K. Nordin	11/01/83
  3117
  3118
  3119 = C63B			IBS	=	*		;entry
  3120 C63B 6C 0C 00			JMP	(DOSINI)	;initialize booted software
  3121 					;SPACE	4,10
  3122 				;	DBE - Display Boot Error Message
  3123 				*
  3124 				*	ENTRY	JSR	DBE
  3125 				*
  3126 				*	NOTES
  3127 				*		Problem: bytes wasted by LDX/TXA and LDY/TYA
  3128 				*		combinations.
  3129 				*
  3130 				*	MODS
  3131 				*		Original Author Unknown
  3132 				*		1. Bring closer to Coding Standard (object unchanged).
  3133 				*		   R. K. Nordin	11/01/83
  3134
  3135
  3136 = C63E			DBE	=	*		;entry
  3137
  3138 				;	Set up IOCB.
  3139
  3140 C63E A2 3D			LDX	#<BMSG	;boot error message
  3141 C640 A0 C4			LDY	#>BMSG
  3142 C642 8A				TXA
  3143 C643 A2 00			LDX	#SEIOCB		;screen editor IOCB index
  3144 C645 9D 44 03			STA	ICBAL,X 	;low buffer address
  3145 C648 98				TYA
  3146 C649 9D 45 03			STA	ICBAH,X		;high buffer address
  3147 C64C A9 09			LDA	#PUTREC
  3148 C64E 9D 42 03			STA	ICCOM,X		;command
  3149 C651 A9 FF			LDA	#$FF
  3150 C653 9D 48 03			STA	ICBLL,X		;buffer length
  3151
  3152 				;	Perform CIO.
  3153
  3154 C656 4C 56 E4			JMP	CIOV		;vector to CIO, return
  3155 					;SPACE	4,10
  3156 				;	GNS - Get Next Sector
  3157 				*
  3158 				*	ENTRY	JSR	GNS
  3159 				*
  3160 				*	MODS
  3161 				*		Original Author Unknown
  3162 				*		1. Bring closer to Coding Standard (object unchanged).
  3163 				*		   R. K. Nordin	11/01/83
  3164
  3165
  3166 = C659			GNS	=	*	;entry
  3167
  3168 				;	Check type of boot.
  3169
  3170 C659 AD EA 03			LDA	CASSBT
  3171 C65C F0 03			BEQ	GNS1	;if not cassette boot
  3172
  3173 				;	Read block from cassette.
  3174
  3175 C65E 4C 7A E4			JMP	RBLOKV	;vector to read cassette block routine, return
  3176
  3177 				;	Read sector from disk.
  3178
  3179 C661 A9 52		GNS1	LDA	#READ
  3180 C663 8D 02 03			STA	DCOMND	;command
  3181 C666 A9 01			LDA	#1	;drive number 1
  3182 C668 8D 01 03			STA	DUNIT	;set drive number
  3183 C66B 4C 53 E4			JMP	DSKINV	;vector to DIO, return
  3184 					;SPACE	4,10
  3185 				;	ACB - Attempt Cassette Boot
  3186 				*
  3187 				*	ENTRY	JSR	ACB
  3188 				*
  3189 				*	MODS
  3190 				*		Original Author Unknown
  3191 				*		1. Bring closer to Coding Standard (object unchanged).
  3192 				*		   R. K. Nordin	11/01/83
  3193
  3194
  3195 = C66E			ACB	=	*	;entry
  3196
  3197 				;	Check type.
  3198
  3199 C66E A5 08			LDA	WARMST	;warmstart flag
  3200 C670 F0 09			BEQ	ACB1	;if coldstart
  3201
  3202 				;	Perform warmstart procedures.
  3203
  3204 C672 A5 09			LDA	BOOT?	;successful boot flags
  3205 C674 29 02			AND	#$02	;successful cassette boot indicator
  3206 C676 F0 27			BEQ	ACB2	;if cassette boot not successful
  3207
  3208 C678 4C A0 C6			JMP	ACB3	;initialize cassette
  3209
  3210 				;	Perform coldstart procedures.
  3211
  3212 C67B AD E9 03		ACB1	LDA	CKEY	;cassette boot request flag
  3213 C67E F0 1F			BEQ	ACB2	;if cassette boot not requested, return
  3214
  3215 				;	Boot cassette.
  3216
  3217 C680 A9 80			LDA	#$80
  3218 C682 85 3E			STA	FTYPE	;set long IRG type
  3219 C684 EE EA 03			INC	CASSBT	;set cassette boot flag
  3220 C687 20 7D E4			JSR	CSOPIV	;open cassette for input
  3221 C68A 20 BB C5			JSR	BAI	;boot and initialize
  3222 C68D A9 00			LDA	#0
  3223 C68F 8D EA 03			STA	CASSBT	;clear cassette boot flag
  3224 C692 8D E9 03			STA	CKEY	;clear cassette boot request flag
  3225 C695 06 09			ASL	BOOT?	;indicate successful cassette boot
  3226
  3227 C697 A5 0C			LDA	DOSINI
  3228 C699 85 02			STA	CASINI	;cassette software initialization address
  3229 C69B A5 0D			LDA	DOSINI+1
  3230 C69D 85 03			STA	CASINI+1
  3231
  3232 				;	Exit.
  3233
  3234 C69F 60			ACB2	RTS		;return
  3235
  3236 				;	Initialize cassette booted program.
  3237
  3238 C6A0 6C 02 00		ACB3	JMP	(CASINI)	;initialize cassette booted program
  3239 				;	;SUBTTL	'Disk Input/Ouput'
  3240 					;SPACE	4,10
  3241 				;	IDIO - Initialize DIO
  3242 				*
  3243 				*	ENTRY	JSR	IDIO
  3244 				*
  3245 				*	MODS
  3246 				*		Original Author Unknown
  3247 				*		1. Bring closer to Coding Standard (object unchanged).
  3248 				*		   R. K. Nordin	11/01/83
  3249
  3250
  3251 = C6A3			IDIO	=	*		;entry
  3252 C6A3 A9 A0			LDA	#160		;160 second timeout
  3253 C6A5 8D 46 02			STA	DSKTIM		;set initial disk timeout
  3254 C6A8 A9 80			LDA	#<DSCTSZ	;disk sector size
  3255 C6AA 8D D5 02			STA	DSCTLN
  3256 C6AD A9 00			LDA	#>DSCTSZ
  3257 C6AF 8D D6 02			STA	DSCTLN+1
  3258 C6B2 60				RTS			;return
  3259 					;SPACE	4,10
  3260 				;	DIO - Disk I/O
  3261 				*
  3262 				*	ENTRY	JSR	DIO
  3263 				*
  3264 				*	MODS
  3265 				*		Original Author Unknown
  3266 				*		1. Bring closer to Coding Standard (object unchanged).
  3267 				*		   R. K. Nordin	11/01/83
  3268
  3269
  3270 = C6B3			DIO	=	*		;entry
  3271
  3272 				;	Initialize.
  3273
  3274 C6B3 A9 31			LDA	#DISKID		;disk bus ID
  3275 C6B5 8D 00 03			STA	DDEVIC		;device bus ID
  3276 C6B8 AD 46 02			LDA	DSKTIM		;timeout
  3277 C6BB AE 02 03			LDX	DCOMND		;command
  3278 C6BE E0 21			CPX	#FOMAT
  3279 C6C0 F0 02			BEQ	DIO1		;if FORMAT command
  3280
  3281 C6C2 A9 07			LDA	#7		;set timeout to 7 seconds
  3282
  3283 C6C4 8D 06 03		DIO1	STA	DTIMLO		;timeout
  3284
  3285 				;	Set SIO command.
  3286
  3287 C6C7 A2 40			LDX	#GETDAT		;assume GET DATA
  3288
  3289 C6C9 AD 02 03			LDA	DCOMND		;command
  3290 C6CC C9 50			CMP	#PUTSEC
  3291 C6CE F0 04			BEQ	DIO2		;if PUT SECTOR command
  3292
  3293 C6D0 C9 57			CMP	#WRITE
  3294 C6D2 D0 02			BNE	DIO3		;if not WRITE command
  3295
  3296 C6D4 A2 80		DIO2	LDX	#PUTDAT		;select PUT DATA
  3297
  3298 				;	Check command.
  3299
  3300 C6D6 C9 53		DIO3	CMP	#STATC
  3301 C6D8 D0 10			BNE	DIO4		;if not STATUS command
  3302
  3303 				;	Set up STATUS command.
  3304
  3305 C6DA A9 EA			LDA	#<DVSTAT
  3306 C6DC 8D 04 03			STA	DBUFLO		;buffer address
  3307 C6DF A9 02			LDA	#>DVSTAT
  3308 C6E1 8D 05 03			STA	DBUFHI
  3309 C6E4 A0 04			LDY	#<4		;low byte count
  3310 C6E6 A9 00			LDA	#>4		;high byte count
  3311 C6E8 F0 06			BEQ	DIO5		;perform SIO
  3312
  3313 				;	Set up other commands.
  3314
  3315 C6EA AC D5 02		DIO4	LDY	DSCTLN		;low byte count
  3316 C6ED AD D6 02			LDA	DSCTLN+1	;high byte count
  3317
  3318 				;	Perform SIO.
  3319
  3320 C6F0 8E 03 03		DIO5	STX	DSTATS		;SIO command
  3321 C6F3 8C 08 03			STY	DBYTLO		;low byte count
  3322 C6F6 8D 09 03			STA	DBYTHI		;high byte count
  3323 C6F9 20 59 E4			JSR	SIOV		;vector to SIO
  3324 C6FC 10 01			BPL	DIO6		;if no error
  3325
  3326 				;	Process error.
  3327
  3328 C6FE 60				RTS			;return
  3329
  3330 				;	Process successful operation.
  3331
  3332 C6FF AD 02 03		DIO6	LDA	DCOMND		;command
  3333 C702 C9 53			CMP	#STATC
  3334 C704 D0 0A			BNE	DIO7		;if not STATUS command
  3335
  3336 C706 20 3A C7			JSR	SBA		;set buffer address
  3337 C709 A0 02			LDY	#2
  3338 C70B B1 15			LDA	(BUFADR),Y	;timeout status
  3339 C70D 8D 46 02			STA	DSKTIM		;disk timeout
  3340
  3341 				;	Set byte count.
  3342
  3343 C710 AD 02 03		DIO7	LDA	DCOMND
  3344 C713 C9 21			CMP	#FOMAT
  3345 C715 D0 1F			BNE	DIO10		;if not FORMAT command
  3346
  3347 C717 20 3A C7			JSR	SBA		;set buffer address
  3348 C71A A0 FE			LDY	#$FE		;initial buffer pointer
  3349
  3350 C71C C8			DIO8	INY			;increment buffer pointer
  3351 C71D C8				INY			;increment buffer pointer
  3352
  3353 C71E B1 15		DIO9	LDA	(BUFADR),Y	;low bad sector data
  3354 C720 C9 FF			CMP	#$FF
  3355 C722 D0 F8			BNE	DIO8		;if low not $FF
  3356
  3357 C724 C8				INY
  3358 C725 B1 15			LDA	(BUFADR),Y	;high bad sector data
  3359 C727 C8				INY
  3360 C728 C9 FF			CMP	#$FF
  3361 C72A D0 F2			BNE	DIO9		;if high not $FF
  3362
  3363 C72C 88				DEY
  3364 C72D 88				DEY
  3365 C72E 8C 08 03			STY	DBYTLO		;low bad sector byte count
  3366 C731 A9 00			LDA	#0
  3367 C733 8D 09 03			STA	DBYTHI		;high bad sector byte count
  3368
  3369 				;	Exit.
  3370
  3371 C736 AC 03 03		DIO10	LDY	DSTATS		;status
  3372 C739 60				RTS			;return
  3373 					;SPACE	4,10
  3374 				;	SBA - Set Buffer Address
  3375 				*
  3376 				*	ENTRY	JSR	SBA
  3377 				*
  3378 				*	MODS
  3379 				*		Original Author Unknown
  3380 				*		1. Bring closer to Coding Standard (object unchanged).
  3381 				*		   R. K. Nordin	11/01/83
  3382
  3383
  3384 = C73A			SBA	=	*		;entry
  3385 C73A AD 04 03			LDA	DBUFLO
  3386 C73D 85 15			STA	BUFADR		;buffer address
  3387 C73F AD 05 03			LDA	DBUFHI
  3388 C742 85 16			STA	BUFADR+1
  3389 C744 60				RTS			;return
  3390 				;	;SUBTTL	'Relocating Loader'
  3391 					;SPACE	4,10
  3392 				;	RLR - Relocate Routine
  3393 				*
  3394 				*	RLR relocates a relocatable routine which is assemb:
  3395 				*	origin 0.
  3396 				*
  3397 				*	ENTRY	JSR	RLR
  3398 				*		GBYTEA - GBYTEA+1 = address of get-byte rou:
  3399 				*
  3400 				*	MODS
  3401 				*		Y. M. Chen	04/01/82
  3402 				*		1. Bring closer to Coding Standard (object unchanged).
  3403 				*		   R. K. Nordin	11/01/83
  3404
  3405
  3406 = C745			RLR	=	*		;entry
  3407
  3408 				;	Clear parameter block.
  3409
  3410 C745 A2 05			LDX	#5		;offset to last parameter
  3411
  3412 C747 A9 00		RLR1	LDA	#0
  3413 C749 9D C9 02			STA	PARMBL,X	;clear byte of parameter bl:
  3414 C74C CA				DEX
  3415 C74D 10 F8			BPL	RLR1		;if not done
  3416
  3417 				;	Get a new record type and set the subroutine vector:
  3418
  3419 C74F A9 00		RLR2	LDA	#0
  3420 C751 8D 33 02			STA	LCOUNT		;process 0th byte of a reco:
  3421 C754 20 CF C7			JSR	GBY		;get type ID
  3422 C757 A0 9C			LDY	#DATAER
  3423 C759 B0 39			BCS	RLR4		;if EOF before END record
  3424
  3425 C75B 8D 88 02			STA	HIBYTE		;save type ID
  3426 C75E 20 CF C7			JSR	GBY		;get record length
  3427 C761 A0 9C			LDY	#DATAER
  3428 C763 B0 2F			BCS	RLR4		;if EOF before END record
  3429
  3430 C765 8D 45 02			STA	RECLEN
  3431 C768 AD 88 02			LDA	HIBYTE		;get type ID
  3432 C76B C9 0B			CMP	#$0B		;END record
  3433 C76D F0 26			BEQ	END		;if END record
  3434
  3435 C76F 2A				ROL		;set subroutine vectors
  3436 C770 AA				TAX
  3437 C771 BD E4 C8			LDA	TRPR,X
  3438 C774 8D C9 02			STA	RUNADR
  3439 C777 BD E5 C8			LDA	TRPR+1,X
  3440 C77A 8D CA 02			STA	RUNADR+1
  3441
  3442 C77D AD 45 02		RLR3	LDA	RECLEN
  3443 C780 CD 33 02			CMP	LCOUNT
  3444 C783 F0 CA			BEQ	RLR2		;if LCOUNT=RECLEN, get new :
  3445
  3446 C785 20 CF C7			JSR	GBY		;get next byte
  3447 C788 A0 9C			LDY	#DATAER
  3448 C78A B0 08			BCS	RLR4		;if EOF before END record
  3449
  3450 C78C 20 D2 C7			JSR	CAL		;call record subroutine
  3451 C78F EE 33 02			INC	LCOUNT
  3452 C792 D0 E9			BNE	RLR3		;continue
  3453
  3454 C794 60			RLR4	RTS			;return
  3455 					;SPACE	4,10
  3456 				;	END - Handle END Record
  3457 				*
  3458 				*	END handles record type of
  3459 				*	1.End Record
  3460 				*
  3461 				*	Record format:
  3462 				*	Byte 0		Type ID
  3463 				*	Byte 1		Self-start flag
  3464 				*	Bytes 2 - 3	Run address
  3465 				*
  3466 				*	Process formula
  3467 				*
  3468 				*	RUNADR+LOADAD ==> Start Execution Address n Loader-:
  3469 				*	parameter block.
  3470 				*
  3471 				*	End record calculates the start execution address b:
  3472 				*	RUNADR with LOADAD, and returns to the Caller with :
  3473 				*	block and a status byte in the Y register. Y=1 mean:
  3474 				*	successful, else is a data structure error.
  3475 				*
  3476 				*	ENTRY	JSR	END
  3477 				*
  3478 				*	MODS
  3479 				*		Y. M. Chen	04/01/82
  3480 				*		1. Bring closer to Coding Standard (object unchanged).
  3481 				*		   R. K. Nordin	11/01/83
  3482
  3483
  3484 = C795			END	=	*	;entry
  3485 C795 20 CF C7			JSR	GBY	;get low byte of the RUNADR
  3486 C798 A0 9C			LDY	#DATAER
  3487 C79A B0 2C			BCS	END3	;if EOF before END record
  3488
  3489 C79C 8D C9 02			STA	RUNADR
  3490 C79F 20 CF C7			JSR	GBY	;get high byte of the RUNADR
  3491 C7A2 A0 9C			LDY	#DATAER
  3492 C7A4 B0 22			BCS	END3	;if EOF before END record
  3493
  3494 C7A6 8D CA 02			STA	RUNADR+1
  3495 C7A9 AD 45 02			LDA	RECLEN	;RECLEN here is self-start flag
  3496 C7AC C9 01			CMP	#1
  3497 C7AE F0 16			BEQ	END2	;if 1, an absolute RUNADR, no fixup
  3498
  3499 C7B0 90 17			BCC	END4	;if 0, this is not a self-start pro:
  3500
  3501 				;	Process relative start.
  3502
  3503 C7B2 18				CLC
  3504 C7B3 AD C9 02			LDA	RUNADR		;execution address, needs f:
  3505 C7B6 6D D1 02			ADC	LOADAD
  3506 C7B9 A8				TAY
  3507 C7BA AD CA 02			LDA	RUNADR+1
  3508 C7BD 6D D2 02			ADC	LOADAD+1	;A= high byte, Y=low byte
  3509
  3510 C7C0 8C C9 02		END1	STY	RUNADR		;set up Loader-Caller param:
  3511 C7C3 8D CA 02			STA	RUNADR+1
  3512
  3513 C7C6 A0 01		END2	LDY	#SUCCES		;Y=1 successful operation
  3514
  3515 C7C8 60			END3	RTS			;return
  3516
  3517 C7C9 A0 00		END4	LDY	#0		;fill self-start parameter :
  3518 C7CB A9 00			LDA	#0		;for non-self start program
  3519 C7CD F0 F1			BEQ	END1		;continue
  3520 					;SPACE	4,10
  3521 				;	GBY - Get Byte
  3522 				*
  3523 				*	ENTRY	JSR	GBY
  3524 				*
  3525 				*	MODS
  3526 				*		Y. M. Chen	04/01/82
  3527 				*		1. Bring closer to Coding Standard (object unchanged).
  3528 				*		   R. K. Nordin	11/01/83
  3529
  3530
  3531 = C7CF			GBY	=	*		;entry
  3532 C7CF 6C CF 02			JMP	(GBYTEA)	;get byte, return
  3533 					;SPACE	4,10
  3534 				;	CAL - Execute at Run Address
  3535 				*
  3536 				*	ENTRY	JSR	CAL
  3537 				*
  3538 				*	MODS
  3539 				*		Y. M. Chen	04/01/82
  3540 				*		1. Bring closer to Coding Standard (object unchanged).
  3541 				*		   R. K. Nordin	11/01/83
  3542
  3543
  3544 = C7D2			CAL	=	*		;entry
  3545 C7D2 6C C9 02			JMP	(RUNADR)	;process record, return
  3546 					;SPACE	4,10
  3547 				;	TEX - Handle Text Record
  3548 				*
  3549 				*	TEX handles record types of
  3550 				*
  3551 				*	1.Non-zero page relocatable text
  3552 				*	2.Zero page relocatable text
  3553 				*	3.Absolute text
  3554 				*
  3555 				*	Record format
  3556 				*
  3557 				*	|Type	|Length		|Relative addr.	|text	|
  3558 				*	|ID	|(RECLEN)	|(RELADR)	|	|
  3559 				*
  3560 				*	Process formula
  3561 				*	A register ===> (NEWADR+LCOUNT)
  3562 				*
  3563 				*	Relocate object text into fixed address of NEWADR+L:
  3564 				*
  3565 				*	ENTRY	JSR	TEX
  3566 				*
  3567 				*	NOTES
  3568 				*
  3569 				*	1.The relocating address (NEWADR) for absolute text:
  3570 				*	relative address (RELADR), relocating address fixup:
  3571 				*	needed.
  3572 				*	2.There is no need to compare MEMTOP for processing:
  3573 				*	text.
  3574 				*	3.X register is used as an indexing to zero page va:
  3575 				*	or non-zero page variables.	X=0 means pointing :
  3576 				*	page fariable, whereas X=2 means pointing to zero p:
  3577 				*	variables.
  3578 				*	4.Each byte of the object text comes in A register.
  3579 				*
  3580 				*	MODS
  3581 				*		Y. M. Chen	04/01/82
  3582 				*		1. Bring closer to Coding Standard (object unchanged).
  3583 				*		   R. K. Nordin	11/01/83
  3584
  3585
  3586 = C7D5			TEX	=	*	;entry
  3587 C7D5 AC 33 02			LDY	LCOUNT	;A register=data coming in
  3588 C7D8 C0 01			CPY	#$01
  3589 C7DA F0 0A			BEQ	TEX1	;if 1, process highest used address
  3590
  3591 C7DC B0 73			BCS	FTX	;if 2 or greater, relocate object t:
  3592
  3593 C7DE 8D 4A 02			STA	RELADR
  3594 C7E1 8D 8E 02			STA	NEWADR	;for absolute text NEWADR=RELADR
  3595 C7E4 90 6A			BCC	TEX8
  3596
  3597 				;	Set highest used address.
  3598
  3599 C7E6 8D 4B 02		TEX1	STA	RELADR+1	;save high byte of RELADR
  3600 C7E9 8D 8F 02			STA	NEWADR+1	;for absolute text NEWADR=R:
  3601 C7EC A2 00			LDX	#0		;X=an index to non-zero or :
  3602 C7EE AD 88 02			LDA	HIBYTE		;HIBYTE=Type ID
  3603 C7F1 F0 06			BEQ	TEX2		;if 0, process non-zero pag:
  3604 C7F3 C9 0A			CMP	#$0A
  3605 C7F5 F0 15			BEQ	TEX3		;if $0A, needs no relative :
  3606
  3607 C7F7 A2 02			LDX	#2		;X=2 for zero page text rec:
  3608
  3609 C7F9 18			TEX2	CLC			;fix relocating addr. for n:
  3610 C7FA AD 4A 02			LDA	RELADR		;text & zero page text
  3611 C7FD 7D D1 02			ADC	LOADAD,X	;NEWADR=RELADR+LOADAD
  3612 C800 8D 8E 02			STA	NEWADR
  3613 C803 AD 4B 02			LDA	RELADR+1
  3614 C806 7D D2 02			ADC	LOADAD+1,X
  3615 C809 8D 8F 02			STA	NEWADR+1	;Loader start relocating
  3616
  3617 C80C 18			TEX3	CLC
  3618 C80D AD 8E 02			LDA	NEWADR	;NEWADR+RECLEN is the last used mem:
  3619 C810 6D 45 02			ADC	RECLEN	;for this particular record
  3620 C813 48				PHA
  3621 C814 A9 00			LDA	#0	;A=high byte, S=low byte
  3622 C816 6D 8F 02			ADC	NEWADR+1
  3623 C819 A8				TAY		;high byte
  3624 C81A 68				PLA		;low byte
  3625 C81B 38				SEC
  3626 C81C E9 02			SBC	#2	;skip unwanted 2 bytes of relative :
  3627 C81E B0 01			BCS	TEX4
  3628
  3629 C820 88				DEY
  3630
  3631 C821 48			TEX4	PHA
  3632 C822 98				TYA
  3633 C823 DD CC 02			CMP	HIUSED+1,X	;HIUSED stores the highest :
  3634 C826 68				PLA
  3635 C827 90 10			BCC	TEX6		;if HIUSED>(NEWADR+RECLEN),:
  3636
  3637 C829 D0 05			BNE	TEX5		;if HIUSED<=(NEWADR+RECLEN)
  3638
  3639 C82B DD CB 02			CMP	HIUSED,X
  3640 C82E 90 09			BCC	TEX6
  3641
  3642 				;	Update HIUSED.
  3643
  3644 C830 9D CB 02		TEX5	STA	HIUSED,X	;update HIUSED
  3645 C833 48				PHA
  3646 C834 98				TYA
  3647 C835 9D CC 02			STA	HIUSED+1,X
  3648 C838 68				PLA
  3649
  3650 C839 AE 88 02		TEX6	LDX	HIBYTE
  3651 C83C E0 01			CPX	#$01
  3652 C83E F0 10			BEQ	TEX8	;if zero page text
  3653
  3654 				;	Check MEMTOP.
  3655
  3656 C840 CC E6 02			CPY	MEMTOP+1	;MEMTOP>HIUSED, OK
  3657 C843 90 0B			BCC	TEX8
  3658
  3659 C845 D0 05			BNE	TEX7
  3660
  3661 C847 CD E5 02			CMP	MEMTOP
  3662 C84A 90 04			BCC	TEX8
  3663
  3664 C84C 68			TEX7	PLA			;MEMTOP<=HIUSED then error
  3665 C84D 68				PLA			;do a force return to calle:
  3666 C84E A0 9D			LDY	#MEMERR		;set memory insufficient fl:
  3667
  3668 C850 60			TEX8	RTS			;return
  3669 					;SPACE	4,10
  3670 				;	FTX - Relocate Text into Memory
  3671 				*
  3672 				*	ENTRY	JSR	FTX
  3673 				*
  3674 				*	NOTES
  3675 				*		Problem: bytes wasted by JMP to RTS.
  3676 				*
  3677 				*	MODS
  3678 				*		Y. M. Chen	04/01/82
  3679 				*		1. Bring closer to Coding Standard (object unchanged).
  3680 				*		   R. K. Nordin	11/01/83
  3681
  3682
  3683 = C851			FTX	=	*	;entry
  3684 C851 38				SEC
  3685 C852 48				PHA		;A register has object text
  3686 C853 AD 33 02			LDA	LCOUNT	;LCOUNT counts 2 bytes of relative :
  3687 C856 E9 02			SBC	#2	;-2 is the total bytes of object te:
  3688 C858 18				CLC
  3689 C859 6D 8E 02			ADC	NEWADR
  3690 C85C 85 36			STA	LTEMP	;A ===>(NEWADR+LCOUNT-2)
  3691 C85E A9 00			LDA	#0
  3692 C860 6D 8F 02			ADC	NEWADR+1
  3693 C863 85 37			STA	LTEMP+1
  3694 C865 68				PLA
  3695 C866 A0 00			LDY	#0
  3696 C868 91 36			STA	(LTEMP),Y
  3697 C86A 4C 50 C8			JMP	TEX8	;return
  3698 					;SPACE	4,10
  3699 				;	WOR - Handle Word Reference Record Type
  3700 				*
  3701 				*	WOR handles record types of
  3702 				*
  3703 				*	1.Non-zero page word references to non-zero page.
  3704 				*	2.Zero page word references to non-zero page.
  3705 				*
  3706 				*	Record format
  3707 				*
  3708 				*	|Type	|Length		|Offset1|Offset2|Offsetn|
  3709 				*	|ID	|(RECLEN)	|A Reg.	|	|	|
  3710 				*
  3711 				*	Process formula
  3712 				*
  3713 				*	(A register +NEWADR)W +LOADAD ===> (NEWADR+ A regis:
  3714 				*
  3715 				*	Count, the offset from the start relocating address:
  3716 				*	low byte
  3717 				*	of a word needing to be fixed.  The fixup process i:
  3718 				*	content of the word and add loading address, then r:
  3719 				*	fixed word.
  3720 				*
  3721 				*	Offset information comes in A register.
  3722 				*
  3723 				*	ENTRY	JSR	WOR
  3724 				*
  3725 				*	MODS
  3726 				*		Y. M. Chen	04/01/82
  3727 				*		1. Bring closer to Coding Standard (object unchanged).
  3728 				*		   R. K. Nordin	11/01/83
  3729
  3730
  3731 = C86D			WOR	=	*		;entry
  3732 C86D 18				CLC
  3733 C86E 6D 8E 02			ADC	NEWADR		;offset in A register
  3734 C871 85 36			STA	LTEMP
  3735 C873 A9 00			LDA	#0
  3736 C875 6D 8F 02			ADC	NEWADR+1
  3737 C878 85 37			STA	LTEMP+1		;offset +NEWADR= LTEMP
  3738 C87A A0 00			LDY	#0
  3739 C87C B1 36			LDA	(LTEMP),Y	;get low byte content of wh:
  3740 C87E 18				CLC
  3741 C87F 6D D1 02			ADC	LOADAD		;fix low byte of a word
  3742 C882 91 36			STA	(LTEMP),Y
  3743 C884 E6 36			INC	LTEMP		;increment LTEMP pointer by:
  3744 C886 D0 02			BNE	WOR1		;if low not zero
  3745
  3746 C888 E6 37			INC	LTEMP+1		;increment high
  3747
  3748 C88A B1 36		WOR1	LDA	(LTEMP),Y	;fix high byte of a word
  3749 C88C 6D D2 02			ADC	LOADAD+1
  3750 C88F 91 36			STA	(LTEMP),Y	;restore processed content
  3751 C891 60				RTS			;return
  3752 					;SPACE	4,10
  3753 				;	LOO - Handle Low Byte and One Byte Record Types
  3754 				*
  3755 				*	LOO handles record types of
  3756 				*
  3757 				*	1.Non-zero page low byte references to non-zero ppa:
  3758 				*	2.Zero page low byte references to non-zero page.
  3759 				*	3.Non-zero page one byte references to zero page.
  3760 				*	4.Zero page one byte references to zero page.
  3761 				*
  3762 				*	Record format
  3763 				*
  3764 				*	|Type	|Length		|Offset1|Offset2|Offsetn|
  3765 				*	|ID	|(RECLEN)	|A Reg.	|A Reg.	|	|
  3766 				*
  3767 				*	The process formula for non-zero page low byte refe:
  3768 				*	non-zero page record and zero page low byte referen:
  3769 				*	non-zero page record is
  3770 				*
  3771 				*	(offset + NEWADR)+LOADAD ===> (offset +NEWADR)
  3772 				*
  3773 				*	The process formula for non-zero page one byte refe:
  3774 				*	zero
  3775 				*	page record and zero page one byte references to ze:
  3776 				*	record
  3777 				*	is
  3778 				*
  3779 				*	(offset + NEWADR)+LOADADZ ===> (offset + NEWADR)
  3780 				*
  3781 				*	Count from the offset from the start relocating add:
  3782 				*	low byte or one byte need to be fixed. Get the cont:
  3783 				*	low byte or one byteand add either LOADAD or LOADAD:
  3784 				*	page loading address), then restore the value.
  3785 				*
  3786 				*	The offset comes in A register.
  3787 				*
  3788 				*	The X register for this routine points to either no:
  3789 				*	variables or zero page variables. Record type 2 & 3:
  3790 				*	non-zero page variable, type 4 & 5 needs zero page :
  3791 				*
  3792 				*	X=2 points to zero page variable.
  3793 				*
  3794 				*	ENTRY	JSR	LOO
  3795 				*
  3796 				*	MODS
  3797 				*		Y. M. Chen	04/01/82
  3798 				*		1. Bring closer to Coding Standard (object unchanged).
  3799 				*		   R. K. Nordin	11/01/83
  3800
  3801
  3802 = C892			LOO	=	*	;entry
  3803 C892 A2 00			LDX	#0	;X=0 points to non-zero page variab:
  3804 C894 AC 88 02			LDY	HIBYTE	;HIBYTE has Type ID
  3805 C897 C0 04			CPY	#4	;type 4 & 5 needs zero page variabl:
  3806 C899 90 02			BCC	LOO1	;if type 2 or 3, need non-zero page:
  3807
  3808 C89B A2 02			LDX	#2	;point to zero page variable
  3809
  3810 C89D 18			LOO1	CLC		;offset is in A register
  3811 C89E 6D 8E 02			ADC	NEWADR	;offset+NEWADR=the byte needs fixup
  3812 C8A1 85 36			STA	LTEMP
  3813 C8A3 A9 00			LDA	#0
  3814 C8A5 6D 8F 02			ADC	NEWADR+1
  3815 C8A8 85 37			STA	LTEMP+1
  3816 C8AA A0 00			LDY	#0
  3817 C8AC B1 36			LDA	(LTEMP),Y	;get the content of offset+:
  3818 C8AE 18				CLC
  3819 C8AF 7D D1 02			ADC	LOADAD,X	;do relocating fixup
  3820 C8B2 91 36			STA	(LTEMP),Y	;restore the being fixed va:
  3821 C8B4 60				RTS			;return
  3822 					;SPACE	4,10
  3823 				;	HIG - Handle High Byte Record Types
  3824 				*
  3825 				*	HIG handles record types of
  3826 				*
  3827 				*	1.Non-zero page high bytes references to non-zero p:
  3828 				*	2.Zero page high bytes references to non-zero page.
  3829 				*
  3830 				*	Record format
  3831 				*
  3832 				*	|Type	|Length		|Offset1|Low byte|Offset2|L:
  3833 				*	|ID	|(RECLEN)	|HIBYTE	|A Reg.  | (HIBYTE):
  3834 				*
  3835 				*	Process formula
  3836 				*
  3837 				*	(HIBYTE+NEWADR)+[[LOADAD+A]/256] ==> (HIBYTE+NEWADR:
  3838 				*
  3839 				*	Count the offset from the start relocating address :
  3840 				*	byte needs to be fixed. Get the low byte informatio:
  3841 				*	A register, then add the low byte with LOADAD and s:
  3842 				*	flag depending on the calculation. Next do an addit:
  3843 				*	high byte, NEWADR and the C flag. Restore the addit:
  3844 				*	back to the high byte location in memory.
  3845 				*
  3846 				*	HIBYTE is not Type ID here. HIBYTE is used to store:
  3847 				*	byte value.
  3848 				*
  3849 				*	ENTRY	JSR	HIG
  3850 				*
  3851 				*	NOTES
  3852 				*		Problem: many instances of jumping to RTS i:
  3853 				*		wastes bytes.
  3854 				*
  3855 				*	MODS
  3856 				*		Y. M. Chen	04/01/82
  3857 				*		1. Bring closer to Coding Standard (object unchanged).
  3858 				*		   R. K. Nordin	11/01/83
  3859
  3860
  3861 = C8B5			HIG	=	*		;entry
  3862
  3863 				;	Initialize.
  3864
  3865 C8B5 48				PHA			;save offset pointing to hi:
  3866
  3867 				;	Check LCOUNT odd or even.
  3868
  3869 C8B6 AD 33 02			LDA	LCOUNT
  3870 C8B9 6A				ROR
  3871 C8BA 68				PLA
  3872 C8BB B0 15			BCS	HIG2		;if even number, process lo:
  3873
  3874 				;	Process high byte.
  3875
  3876 C8BD 18				CLC
  3877 C8BE 6D 8E 02			ADC	NEWADR
  3878 C8C1 85 36			STA	LTEMP		;get high byte value
  3879 C8C3 A9 00			LDA	#0
  3880 C8C5 6D 8F 02			ADC	NEWADR+1
  3881 C8C8 85 37			STA	LTEMP+1
  3882 C8CA A0 00			LDY	#0
  3883 C8CC B1 36			LDA	(LTEMP),Y
  3884 C8CE 8D 88 02			STA	HIBYTE		;save high byte content
  3885
  3886 C8D1 60			HIG1	RTS			;return
  3887
  3888 				;	Process low byte
  3889
  3890 C8D2 18			HIG2	CLC
  3891 C8D3 6D D1 02			ADC	LOADAD		;add low byte with LOADAD
  3892 C8D6 A9 00			LDA	#0
  3893 C8D8 6D D2 02			ADC	LOADAD+1
  3894 C8DB 6D 88 02			ADC	HIBYTE		;C flag+LOADAD(high byte)+H:
  3895 C8DE A0 00			LDY	#0
  3896 C8E0 91 36			STA	(LTEMP),Y	;store being fixed high byt:
  3897 C8E2 F0 ED			BEQ	HIG1
  3898 					;SPACE	4,10
  3899 				;	TRPR - Table of Record Processing Routines
  3900
  3901
  3902 C8E4 D5 C7		TRPR	.word	TEX	;0 - non-zero page relocatable text
  3903 C8E6 D5 C7			.word	TEX	;1 - zero page relocatable text
  3904 C8E8 92 C8			.word	LOO	;2 - non-zero page low byte to non-:
  3905 C8EA 92 C8			.word	LOO	;3 - zero page low byte to non-zero:
  3906 C8EC 92 C8			.word	LOO	;4 - non-zero page one byte to zero:
  3907 C8EE 92 C8			.word	LOO	;5 - zero page one byte to zero pag:
  3908 C8F0 6D C8			.word	WOR	;6 - non-zero page word to non-zero:
  3909 C8F2 6D C8			.word	WOR	;7 - zero page word to non-zero pag:
  3910 C8F4 B5 C8			.word	HIG	;8 - non-zero page high byte to non:
  3911 C8F6 B5 C8			.word	HIG	;9 - zero page high byte to non-zer:
  3912 C8F8 D5 C7			.word	TEX	;10 - absolute text
  3913 C8FA 95 C7			.word	END	;11 - end record
  3914 				;	;SUBTTL	'Self-test, Part 1'
  3915 					;SPACE	4,10
  3916 				;	SES - Select and Execute Self-test
  3917 				*
  3918 				*	SES selects the self-test ROM and executes the self-test.
  3919 				*
  3920 				*	ENTRY	JSR	SES
  3921 				*
  3922 				*	NOTES
  3923 				*		Problem: this could be contiguous with other OS ROM
  3924 				*		self-test code (near TSTO).
  3925 				*
  3926 				*	MODS
  3927 				*		M. W. Colburn	10/26/82
  3928 				*		1. Bring closer to Coding Standard (object unchanged).
  3929 				*		   R. K. Nordin	11/01/83
  3930
  3931
  3932 = C8FC			SES	=	*	;entry
  3933
  3934 C8FC A9 FF			LDA	#$FF
  3935 C8FE 8D 44 02			STA	COLDST	;force coldstart on RESET
  3936
  3937 C901 AD 01 D3			LDA	PORTB
  3938 C904 29 7F			AND	#$7F	;enable self-test ROM
  3939 C906 8D 01 D3			STA	PORTB	;update port B memory control
  3940
  3941 C909 4C 83 E4			JMP	SLFTSV	;vector to self-test
  3942 				;	;SUBTTL	'Parallel Input/Output'
  3943 					;SPACE	4,10
  3944 				;	GIN - Initialize Generic Parallel Device
  3945 				*
  3946 				*	ENTRY	JSR	GIN
  3947 				*
  3948 				*	MODS
  3949 				*		Y. M. Chen	02/18/83
  3950 				*		1. Bring closer to Coding Standard (object unchanged).
  3951 				*		   R. K. Nordin	11/01/83
  3952
  3953
  3954 = C90C			GIN	=	*	;entry
  3955
  3956 				;	Initialize.
  3957
  3958 C90C A9 01			LDA	#$01	;initially select device 0
  3959 C90E 8D 48 02			STA	SHPDVS	;device select shadow
  3960
  3961 				;	For each potential device, initialize if device pre:
  3962
  3963 C911 AD 48 02		GIN1	LDA	SHPDVS	;device select shadow
  3964 C914 8D FF D1			STA	PDVS	;device select
  3965
  3966 C917 AD 03 D8			LDA	PDID1	;first ID
  3967 C91A C9 80			CMP	#$80	;required value
  3968 C91C D0 0A			BNE	GIN2	;if first ID not verified
  3969
  3970 C91E AD 0B D8			LDA	PDID2	;second ID
  3971 C921 C9 91			CMP	#$91	;required value
  3972 C923 D0 03			BNE	GIN2	;if second ID not verified
  3973
  3974 C925 20 19 D8			JSR	PDVV+12	;initialize parallel device handler
  3975
  3976 C928 0E 48 02		GIN2	ASL	SHPDVS	;advance to next device
  3977 C92B D0 E4			BNE	GIN1	;if devices remain
  3978
  3979 				;	Exit
  3980
  3981 C92D A9 00			LDA	#$00	;select FPP (deselect device)
  3982 				;	STA	SHPDVS	;device select shadow
  3983 C92F 8D FF D1			STA	PDVS	;device select
  3984 C932 60				RTS		;return
  3985 					;SPACE	4,10
  3986 				;	PIO - Parallel Input/Output
  3987 				*
  3988 				*	ENTRY	JSR	PIO
  3989 				*
  3990 				*	NOTES
  3991 				*		Problem: in the CRASS65 section, CRITIC was:
  3992 				*		zero-page.
  3993 				*
  3994 				*	MODS
  3995 				*		Y. M. Chen	02/18/83
  3996 				*		1. Bring closer to Coding Standard (object unchanged).
  3997 				*		   R. K. Nordin	11/01/83
  3998
  3999
  4000 = C933			PIO	=	*	;entry
  4001
  4002 				;	Initialize.
  4003
  4004 C933 A9 01			LDA	#1
  4005 C935 8D 42 00			STA.w	CRITIC	;indicate critical section
  4006 				;!!!	VFD	8\$8D,8\low CRITIC,8\high CRITIC
  4007 C938 AD 01 03			LDA	DUNIT	;device unit number
  4008 C93B 48				PHA		;save device unit number
  4009 C93C AD 47 02			LDA	PDVMSK	;device selection mask
  4010 C93F F0 1A			BEQ	PIO2	;if no device to select
  4011
  4012 				;	For each device, pass request to device I/O routine:
  4013
  4014 C941 A2 08			LDX	#TPDSL	;offset to first byte beyond table
  4015
  4016 C943 20 AF C9		PIO1	JSR	SNP	;select next parallel device
  4017 C946 F0 13			BEQ	PIO2	;if no device selected
  4018
  4019 C948 8A				TXA
  4020 C949 48				PHA		;save offset
  4021 C94A 20 05 D8			JSR	PDIOV	;perform parallel device I/O
  4022 C94D 68				PLA		;saved offset
  4023 C94E AA				TAX		;restore offset
  4024 C94F 90 F2			BCC	PIO1	;if device did not field request
  4025
  4026 				;	Restore Floating Point Package.
  4027
  4028 C951 A9 00			LDA	#$00	;select FPP (deselect device)
  4029 C953 8D 48 02			STA	SHPDVS	;device select shadow
  4030 C956 8D FF D1			STA	PDVS	;device select
  4031 C959 F0 03			BEQ	PIO3	;exit
  4032
  4033 				;	Perform SIO.
  4034
  4035 C95B 20 71 E9		PIO2	JSR	SIO	;perform SIO
  4036
  4037 				;	Exit.
  4038
  4039 C95E 68			PIO3	PLA		;saved device unit number
  4040 C95F 8D 01 03			STA	DUNIT	;restore device unit number
  4041 C962 A9 00			LDA	#0
  4042 C964 8D 42 00			STA.w	CRITIC	;indicate non-critical section
  4043 				;!!!	VFD	8\$8D,8\low CRITIC,8\high CRITIC
  4044 C967 8C 03 03			STY	DSTATS
  4045 C96A AC 03 03			LDY	DSTATS	;status (re-establish N)
  4046 C96D 60				RTS		;return
  4047 					;SPACE	4,10
  4048 				;	PIR - Handle Parallel Device IRQ
  4049 				*
  4050 				*	ENTRY	JSR	PIR
  4051 				*
  4052 				*	EXIT
  4053 				*		Exits via RTI
  4054 				*
  4055 				*	MODS
  4056 				*		Y. M. Chen	02/18/83
  4057 				*		1. Bring closer to Coding Standard (object unchanged).
  4058 				*		   R. K. Nordin	11/01/83
  4059
  4060
  4061 = C96E			PIR	=	*	;entry
  4062
  4063 				;	Determine which device made IRQ, in order of priori:
  4064
  4065 C96E A2 08			LDX	#TPDSL	;offset to first byte beyond table
  4066
  4067 C970 6A			PIR1	ROR
  4068 C971 B0 03			BCS	PIR2	;if IRQ of that device
  4069
  4070 C973 CA				DEX
  4071 C974 D0 FA			BNE	PIR1	;if devices remain
  4072
  4073 				;	Select device and process IRQ.
  4074
  4075 C976 AD 48 02		PIR2	LDA	SHPDVS		;current device selection
  4076 C979 48				PHA			;save current device select:
  4077 C97A BD 20 CA			LDA	TPDS-1,X	;device selection desired
  4078 C97D 8D 48 02			STA	SHPDVS		;device select shadow
  4079 C980 8D FF D1			STA	PDVS		;device select
  4080 C983 20 08 D8			JSR	PDIRQV		;process IRQ
  4081
  4082 				;	Exit.
  4083
  4084 C986 68				PLA			;saved device selection
  4085 C987 8D 48 02			STA	SHPDVS		;restore device select shad:
  4086 C98A 8D FF D1			STA	PDVS		;device select
  4087 C98D 68				PLA			;saved X
  4088 C98E AA				TAX			;restore X
  4089 C98F 68				PLA			;restore A
  4090 C990 40				RTI			;return
  4091 					;SPACE	4,10
  4092 				;	GOP - Perform Generic Parallel Device OPEN
  4093 				*
  4094 				*	ENTRY	JSR	GOP
  4095 				*
  4096 				*	MODS
  4097 				*		Y. M. Chen	02/18/83
  4098 				*		1. Bring closer to Coding Standard (object unchanged).
  4099 				*		   R. K. Nordin	11/01/83
  4100
  4101
  4102 = C991			GOP	=	*	;entry
  4103 C991 A0 01			LDY	#1	;offset for OPEN
  4104 C993 4C DC C9			JMP	EPC	;execute parallel device handler co:
  4105 					;SPACE	4,10
  4106 				;	GCL - Perform Generic Parallel Device CLOSE
  4107 				*
  4108 				*	ENTRY	JSR	GCL
  4109 				*
  4110 				*	MODS
  4111 				*		Y. M. Chen	02/18/83
  4112 				*		1. Bring closer to Coding Standard (object unchanged).
  4113 				*		   R. K. Nordin	11/01/83
  4114
  4115
  4116 = C996			GCL	=	*	;entry
  4117 C996 A0 03			LDY	#3	;offset for CLOSE
  4118 C998 4C DC C9			JMP	EPC	;execute parallel device handler co:
  4119 					;SPACE	4,10
  4120 				;	GGB - Perform Generic Parallel Device GET-BYTE
  4121 				*
  4122 				*	ENTRY	JSR	GGB
  4123 				*
  4124 				*	MODS
  4125 				*		Y. M. Chen	02/18/83
  4126 				*		1. Bring closer to Coding Standard (object unchanged).
  4127 				*		   R. K. Nordin	11/01/83
  4128
  4129
  4130 = C99B			GGB	=	*	;entry
  4131 C99B A0 05			LDY	#5	;offset for GET-BYTE
  4132 C99D 4C DC C9			JMP	EPC	;execute parallel device handler co:
  4133 					;SPACE	4,10
  4134 				;	GPB - Perform Generic Parallel Device PUT-BYTE
  4135 				*
  4136 				*	ENTRY	JSR	GPB
  4137 				*
  4138 				*	MODS
  4139 				*		Y. M. Chen	02/18/83
  4140 				*		1. Bring closer to Coding Standard (object unchanged).
  4141 				*		   R. K. Nordin	11/01/83
  4142
  4143
  4144 = C9A0			GPB	=	*	;entry
  4145 C9A0 A0 07			LDY	#7	;offset for PUT-BYTE
  4146 C9A2 4C DC C9			JMP	EPC	;execute parallel device handler co:
  4147 					;SPACE	4,10
  4148 				;	GST - Perform Generic Parallel Device STATUS
  4149 				*
  4150 				*	ENTRY	JSR	GST
  4151 				*
  4152 				*	MODS
  4153 				*		Y. M. Chen	02/18/83
  4154 				*		1. Bring closer to Coding Standard (object unchanged).
  4155 				*		   R. K. Nordin	11/01/83
  4156
  4157
  4158 = C9A5			GST	=	*	;entry
  4159 C9A5 A0 09			LDY	#9	;offset for STATUS
  4160 C9A7 4C DC C9			JMP	EPC	;execute parallel device handler co:
  4161 					;SPACE	4,10
  4162 				;	GSP - Perform Generic Parallel Device SPECIAL
  4163 				*
  4164 				*	ENTRY	JSR	GSP
  4165 				*
  4166 				*	MODS
  4167 				*		Y. M. Chen	02/18/83
  4168 				*		1. Bring closer to Coding Standard (object unchanged).
  4169 				*		   R. K. Nordin	11/01/83
  4170
  4171
  4172 = C9AA			GSP	=	*	;entry
  4173 C9AA A0 0B			LDY	#11	;offset for SPECIAL
  4174 C9AC 4C DC C9			JMP	EPC	;execute parallel device handler co:
  4175 					;SPACE	4,10
  4176 				;	SNP - Select Next Parallel Device
  4177 				*
  4178 				*	ENTRY	JSR	SNP
  4179 				*
  4180 				*	MODS
  4181 				*		Y. M. Chen	02/18/83
  4182 				*		1. Bring closer to Coding Standard (object unchanged).
  4183 				*		   R. K. Nordin	11/01/83
  4184
  4185
  4186 = C9AF			SNP	=	*	;entry
  4187
  4188 				;	Decrement and check offset.
  4189
  4190 C9AF CA			SNP1	DEX		;decrement offset
  4191 C9B0 10 09			BPL	SNP2	;if devices remain
  4192
  4193 				;	Exit
  4194
  4195 C9B2 A9 00			LDA	#$00	;select FPP (deselect device)
  4196 C9B4 8D 48 02			STA	SHPDVS	;device select shadow
  4197 C9B7 8D FF D1			STA	PDVS	;device select
  4198 C9BA 60				RTS		;return
  4199
  4200 				;	Ensure device is indicated by selection mask.
  4201
  4202 C9BB AD 47 02		SNP2	LDA	PDVMSK	;device selection mask
  4203 C9BE 3D 21 CA			AND	TPDS,X	;device select
  4204 C9C1 F0 EC			BEQ	SNP1	;if device not indicated for select:
  4205
  4206 				;	Select device.
  4207
  4208 C9C3 8D 48 02			STA	SHPDVS	;device select shadow
  4209 C9C6 8D FF D1			STA	PDVS	;device select
  4210 C9C9 60				RTS		;return
  4211 					;SPACE	4,10
  4212 				;	IPH - Invoke Parallel Device Handler
  4213 				*
  4214 				*	ENTRY	JSR	IPH
  4215 				*		Y = offset into parallel defice vector tabl:
  4216 				*		PPTMPA	= original A value
  4217 				*		PPTMPX	= original X value
  4218 				*
  4219 				*	NOTES
  4220 				*		Problem: wasted byte for DEY.
  4221 				*
  4222 				*	MODS
  4223 				*		Y. M. Chen	02/18/83
  4224 				*		1. Bring closer to Coding Standard (object unchanged).
  4225 				*		   R. K. Nordin	11/01/83
  4226
  4227
  4228 = C9CA			IPH	=	*	;entry
  4229 C9CA B9 0D D8			LDA	PDVV,Y	;high routine address-1
  4230 C9CD 48				PHA		;place on stack
  4231 C9CE 88				DEY
  4232 C9CF B9 0D D8			LDA	PDVV,Y	;low routine address-1
  4233 C9D2 48				PHA		;place on stack
  4234 C9D3 AD 4C 02			LDA	PPTMPA	;restore A for handler
  4235 C9D6 AE 4D 02			LDX	PPTMPX	;restore X for handler
  4236 C9D9 A0 92			LDY	#FNCNOT	;preset status
  4237 C9DB 60				RTS		;invoke handler routine (address on:
  4238 					;SPACE	4,10
  4239 				;	EPC - Execute Parallel Device Handler Command
  4240 				*
  4241 				*	ENTRY	JSR	EPC
  4242 				*
  4243 				*	NOTES
  4244 				*		Problem: in the CRASS65 version, CRITIC was:
  4245 				*		zero-page.
  4246 				*
  4247 				*	MODS
  4248 				*		Y. M. Chen	02/18/83
  4249 				*		1. Bring closer to Coding Standard (object unchanged).
  4250 				*		   R. K. Nordin	11/01/83
  4251
  4252
  4253 = C9DC			EPC	=	*	;entry
  4254
  4255 				;	Initialize.
  4256
  4257 C9DC 8D 4C 02			STA	PPTMPA	;save data byte
  4258 C9DF 8E 4D 02			STX	PPTMPX	;save X
  4259 C9E2 AD 42 00			LDA.w	CRITIC
  4260 				;!!!	VFD	8\$AD,8\low CRITIC,8\high CRITIC
  4261 C9E5 48				PHA		;save critical section status
  4262 C9E6 A9 01			LDA	#1
  4263 C9E8 8D 42 00			STA.w	CRITIC	;indicate critical section
  4264 				;!!!	VFD	8\$8D,8\low CRITIC,8\high CRITIC
  4265
  4266 				;	For each device, pass request to device handler.
  4267
  4268 C9EB A2 08			LDX	#TPDSL	;offset to first byte beyond table
  4269
  4270 C9ED 20 AF C9		EPC1	JSR	SNP	;select next device
  4271 C9F0 F0 11			BEQ	EPC2	;if no device selected, return erro:
  4272
  4273 C9F2 8A				TXA
  4274 C9F3 48				PHA		;save offset
  4275 C9F4 98				TYA
  4276 C9F5 48				PHA		;save Y
  4277 C9F6 20 CA C9			JSR	IPH	;invoke parallel device handler
  4278 C9F9 90 20			BCC	EPC4	;if device did not field, try next :
  4279
  4280 				;	Clean up.
  4281
  4282 C9FB 8D 4C 02			STA	PPTMPA	;save possile data byte
  4283 C9FE 68				PLA		;clean stack
  4284 C9FF 68				PLA
  4285 CA00 4C 05 CA			JMP	EPC3	;exit
  4286
  4287 				;	Return Nonexistent Device error.
  4288
  4289 CA03 A0 82		EPC2	LDY	#NONDEV
  4290
  4291 				;	Restore Floating Point Package
  4292
  4293 CA05 A9 00		EPC3	LDA	#$00	;select FPP (deselect device)
  4294 CA07 8D 48 02			STA	SHPDVS	;device select shadow
  4295 CA0A 8D FF D1			STA	PDVS	;device select
  4296 CA0D 68				PLA		;saved critical section status
  4297 CA0E 8D 42 00			STA.w	CRITIC	;restore critical section status
  4298 				;!!!	VFD	8\$8D,8\low CRITIC,8\high CRITIC
  4299 CA11 AD 4C 02			LDA	PPTMPA	;restore possible data byte
  4300 CA14 8C 4D 02			STY	PPTMPX
  4301 CA17 AC 4D 02			LDY	PPTMPX	;status (re-establish N)
  4302 CA1A 60				RTS		;return
  4303
  4304 				;	Prepare to try next device.
  4305
  4306 CA1B 68			EPC4	PLA
  4307 CA1C A8				TAY		;restore Y
  4308 CA1D 68				PLA
  4309 CA1E AA				TAX		;restore X
  4310 CA1F 90 CC			BCC	EPC1	;try next device
  4311 					;SPACE	4,10
  4312 				;	TPDS - Table of Parallel Device Selects
  4313 				*
  4314 				*	NOTES
  4315 				*		Problem: bytes wasted by replication of thi:
  4316 				*		elsewhere.
  4317
  4318
  4319 CA21 80			TPDS	.byte	$80	;0 - device 7 (lowest priority)
  4320 CA22 40				.byte	$40	;1 - device 6
  4321 CA23 20				.byte	$20	;2 - device 5
  4322 CA24 10				.byte	$10	;3 - device 4
  4323 CA25 08				.byte	$08	;4 - device 3
  4324 CA26 04				.byte	$04	;5 - device 2
  4325 CA27 02				.byte	$02	;6 - device 1
  4326 CA28 01				.byte	$01	;7 - device 0 (highest priority)
  4327
  4328 = 0008			TPDSL	=	*-TPDS	;length
  4329 				;	;SUBTTL	'Peripheral Handler Loading Facility, Part 1'
  4330 					;SPACE	4,10
  4331 				;	PHL - Load and Initialize Peripheral Handler
  4332 				*
  4333 				*	Subroutine to load, relocate, initialize and open a
  4334 				*	"provisionally" opened IOCB. This routine is called
  4335 				*	upon first I/O attempt following provisional open.
  4336 				*	It does the final opening by simulating the first
  4337 				*	part of a normal CIO OPEN and then finishing with
  4338 				*	code which is in CIO.
  4339 				*
  4340 				*	Input parameters:
  4341 				*	ICIDNO	(specifies which IOCB);
  4342 				*	various values in the provisionally-opened IOCB:
  4343 				*		ICSPR (handler name)
  4344 				*		ICSPR+1 (serial address for loading);
  4345 				*	whatever the called subroutines require.
  4346 				*
  4347 				*	Output parameters:
  4348 				*	None. (Error returns are all handled by called subr:
  4349 				*		in fact, all returns are handled by called :
  4350 				*
  4351 				*	Modified:
  4352 				*	ICHID in both calling IOCB and ZIOCB (part of compl:
  4353 				*	ICCOMT (a CIO variable);
  4354 				*	Registers not saved.
  4355 				*
  4356 				*	Subroutines called:
  4357 				*	LPH (does the loading);
  4358 				*	PHC (initializes the loaded handler);
  4359 				*	FDH (a CIO entry--finds handler table entry of
  4360 				*		newly loaded/initialized handler);
  4361 				*	IIO (a CIO entry--finishes full proper opening of I:
  4362 				*		including calling handler OPEN entry--IIO r:
  4363 				*		to PHL's caller);
  4364 				*	IND (a CIO entry--returns with error to PHL's calle:
  4365 				*
  4366 				*	ENTRY	JSR	PHL
  4367 				*
  4368 				*	NOTES
  4369 				*		Problem: in the CRASS65 version, ICIDNO was:
  4370 				*		zero-page.
  4371 				*
  4372 				*	MODS
  4373 				*		R. S. Scheiman	04/01/82
  4374 				*		1. Bring closer to Coding Standard (object unchanged).
  4375 				*		   R. K. Nordin	11/01/83
  4376
  4377
  4378 = CA29			PHL	=	*		;entry
  4379
  4380 				;	Load peripheral handler.
  4381
  4382 CA29 AE 2E 00			LDX.w	ICIDNO		;IOCB index
  4383 				;!!!	VFD	8\$AE,8\low ICIDNO,8\high ICIDNO
  4384 CA2C BD 4D 03			LDA	ICSPR+1,X
  4385 CA2F 20 DE E7			JSR	LPH		;load peripheral handler
  4386 CA32 B0 20			BCS	PHL1		;if error
  4387
  4388 				;	Initialize peripheral handler
  4389
  4390 CA34 18				CLC			;indicate zero handler size
  4391 CA35 20 9E E8			JSR	PHC		;initialize peripheral hand:
  4392 CA38 B0 1A			BCS	PHL1		;if error
  4393
  4394 				;	Find device handler
  4395
  4396 CA3A AE 2E 00			LDX.w	ICIDNO		;IOCB index
  4397 				;!!!	VFD	8\$AE,8\low ICIDNO,8\high ICIDNO
  4398 CA3D BD 4C 03			LDA	ICSPR,X
  4399 CA40 20 16 E7			JSR	FDH		;find device handler
  4400 CA43 B0 0F			BCS	PHL1		;if not found
  4401
  4402 				;	Set handler ID.
  4403
  4404 CA45 AE 2E 00			LDX.w	ICIDNO		;IOCB index
  4405 				;!!!	VFD	8\$AE,8\low ICIDNO,8\high ICIDNO
  4406 CA48 9D 40 03			STA	ICHID,X		;handler ID
  4407 CA4B 85 20			STA	ICHIDZ
  4408
  4409 				;	Simulate initial CIO OPEN processing.
  4410
  4411 CA4D A9 03			LDA	#OPEN	;OPEN command
  4412 CA4F 85 17			STA	ICCOMT	;command
  4413 CA51 4C 5C E5			JMP	IIO	;initialize IOCB for OPEN, return
  4414
  4415 				;	Indicate nonexistent device error.
  4416
  4417 CA54 4C 10 E5		PHL1	JMP	IND	;indicate nonexistent device error,:
  4418 				;	;SUBTTL	'Self-test, Part 2'
  4419 					;SPACE	4,10
  4420 				;	TSTO - Table of Self-test Text Offsets
  4421
  4422
  4423 CA57 00			TSTO	.byte	TXT0-TTXT	;0 - offset to "MEMORY TEST   ROM" text
  4424 CA58 13				.byte	TXT1-TTXT	;1 - offset to "RAM" text
  4425 CA59 16				.byte	TXT2-TTXT	;2 - offset to "KEYBOARD TEST" text
  4426 CA5A D1				.byte	TXT3-TTXT	;3 - offset to "S P A C E   B A R" text
  4427 CA5B E4				.byte	TXT4-TTXT	;4 - offset to "SH" text
  4428 CA5C E4				.byte	TXT5-TTXT	;5 - offset to "SH" text
  4429 CA5D E8				.byte	TXT6-TTXT	;6 - offset to "B S" text
  4430 CA5E 29				.byte	TXT7-TTXT	;7 - offset to keyboard text
  4431 CA5F EB				.byte	TXT8-TTXT	;8 - offset to control key text
  4432 CA60 EE				.byte	TXT9-TTXT	;9 - offset to "VOICE #" text
  4433 					;SPACE	4,10
  4434 				;	TTXT - Table of Text Sequences
  4435
  4436
  4437 = CA61			TTXT	=	*
  4438 					;SPACE	4,10
  4439 				;	TXT0 - "MEMORY TEST   ROM" Text
  4440
  4441
  4442 CA61 00 00		TXT0	.byte	$00,$00
  4443 CA63 2D 25 2D 2F 32 39		.byte	$2D,$25,$2D,$2F,$32,$39	;"MEMORY"
  4444 CA69 00				.byte	$00
  4445 CA6A 34 25 33 34			.byte	$34,$25,$33,$34		;"TEST"
  4446 CA6E 00 00 00			.byte	$00,$00,$00
  4447 CA71 32 2F 2D			.byte	$32,$2F,$2D		;"ROM"
  4448
  4449 = 0013			TXT0L	=	*-TXT0	;length
  4450 					;SPACE	4,10
  4451 				;	TXT1 - "RAM" Text
  4452
  4453
  4454 CA74 32 21 2D		TXT1	.byte	$32,$21,$2D		;"RAM"
  4455
  4456 = 0003			TXT1L	=	*-TXT1	;length
  4457 					;SPACE	4,10
  4458 				;	TXT2 - "KEYBOARD TEST" Text
  4459
  4460
  4461 CA77 00 00		TXT2	.byte	$00,$00
  4462 CA79 2B 25 39 22 2F 21 + 	.byte	$2B,$25,$39,$22,$2F,$21,$32,$24	;"KEYBOARD"
  4463 CA81 00				.byte	$00
  4464 CA82 34 25 33 34			.byte	$34,$25,$33,$34			;"TEST"
  4465 CA86 00 00 00			.byte	$00,$00,$00
  4466 CA89 B2				.byte	$B2
  4467
  4468 = 0013			TXT2L	=	*-TXT2	;length
  4469 					;SPACE	4,10
  4470 				;	TXT7 - Keyboard
  4471
  4472
  4473 = CA8A			TXT7	=	*
  4474
  4475 				;	First Row (Function Keys)
  4476
  4477 CA8A 91				.byte	$91		;"1"
  4478 CA8B 00				.byte	$00
  4479 CA8C 92				.byte	$92		;"2"
  4480 CA8D 00				.byte	$00
  4481 CA8E 93				.byte	$93		;"3"
  4482 CA8F 00				.byte	$00
  4483 CA90 94				.byte	$94		;"4"
  4484 CA91 00				.byte	$00
  4485 CA92 A8				.byte	$A8		;"H"
  4486 CA93 00				.byte	$00
  4487 CA94 A1				.byte	$A1		;"A"
  4488 CA95 00				.byte	$00
  4489 CA96 A2				.byte	$A2		;"B"
  4490 CA97 00 00 00			.byte	$00,$00,$00
  4491
  4492 				;	Second Row ("1 2 3 4 5 6 7 8 9 0 < >")
  4493
  4494 CA9A 5B				.byte	$5B
  4495 CA9B 00				.byte	$00
  4496 CA9C 11				.byte	$11		;"1"
  4497 CA9D 00				.byte	$00
  4498 CA9E 12				.byte	$12		;"2"
  4499 CA9F 00				.byte	$00
  4500 CAA0 13				.byte	$13		;"3"
  4501 CAA1 00				.byte	$00
  4502 CAA2 14				.byte	$14		;"4"
  4503 CAA3 00				.byte	$00
  4504 CAA4 15				.byte	$15		;"5"
  4505 CAA5 00				.byte	$00
  4506 CAA6 16				.byte	$16		;"6"
  4507 CAA7 00				.byte	$00
  4508 CAA8 17				.byte	$17		;"7"
  4509 CAA9 00				.byte	$00
  4510 CAAA 18				.byte	$18		;"8"
  4511 CAAB 00				.byte	$00
  4512 CAAC 19				.byte	$19		;"9"
  4513 CAAD 00				.byte	$00
  4514 CAAE 10				.byte	$10		;"0"
  4515 CAAF 00				.byte	$00
  4516 CAB0 1C				.byte	$1C		;"<"
  4517 CAB1 00				.byte	$00
  4518 CAB2 1E				.byte	$1E		;">"
  4519 CAB3 00				.byte	$00
  4520 CAB4 A2				.byte	$A2		;"B"
  4521 CAB5 80				.byte	$80
  4522 CAB6 B3				.byte	$B3		;"S"
  4523 CAB7 00 00 00			.byte	$00,$00,$00
  4524
  4525 				;	Third Row ("Q W E R T Y U I O P - =")
  4526
  4527 CABA FF				.byte	$FF
  4528 CABB FF				.byte	$FF
  4529 CABC 00				.byte	$00
  4530 CABD 31				.byte	$31		;"Q"
  4531 CABE 00				.byte	$00
  4532 CABF 37				.byte	$37		;"W"
  4533 CAC0 00				.byte	$00
  4534 CAC1 25				.byte	$25		;"E"
  4535 CAC2 00				.byte	$00
  4536 CAC3 32				.byte	$32		;"R"
  4537 CAC4 00				.byte	$00
  4538 CAC5 34				.byte	$34		;"T"
  4539 CAC6 00				.byte	$00
  4540 CAC7 39				.byte	$39		;"Y"
  4541 CAC8 00				.byte	$00
  4542 CAC9 35				.byte	$35		;"U"
  4543 CACA 00				.byte	$00
  4544 CACB 29				.byte	$29		;"I"
  4545 CACC 00				.byte	$00
  4546 CACD 2F				.byte	$2F		;"O"
  4547 CACE 00				.byte	$00
  4548 CACF 30				.byte	$30		;"P"
  4549 CAD0 00				.byte	$00
  4550 CAD1 0D				.byte	$0D		;"-"
  4551 CAD2 00				.byte	$00
  4552 CAD3 1D				.byte	$1D		;"="
  4553 CAD4 00				.byte	$00
  4554 CAD5 B2				.byte	$B2		;"R"
  4555 CAD6 B4				.byte	$B4		;"T"
  4556 CAD7 00 00 00			.byte	$00,$00,$00
  4557
  4558 				;	Fourth Row ("A S D F G H J K L ; + *")
  4559
  4560 CADA 80				.byte	$80
  4561 CADB DC				.byte	$DC
  4562 CADC 80				.byte	$80
  4563 CADD 00				.byte	$00
  4564 CADE 21				.byte	$21		;"A"
  4565 CADF 00				.byte	$00
  4566 CAE0 33				.byte	$33		;"S"
  4567 CAE1 00				.byte	$00
  4568 CAE2 24				.byte	$24		;"D"
  4569 CAE3 00				.byte	$00
  4570 CAE4 26				.byte	$26		;"F"
  4571 CAE5 00				.byte	$00
  4572 CAE6 27				.byte	$27		;"G"
  4573 CAE7 00				.byte	$00
  4574 CAE8 28				.byte	$28		;"H"
  4575 CAE9 00				.byte	$00
  4576 CAEA 2A				.byte	$2A		;"J"
  4577 CAEB 00				.byte	$00
  4578 CAEC 2B				.byte	$2B		;"K"
  4579 CAED 00				.byte	$00
  4580 CAEE 2C				.byte	$2C		;"L"
  4581 CAEF 00				.byte	$00
  4582 CAF0 1B				.byte	$1B		;";"
  4583 CAF1 00				.byte	$00
  4584 CAF2 0B				.byte	$0B		;"+"
  4585 CAF3 00				.byte	$00
  4586 CAF4 0A				.byte	$0A		;"*"
  4587 CAF5 00				.byte	$00
  4588 CAF6 A3				.byte	$A3		;"C"
  4589 CAF7 00 00 00			.byte	$00,$00,$00
  4590
  4591 				;	Fifth Row ("Z X C V B N M , . /")
  4592
  4593 CAFA 80				.byte	$80
  4594 CAFB B3				.byte	$B3		;"S"
  4595 CAFC A8				.byte	$A8		;"H"
  4596 CAFD 80				.byte	$80
  4597 CAFE 00				.byte	$00
  4598 CAFF 3A				.byte	$3A		;"Z"
  4599 CB00 00				.byte	$00
  4600 CB01 38				.byte	$38		;"X"
  4601 CB02 00				.byte	$00
  4602 CB03 23				.byte	$23		;"C"
  4603 CB04 00				.byte	$00
  4604 CB05 36				.byte	$36		;"V"
  4605 CB06 00				.byte	$00
  4606 CB07 22				.byte	$22		;"B"
  4607 CB08 00				.byte	$00
  4608 CB09 2E				.byte	$2E		;"N"
  4609 CB0A 00				.byte	$00
  4610 CB0B 2D				.byte	$2D		;"M"
  4611 CB0C 00				.byte	$00
  4612 CB0D 0C				.byte	$0C		;","
  4613 CB0E 00				.byte	$00
  4614 CB0F 0E				.byte	$0E		;"."
  4615 CB10 00				.byte	$00
  4616 CB11 0F				.byte	$0F		;"/"
  4617 CB12 00				.byte	$00
  4618 CB13 80				.byte	$80
  4619 CB14 B3				.byte	$B3		;"S"
  4620 CB15 A8				.byte	$A8		;"H"
  4621 CB16 80				.byte	$80
  4622 CB17 00 00 00			.byte	$00,$00,$00
  4623
  4624 				;	Sixth Row (Space Bar)
  4625
  4626 CB1A 00 00 00 00 00		.byte	$00,$00,$00,$00,$00
  4627 CB1F 80				.byte	$80
  4628 CB20 B3				.byte	$B3		;"S"
  4629 CB21 80				.byte	$80
  4630 CB22 B0				.byte	$B0		;"P"
  4631 CB23 80				.byte	$80
  4632 CB24 A1				.byte	$A1		;"A"
  4633 CB25 80				.byte	$80
  4634 CB26 A3				.byte	$A3		;"C"
  4635 CB27 80				.byte	$80
  4636 CB28 A5				.byte	$A5		;"E"
  4637 CB29 80				.byte	$80
  4638 CB2A 80				.byte	$80
  4639 CB2B 80				.byte	$80
  4640 CB2C A2				.byte	$A2		;"B"
  4641 CB2D 80				.byte	$80
  4642 CB2E A1				.byte	$A1		;"A"
  4643 CB2F 80				.byte	$80
  4644 CB30 B2				.byte	$B2		;"R"
  4645 CB31 80				.byte	$80
  4646
  4647 = 00A8			TXT7L	=	*-TXT7	;length
  4648 					;SPACE	4,10
  4649 				;	TXT3 - "S P A C E   B A R" Text
  4650
  4651
  4652 CB32 00			TXT3	.byte	$00
  4653 CB33 33				.byte	$33		;"S"
  4654 CB34 00				.byte	$00
  4655 CB35 30				.byte	$30		;"P"
  4656 CB36 00				.byte	$00
  4657 CB37 21				.byte	$21		;"A"
  4658 CB38 00				.byte	$00
  4659 CB39 23				.byte	$23		;"C"
  4660 CB3A 00				.byte	$00
  4661 CB3B 25				.byte	$25		;"E"
  4662 CB3C 00				.byte	$00
  4663 CB3D 00				.byte	$00
  4664 CB3E 00				.byte	$00
  4665 CB3F 22				.byte	$22		;"B"
  4666 CB40 00				.byte	$00
  4667 CB41 21				.byte	$21		;"A"
  4668 CB42 00				.byte	$00
  4669 CB43 32				.byte	$32		;"R"
  4670 CB44 00				.byte	$00
  4671
  4672 = 0013			TXT3L	=	*-TXT3	;length
  4673 					;SPACE	4,10
  4674 				;	TXT4 - "SH" Text
  4675
  4676
  4677 CB45 00			TXT4	.byte	$00
  4678 CB46 33 28			.byte	$33,$28		;"SH"
  4679 CB48 00				.byte	$00
  4680
  4681 = 0004			TXT4L	=	*-TXT4	;length
  4682 					;SPACE	4,10
  4683 				;	TXT5 - "SH" Text
  4684
  4685
  4686 = CB45			TXT5	=	TXT4
  4687
  4688 = 0004			TXT5L	=	TXT4L	;length
  4689 					;SPACE	4,10
  4690 				;	TXT6 - "B S" Text
  4691
  4692
  4693 CB49 22			TXT6	.byte	$22	;"B"
  4694 CB4A 00				.byte	$00
  4695 CB4B 33				.byte	$33	;"S"
  4696
  4697 = 0003			TXT6L	=	*-TXT6	;length
  4698 					;SPACE	4,10
  4699 				;	TXT8 - Control Key
  4700
  4701
  4702 CB4C 00			TXT8	.byte	$00
  4703 CB4D 5C				.byte	$5C
  4704 CB4E 00				.byte	$00
  4705
  4706 = 0003			TXT8L	=	*-TXT8	;length
  4707 					;SPACE	4,10
  4708 				;	TXT9 - "VOICE #" Text
  4709
  4710
  4711 CB4F 36 2F 29 23 25	TXT9	.byte	$36,$2F,$29,$23,$25	;"VOICE"
  4712 CB54 00				.byte	$00
  4713 CB55 03				.byte	$03			;"#"
  4714
  4715 = 0007			TXT9L	=	*-TXT9	;length
  4716 				;	;SUBTTL	'Peripheral Handler Loading Facility, Part 2'
  4717 					;SPACE	4,10
  4718 				;	CLT - Checksum Linkage Table
  4719 				*
  4720 				*	ENTRY	JSR	CLT
  4721 				*		ZCHAIN = ZCHAIN+1 = address of linkage tabl:
  4722 				*
  4723 				*	EXIT
  4724 				*		A = checksum of linkage table
  4725 				*
  4726 				*	CHANGES
  4727 				*		Y
  4728 				*
  4729 				*	CALLS
  4730 				*		-none-
  4731 				*
  4732 				*	MODS
  4733 				*		R. S. Scheiman	04/01/82
  4734 				*		1. Bring closer to Coding Standard (object unchanged).
  4735 				*		   R. K. Nordin	11/01/83
  4736
  4737
  4738 = CB56			CLT	=	*		;entry
  4739
  4740 CB56 A0 11			LDY	#17		;offset to last byte to sum
  4741 CB58 A9 00			LDA	#0		;initial sum
  4742 CB5A 18				CLC
  4743
  4744 CB5B 71 4A		CLT1	ADC	(ZCHAIN),Y	;add byte
  4745 CB5D 88				DEY
  4746 CB5E 10 FB			BPL	CLT1		;if not done
  4747
  4748 CB60 69 00			ADC	#0		;add final carry
  4749 CB62 49 FF			EOR	#$FF		;complement
  4750 CB64 60				RTS			;return
  4751 				;	;SUBTTL	'International Character Set'
  4752 					;SPACE	4,10
  4753 						
  4754 CB65				ORG	ICSORG
  4755 					;SPACE	4,10
  4756 				;	International Character Set
  4757
  4758
  4759 CC00 00 00 00 00 00 00 + 	.byte	$00,$00,$00,$00,$00,$00,$00,$00	;$00 - space
  4760 CC08 00 18 18 18 18 00 + 	.byte	$00,$18,$18,$18,$18,$00,$18,$00	;$01 - !
  4761 CC10 00 66 66 66 00 00 + 	.byte	$00,$66,$66,$66,$00,$00,$00,$00	;$02 - "
  4762 CC18 00 66 FF 66 66 FF + 	.byte	$00,$66,$FF,$66,$66,$FF,$66,$00	;$03 - #
  4763 CC20 18 3E 60 3C 06 7C + 	.byte	$18,$3E,$60,$3C,$06,$7C,$18,$00	;$04 - $
  4764 CC28 00 66 6C 18 30 66 + 	.byte	$00,$66,$6C,$18,$30,$66,$46,$00	;$05 - %
  4765 CC30 1C 36 1C 38 6F 66 + 	.byte	$1C,$36,$1C,$38,$6F,$66,$3B,$00	;$06 - &
  4766 CC38 00 18 18 18 00 00 + 	.byte	$00,$18,$18,$18,$00,$00,$00,$00	;$07 - '
  4767 CC40 00 0E 1C 18 18 1C + 	.byte	$00,$0E,$1C,$18,$18,$1C,$0E,$00	;$08 - (
  4768 CC48 00 70 38 18 18 38 + 	.byte	$00,$70,$38,$18,$18,$38,$70,$00	;$09 - )
  4769 CC50 00 66 3C FF 3C 66 + 	.byte	$00,$66,$3C,$FF,$3C,$66,$00,$00	;$0A - asterisk
  4770 CC58 00 18 18 7E 18 18 + 	.byte	$00,$18,$18,$7E,$18,$18,$00,$00	;$0B - plus
  4771 CC60 00 00 00 00 00 18 + 	.byte	$00,$00,$00,$00,$00,$18,$18,$30	;$0C - comma
  4772 CC68 00 00 00 7E 00 00 + 	.byte	$00,$00,$00,$7E,$00,$00,$00,$00	;$0D - minus
  4773 CC70 00 00 00 00 00 18 + 	.byte	$00,$00,$00,$00,$00,$18,$18,$00	;$0E - period
  4774 CC78 00 06 0C 18 30 60 + 	.byte	$00,$06,$0C,$18,$30,$60,$40,$00	;$0F - /
  4775
  4776 CC80 00 3C 66 6E 76 66 + 	.byte	$00,$3C,$66,$6E,$76,$66,$3C,$00	;$10 - 0
  4777 CC88 00 18 38 18 18 18 + 	.byte	$00,$18,$38,$18,$18,$18,$7E,$00	;$11 - 1
  4778 CC90 00 3C 66 0C 18 30 + 	.byte	$00,$3C,$66,$0C,$18,$30,$7E,$00	;$12 - 2
  4779 CC98 00 7E 0C 18 0C 66 + 	.byte	$00,$7E,$0C,$18,$0C,$66,$3C,$00	;$13 - 3
  4780 CCA0 00 0C 1C 3C 6C 7E + 	.byte	$00,$0C,$1C,$3C,$6C,$7E,$0C,$00	;$14 - 4
  4781 CCA8 00 7E 60 7C 06 66 + 	.byte	$00,$7E,$60,$7C,$06,$66,$3C,$00	;$15 - 5
  4782 CCB0 00 3C 60 7C 66 66 + 	.byte	$00,$3C,$60,$7C,$66,$66,$3C,$00	;$16 - 6
  4783 CCB8 00 7E 06 0C 18 30 + 	.byte	$00,$7E,$06,$0C,$18,$30,$30,$00	;$17 - 7
  4784 CCC0 00 3C 66 3C 66 66 + 	.byte	$00,$3C,$66,$3C,$66,$66,$3C,$00	;$18 - 8
  4785 CCC8 00 3C 66 3E 06 0C + 	.byte	$00,$3C,$66,$3E,$06,$0C,$38,$00	;$19 - 9
  4786 CCD0 00 00 18 18 00 18 + 	.byte	$00,$00,$18,$18,$00,$18,$18,$00	;$1A - colon
  4787 CCD8 00 00 18 18 00 18 + 	.byte	$00,$00,$18,$18,$00,$18,$18,$30	;$1B - semicolon
  4788 CCE0 06 0C 18 30 18 0C + 	.byte	$06,$0C,$18,$30,$18,$0C,$06,$00	;$1C - <
  4789 CCE8 00 00 7E 00 00 7E + 	.byte	$00,$00,$7E,$00,$00,$7E,$00,$00	;$1D - =
  4790 CCF0 60 30 18 0C 18 30 + 	.byte	$60,$30,$18,$0C,$18,$30,$60,$00	;$1E - >
  4791 CCF8 00 3C 66 0C 18 00 + 	.byte	$00,$3C,$66,$0C,$18,$00,$18,$00	;$1F - ?
  4792
  4793 CD00 00 3C 66 6E 6E 60 + 	.byte	$00,$3C,$66,$6E,$6E,$60,$3E,$00	;$20 - @
  4794 CD08 00 18 3C 66 66 7E + 	.byte	$00,$18,$3C,$66,$66,$7E,$66,$00	;$21 - A
  4795 CD10 00 7C 66 7C 66 66 + 	.byte	$00,$7C,$66,$7C,$66,$66,$7C,$00	;$22 - B
  4796 CD18 00 3C 66 60 60 66 + 	.byte	$00,$3C,$66,$60,$60,$66,$3C,$00	;$23 - C
  4797 CD20 00 78 6C 66 66 6C + 	.byte	$00,$78,$6C,$66,$66,$6C,$78,$00	;$24 - D
  4798 CD28 00 7E 60 7C 60 60 + 	.byte	$00,$7E,$60,$7C,$60,$60,$7E,$00	;$25 - E
  4799 CD30 00 7E 60 7C 60 60 + 	.byte	$00,$7E,$60,$7C,$60,$60,$60,$00	;$26 - F
  4800 CD38 00 3E 60 60 6E 66 + 	.byte	$00,$3E,$60,$60,$6E,$66,$3E,$00	;$27 - G
  4801 CD40 00 66 66 7E 66 66 + 	.byte	$00,$66,$66,$7E,$66,$66,$66,$00	;$28 - H
  4802 CD48 00 7E 18 18 18 18 + 	.byte	$00,$7E,$18,$18,$18,$18,$7E,$00	;$29 - I
  4803 CD50 00 06 06 06 06 66 + 	.byte	$00,$06,$06,$06,$06,$66,$3C,$00	;$2A - J
  4804 CD58 00 66 6C 78 78 6C + 	.byte	$00,$66,$6C,$78,$78,$6C,$66,$00	;$2B - K
  4805 CD60 00 60 60 60 60 60 + 	.byte	$00,$60,$60,$60,$60,$60,$7E,$00	;$2C - L
  4806 CD68 00 63 77 7F 6B 63 + 	.byte	$00,$63,$77,$7F,$6B,$63,$63,$00	;$2D - M
  4807 CD70 00 66 76 7E 7E 6E + 	.byte	$00,$66,$76,$7E,$7E,$6E,$66,$00	;$2E - N
  4808 CD78 00 3C 66 66 66 66 + 	.byte	$00,$3C,$66,$66,$66,$66,$3C,$00	;$2F - O
  4809
  4810 CD80 00 7C 66 66 7C 60 + 	.byte	$00,$7C,$66,$66,$7C,$60,$60,$00	;$30 - P
  4811 CD88 00 3C 66 66 66 6C + 	.byte	$00,$3C,$66,$66,$66,$6C,$36,$00	;$31 - Q
  4812 CD90 00 7C 66 66 7C 6C + 	.byte	$00,$7C,$66,$66,$7C,$6C,$66,$00	;$32 - R
  4813 CD98 00 3C 60 3C 06 06 + 	.byte	$00,$3C,$60,$3C,$06,$06,$3C,$00	;$33 - S
  4814 CDA0 00 7E 18 18 18 18 + 	.byte	$00,$7E,$18,$18,$18,$18,$18,$00	;$34 - T
  4815 CDA8 00 66 66 66 66 66 + 	.byte	$00,$66,$66,$66,$66,$66,$7E,$00	;$35 - U
  4816 CDB0 00 66 66 66 66 3C + 	.byte	$00,$66,$66,$66,$66,$3C,$18,$00	;$36 - V
  4817 CDB8 00 63 63 6B 7F 77 + 	.byte	$00,$63,$63,$6B,$7F,$77,$63,$00	;$37 - W
  4818 CDC0 00 66 66 3C 3C 66 + 	.byte	$00,$66,$66,$3C,$3C,$66,$66,$00	;$38 - X
  4819 CDC8 00 66 66 3C 18 18 + 	.byte	$00,$66,$66,$3C,$18,$18,$18,$00	;$39 - Y
  4820 CDD0 00 7E 0C 18 30 60 + 	.byte	$00,$7E,$0C,$18,$30,$60,$7E,$00	;$3A - Z
  4821 CDD8 00 1E 18 18 18 18 + 	.byte	$00,$1E,$18,$18,$18,$18,$1E,$00	;$3B - [
  4822 CDE0 00 40 60 30 18 0C + 	.byte	$00,$40,$60,$30,$18,$0C,$06,$00	;$3C - \
  4823 CDE8 00 78 18 18 18 18 + 	.byte	$00,$78,$18,$18,$18,$18,$78,$00	;$3D - ]
  4824 CDF0 00 08 1C 36 63 00 + 	.byte	$00,$08,$1C,$36,$63,$00,$00,$00	;$3E - ^
  4825 CDF8 00 00 00 00 00 00 + 	.byte	$00,$00,$00,$00,$00,$00,$FF,$00	;$3F - underline
  4826
  4827 CE00 0C 18 3C 06 3E 66 + 	.byte	$0C,$18,$3C,$06,$3E,$66,$3E,$00	;$40 - acute accent a
  4828 CE08 30 18 00 66 66 66 + 	.byte	$30,$18,$00,$66,$66,$66,$3E,$00	;$41 - acute accent u
  4829 CE10 36 6C 00 76 76 7E + 	.byte	$36,$6C,$00,$76,$76,$7E,$6E,$00	;$42 - tilde N
  4830 CE18 0C 18 7E 60 7C 60 + 	.byte	$0C,$18,$7E,$60,$7C,$60,$7E,$00	;$43 - acute accent E
  4831 CE20 00 00 3C 60 60 3C + 	.byte	$00,$00,$3C,$60,$60,$3C,$18,$30	;$44 - cedilla c
  4832 CE28 3C 66 00 3C 66 66 + 	.byte	$3C,$66,$00,$3C,$66,$66,$3C,$00	;$45 - circumflex o
  4833 CE30 30 18 00 3C 66 66 + 	.byte	$30,$18,$00,$3C,$66,$66,$3C,$00	;$46 - grave accent o
  4834 CE38 30 18 00 38 18 18 + 	.byte	$30,$18,$00,$38,$18,$18,$3C,$00	;$47 - grave accent i
  4835 CE40 1C 30 30 78 30 30 + 	.byte	$1C,$30,$30,$78,$30,$30,$7E,$00	;$48 - U.K. currency
  4836 CE48 00 66 00 38 18 18 + 	.byte	$00,$66,$00,$38,$18,$18,$3C,$00	;$49 - diaeresis i
  4837 CE50 00 66 00 66 66 66 + 	.byte	$00,$66,$00,$66,$66,$66,$3E,$00	;$4A - umlaut u
  4838 CE58 36 00 3C 06 3E 66 + 	.byte	$36,$00,$3C,$06,$3E,$66,$3E,$00	;$4B - umlaut a
  4839 CE60 66 00 3C 66 66 66 + 	.byte	$66,$00,$3C,$66,$66,$66,$3C,$00	;$4C - umlaut O
  4840 CE68 0C 18 00 66 66 66 + 	.byte	$0C,$18,$00,$66,$66,$66,$3E,$00	;$4D - grave accent u
  4841 CE70 0C 18 00 3C 66 66 + 	.byte	$0C,$18,$00,$3C,$66,$66,$3C,$00	;$4E - acute accent o
  4842 CE78 00 66 00 3C 66 66 + 	.byte	$00,$66,$00,$3C,$66,$66,$3C,$00	;$4F - umlaut o
  4843
  4844 CE80 66 00 66 66 66 66 + 	.byte	$66,$00,$66,$66,$66,$66,$7E,$00	;$50 - umlaut U
  4845 CE88 3C 66 1C 06 3E 66 + 	.byte	$3C,$66,$1C,$06,$3E,$66,$3E,$00	;$51 - circumflex a
  4846 CE90 3C 66 00 66 66 66 + 	.byte	$3C,$66,$00,$66,$66,$66,$3E,$00	;$52 - circumflex u
  4847 CE98 3C 66 00 38 18 18 + 	.byte	$3C,$66,$00,$38,$18,$18,$3C,$00	;$53 - circumflex i
  4848 CEA0 0C 18 3C 66 7E 60 + 	.byte	$0C,$18,$3C,$66,$7E,$60,$3C,$00	;$54 - acute accent e
  4849 CEA8 30 18 3C 66 7E 60 + 	.byte	$30,$18,$3C,$66,$7E,$60,$3C,$00	;$55 - grave accent e
  4850 CEB0 36 6C 00 7C 66 66 + 	.byte	$36,$6C,$00,$7C,$66,$66,$66,$00	;$56 - tilde n
  4851 CEB8 3C C3 3C 66 7E 60 + 	.byte	$3C,$C3,$3C,$66,$7E,$60,$3C,$00	;$57 - circumflex e
  4852 CEC0 18 00 3C 06 3E 66 + 	.byte	$18,$00,$3C,$06,$3E,$66,$3E,$00	;$58 - ring a
  4853 CEC8 30 18 3C 06 3E 66 + 	.byte	$30,$18,$3C,$06,$3E,$66,$3E,$00	;$59 - grave accent a
  4854 CED0 18 00 18 3C 66 7E + 	.byte	$18,$00,$18,$3C,$66,$7E,$66,$00	;$5A - ring A
  4855 CED8 78 60 78 60 7E 18 + 	.byte	$78,$60,$78,$60,$7E,$18,$1E,$00	;$5B - display escape
  4856 CEE0 00 18 3C 7E 18 18 + 	.byte	$00,$18,$3C,$7E,$18,$18,$18,$00	;$5C - up arrow
  4857 CEE8 00 18 18 18 7E 3C + 	.byte	$00,$18,$18,$18,$7E,$3C,$18,$00	;$5D - down arrow
  4858 CEF0 00 18 30 7E 30 18 + 	.byte	$00,$18,$30,$7E,$30,$18,$00,$00	;$5E - left arrow
  4859 CEF8 00 18 0C 7E 0C 18 + 	.byte	$00,$18,$0C,$7E,$0C,$18,$00,$00	;$5F - right arrow
  4860
  4861 CF00 18 00 18 18 18 18 + 	.byte	$18,$00,$18,$18,$18,$18,$18,$00	;$60 - Spanish !
  4862 CF08 00 00 3C 06 3E 66 + 	.byte	$00,$00,$3C,$06,$3E,$66,$3E,$00	;$61 - a
  4863 CF10 00 60 60 7C 66 66 + 	.byte	$00,$60,$60,$7C,$66,$66,$7C,$00	;$62 - b
  4864 CF18 00 00 3C 60 60 60 + 	.byte	$00,$00,$3C,$60,$60,$60,$3C,$00	;$63 - c
  4865 CF20 00 06 06 3E 66 66 + 	.byte	$00,$06,$06,$3E,$66,$66,$3E,$00	;$64 - d
  4866 CF28 00 00 3C 66 7E 60 + 	.byte	$00,$00,$3C,$66,$7E,$60,$3C,$00	;$65 - e
  4867 CF30 00 0E 18 3E 18 18 + 	.byte	$00,$0E,$18,$3E,$18,$18,$18,$00	;$66 - f
  4868 CF38 00 00 3E 66 66 3E + 	.byte	$00,$00,$3E,$66,$66,$3E,$06,$7C	;$67 - g
  4869 CF40 00 60 60 7C 66 66 + 	.byte	$00,$60,$60,$7C,$66,$66,$66,$00	;$68 - h
  4870 CF48 00 18 00 38 18 18 + 	.byte	$00,$18,$00,$38,$18,$18,$3C,$00	;$69 - i
  4871 CF50 00 06 00 06 06 06 + 	.byte	$00,$06,$00,$06,$06,$06,$06,$3C	;$6A - j
  4872 CF58 00 60 60 6C 78 6C + 	.byte	$00,$60,$60,$6C,$78,$6C,$66,$00	;$6B - k
  4873 CF60 00 38 18 18 18 18 + 	.byte	$00,$38,$18,$18,$18,$18,$3C,$00	;$6C - l
  4874 CF68 00 00 66 7F 7F 6B + 	.byte	$00,$00,$66,$7F,$7F,$6B,$63,$00	;$6D - m
  4875 CF70 00 00 7C 66 66 66 + 	.byte	$00,$00,$7C,$66,$66,$66,$66,$00	;$6E - n
  4876 CF78 00 00 3C 66 66 66 + 	.byte	$00,$00,$3C,$66,$66,$66,$3C,$00	;$6F - o
  4877
  4878 CF80 00 00 7C 66 66 7C + 	.byte	$00,$00,$7C,$66,$66,$7C,$60,$60	;$70 - p
  4879 CF88 00 00 3E 66 66 3E + 	.byte	$00,$00,$3E,$66,$66,$3E,$06,$06	;$71 - q
  4880 CF90 00 00 7C 66 60 60 + 	.byte	$00,$00,$7C,$66,$60,$60,$60,$00	;$72 - r
  4881 CF98 00 00 3E 60 3C 06 + 	.byte	$00,$00,$3E,$60,$3C,$06,$7C,$00	;$73 - s
  4882 CFA0 00 18 7E 18 18 18 + 	.byte	$00,$18,$7E,$18,$18,$18,$0E,$00	;$74 - t
  4883 CFA8 00 00 66 66 66 66 + 	.byte	$00,$00,$66,$66,$66,$66,$3E,$00	;$75 - u
  4884 CFB0 00 00 66 66 66 3C + 	.byte	$00,$00,$66,$66,$66,$3C,$18,$00	;$76 - v
  4885 CFB8 00 00 63 6B 7F 3E + 	.byte	$00,$00,$63,$6B,$7F,$3E,$36,$00	;$77 - w
  4886 CFC0 00 00 66 3C 18 3C + 	.byte	$00,$00,$66,$3C,$18,$3C,$66,$00	;$78 - x
  4887 CFC8 00 00 66 66 66 3E + 	.byte	$00,$00,$66,$66,$66,$3E,$0C,$78	;$79 - y
  4888 CFD0 00 00 7E 0C 18 30 + 	.byte	$00,$00,$7E,$0C,$18,$30,$7E,$00	;$7A - z
  4889 CFD8 66 66 18 3C 66 7E + 	.byte	$66,$66,$18,$3C,$66,$7E,$66,$00	;$7B - umlaut A
  4890 CFE0 18 18 18 18 18 18 + 	.byte	$18,$18,$18,$18,$18,$18,$18,$18	;$7C - |
  4891 CFE8 00 7E 78 7C 6E 66 + 	.byte	$00,$7E,$78,$7C,$6E,$66,$06,$00	;$7D - display clear
  4892 CFF0 08 18 38 78 38 18 + 	.byte	$08,$18,$38,$78,$38,$18,$08,$00	;$7E - display backspace
  4893 CFF8 10 18 1C 1E 1C 18 + 	.byte	$10,$18,$1C,$1E,$1C,$18,$10,$00	;$7F - display tab
  4894 				;	;SUBTTL	'Self-test, Part 3'
  4895 					;SPACE	4,10
  4896
  4897 				;	ORG	$D000
  4898 				;	LOC	$5000	;$D000 - $D7FF mapped to $5000 - $57FF
  4899 D000				ORG $5000, $D000 ; MADS version of LOC
  4900
  4901 					;SPACE	4,10
  4902 				;	STH - Self-test Hardware
  4903 				*
  4904 				*	ENTRY	JSR	STH
  4905 				*
  4906 				*	NOTES
  4907 				*		Problem: this is superfluous; SLFTSV could vector to
  4908 				*		EST.
  4909 				*
  4910 				*	MODS
  4911 				*		M. W. Colburn	10/26/82
  4912 				*		1. Bring closer to Coding Standard (object unchanged).
  4913 				*		   R. K. Nordin	11/01/83
  4914
  4915
  4916 = 5000			STH	=	*	;entry
  4917 5000 4C 09 50			JMP	EST	;execute self-test
  4918 					;SPACE	4,10
  4919 				;	EMS - Execute Memory Self-test
  4920 				*
  4921 				*	ENTRY	JSR	EMS
  4922 				*
  4923 				*	MODS
  4924 				*		M. W. Colburn	10/26/82
  4925 				*		1. Bring closer to Coding Standard (object unchanged).
  4926 				*		   R. K. Nordin	11/01/83
  4927
  4928
  4929 = 5003			EMS	=	*	;entry
  4930 5003 20 86 50			JSR	IST	;initialize self-test
  4931 5006 4C 91 52			JMP	STM	;self-test memory
  4932 					;SPACE	4,10
  4933 				;	EST - Execute Self-test
  4934 				*
  4935 				*	ENTRY	JSR	EST
  4936 				*
  4937 				*	MODS
  4938 				*		M. W. Colburn	10/26/82
  4939 				*		1. Bring closer to Coding Standard (object unchanged).
  4940 				*		   R. K. Nordin	11/01/83
  4941
  4942
  4943 = 5009			EST	=	*	;entry
  4944 5009 20 86 50			JSR	IST	;initialize self-test
  4945 				;	JMP	SEL	;self-test
  4946 					;SPACE	4,10
  4947 				;	SEL - Self-test
  4948 				*
  4949 				*	ENTRY	JSR	SEL
  4950 				*
  4951 				*	MODS
  4952 				*		M. W. Colburn	10/26/82
  4953 				*		1. Bring closer to Coding Standard (object unchanged).
  4954 				*		   R. K. Nordin	11/01/83
  4955
  4956
  4957 = 500C			SEL	=	*		;entry
  4958
  4959 				;	Initialize.
  4960
  4961 500C A9 00			LDA	#0
  4962 500E 85 80			STA	STTIME		;clear main screen timeout timer
  4963 5010 85 81			STA	STTIME+1
  4964 5012 85 82			STA	STAUT		;clear auto-mode flag
  4965 5014 8D 08 D2			STA	AUDCTL		;initialize audio control register
  4966 5017 A9 03			LDA	#$03		;initialize POKEY
  4967 5019 8D 0F D2			STA	SKCTL		;serial port control
  4968 501C 20 10 55			JSR	SAS		;silence all sounds
  4969 501F A9 40			LDA	#$40		;disable DLI
  4970 5021 8D 0E D4			STA	NMIEN		;NMI enable
  4971 5024 A2 00			LDX	#0		;main screen colors
  4972 5026 20 73 57			JSR	SUC		;set up colors
  4973 5029 A2 3A			LDX	#<DISL1	;display list for main screen
  4974 502B A0 51			LDY	#>DISL1
  4975 502D 20 9E 50			JSR	SDL		;set up display list
  4976 5030 A9 D0			LDA	#<PMD	;process main screen DLI routine
  4977 5032 8D 00 02			STA	VDSLST		;display list NMI address
  4978 5035 A9 50			LDA	#>PMD
  4979 5037 8D 01 02			STA	VDSLST+1
  4980 503A A2 0C			LDX	#3*4		;main screen bold lines
  4981 503C A9 AA			LDA	#$AA		;color 1
  4982 503E 20 2A 57			JSR	SVR		;set value in range
  4983
  4984 				;	Wait for all screen DLI's to clear and for VBLANK.
  4985
  4986 5041 A2 00			LDX	#0
  4987
  4988 5043 8E 0A D4		SEL1	STX	WSYNC		;wait for HBLANK synchronization
  4989 5046 E8				INX
  4990 5047 D0 FA			BNE	SEL1		;if not done waiting
  4991
  4992 				;	Wait until beam close to top (main screen DLI near).
  4993
  4994 5049 AD 0B D4		SEL2	LDA	VCOUNT
  4995 504C C9 18			CMP	#24
  4996 504E B0 F9			BCS	SEL2		;if not done waiting
  4997
  4998 				;	Preset for self-test type determination.
  4999
  5000 5050 A9 10			LDA	#$10		;initially select memory test
  5001 5052 85 87			STA	STPASS		;pass indicator
  5002 5054 A9 C0			LDA	#$C0		;enable DLI
  5003 5056 8D 0E D4			STA	NMIEN
  5004
  5005 				;	Determine type of self-test.
  5006
  5007 5059 AD 1F D0		SEL3	LDA	CONSOL		;console switches
  5008 505C 29 01			AND	#$01		;START key indicator
  5009 505E D0 F9			BNE	SEL3		;if START key not pressed
  5010
  5011 5060 A9 FF			LDA	#$FF		;clear character
  5012 5062 8D FC 02			STA	CH
  5013
  5014 5065 A5 86			LDA	STSEL		;selection
  5015 5067 29 0F			AND	#$0F		;selection
  5016 5069 C9 01			CMP	#$01		;memory test indicator
  5017 506B F0 10			BEQ	SEL5		;if memory test
  5018
  5019 506D C9 02			CMP	#$02
  5020 506F F0 0F			BEQ	SEL6		;if audio-visual test
  5021
  5022 5071 C9 04			CMP	#$04
  5023 5073 F0 0E			BEQ	SEL7		;if keyboard test
  5024
  5025 				;	Self-test all.
  5026
  5027 5075 A9 88		SEL4	LDA	#$88		;indicate all tests
  5028 5077 85 86			STA	STSEL		;selection
  5029 5079 A9 FF			LDA	#$FF		;auto-mode indicator
  5030 507B 85 82			STA	STAUT		;auto-mode flag
  5031
  5032 				;	Self-test memory.
  5033
  5034 507D 4C 91 52		SEL5	JMP	STM		;self-test memory
  5035
  5036 				;	Self-test audio-visual.
  5037
  5038 5080 4C 57 55		SEL6	JMP	STV		;self-test audio-visual
  5039
  5040 				;	Self-test keyboard.
  5041
  5042 5083 4C 50 54		SEL7	JMP	STK		;self-test keyboard
  5043 					;SPACE	4,10
  5044 				;	IST - Initialize Self-test
  5045 				*
  5046 				*	ENTRY	JSR	IST
  5047 				*
  5048 				*	MODS
  5049 				*		M. W. Colburn	10/26/82
  5050 				*		1. Bring closer to Coding Standard (object unchanged).
  5051 				*		   R. K. Nordin	11/01/83
  5052
  5053
  5054 = 5086			IST	=	*	;entry
  5055 5086 A9 11			LDA	#$11	;indicate memory test
  5056 5088 85 86			STA	STSEL	;selection
  5057 508A A9 21			LDA	#$21
  5058 508C 8D 2F 02			STA	SDMCTL	;select small size playfield
  5059 508F A9 C0			LDA	#$C0
  5060 5091 8D 0E D4			STA	NMIEN	;enable DLI
  5061 5094 A9 41			LDA	#$41
  5062 5096 85 83			STA	STJMP	;ANTIC jump instruction
  5063 5098 A9 FF			LDA	#$FF	;clear code indicator
  5064 509A 8D FC 02			STA	CH	;key code
  5065 509D 60				RTS		;return
  5066 					;SPACE	4,10
  5067 				;	SDL - Set Up Display List
  5068 				*
  5069 				*	ENTRY	JSR	SDL
  5070 				*
  5071 				*	MODS
  5072 				*		M. W. Colburn	10/26/82
  5073 				*		1. Bring closer to Coding Standard (object unchanged).
  5074 				*		   R. K. Nordin	11/01/83
  5075
  5076
  5077 = 509E			SDL	=	*	;entry
  5078
  5079 509E 85 8A			STA	STKST		;keyboard self-test flag
  5080 50A0 98				TYA
  5081 50A1 48				PHA			;save high address
  5082 50A2 8A				TXA
  5083 50A3 48				PHA			;save low address
  5084 50A4 A9 00			LDA	#0
  5085 50A6 8D 2F 02			STA	SDMCTL		;DMACTL (DMA control) shadow
  5086 50A9 8D DC 02			STA	HELPFG		;HELP key flag
  5087 50AC A9 DA			LDA	#<POD	;process DLI routine
  5088 50AE 8D 00 02			STA	VDSLST
  5089 50B1 A9 53			LDA	#>POD
  5090 50B3 8D 01 02			STA	VDSLST+1
  5091 50B6 A2 00			LDX	#0*4		;screen memory
  5092 50B8 8A				TXA			;value is 0
  5093 50B9 20 2A 57			JSR	SVR		;set value in range
  5094 50BC 68				PLA			;saved low address
  5095 50BD AA				TAX
  5096 50BE 68				PLA			;saved high address
  5097 50BF A8				TAY
  5098 50C0 8E 30 02			STX	SDLSTL		;low display list address
  5099 50C3 86 84			STX	STJMP+1		;low display list address
  5100 50C5 8C 31 02			STY	SDLSTH		;high display list address
  5101 50C8 84 85			STY	STJMP+2		;high display list address
  5102 50CA A9 21			LDA	#$21
  5103 50CC 8D 2F 02			STA	SDMCTL
  5104 50CF 60				RTS		;return
  5105 					;SPACE	4,10
  5106 				;	PMD - Process Main Screen DLI
  5107 				*
  5108 				*	1) .IF MAIN SCREEN IS ON FOR MORE than FIVE MINUTES
  5109 				*	THEN 'ALL TESTS' SELECTION IS SELECTED AND EXECUTED
  5110 				*	2) COLORS FOR CURRENTLY SELECTED CHOICE AND THE
  5111 				*	NON-SELECTED CHOICES ARE DISPLAYED ON FLY
  5112 				*	3) SELECTION PROCESS IS HANDLED
  5113 				*
  5114 				*	ENTRY	JMP	PMD
  5115 				*
  5116 				*	EXIT
  5117 				*		Exits via RTI
  5118 				*
  5119 				*	MODS
  5120 				*		M. W. Colburn	10/26/82
  5121 				*		1. Bring closer to Coding Standard (object unchanged).
  5122 				*		   R. K. Nordin	11/01/83
  5123
  5124
  5125 = 50D0			PMD	=	*	;entry
  5126
  5127 				;	Initialize.
  5128
  5129 50D0 48				PHA		;save A
  5130 50D1 8A				TXA
  5131 50D2 48				PHA		;save X
  5132
  5133 				;	Check for 4th time.
  5134
  5135 50D3 A2 7A		PMD1	LDX	#$7A	;assume non-selected color
  5136 50D5 A5 87			LDA	STPASS	;pass indicator
  5137 50D7 C9 01			CMP	#$01	;4th time indicator
  5138 50D9 F0 1F			BEQ	PMD3	;if 4th time
  5139
  5140 				;	Check for selection.
  5141
  5142 50DB 29 01			AND	#$01	;selection indicatorn
  5143 50DD F0 0A			BEQ	PMD2	;if selected
  5144
  5145 				;	Increment and check blink counter.
  5146
  5147 50DF E6 A2			INC	STBL	;increment blink counter
  5148 50E1 A5 A2			LDA	STBL	;blink counter
  5149 50E3 29 20			AND	#$20	;blink indicator
  5150 50E5 F0 02			BEQ	PMD2	;if not to blink
  5151
  5152 50E7 A2 2C			LDX	#$2C	;use selected color
  5153
  5154 				;	Set color.
  5155
  5156 50E9 8E 0A D4		PMD2	STX	WSYNC	;wait for HBLANK synchronization
  5157 50EC 8E 16 D0			STX	COLPF0	;playfield 0 color
  5158 50EF 18				CLC
  5159 50F0 66 87			ROR	STPASS	;advance pass indicator
  5160 50F2 A9 00			LDA	#0
  5161 50F4 85 4D			STA	ATRACT
  5162
  5163 				;	Exit.
  5164
  5165 50F6 68				PLA
  5166 50F7 AA				TAX		;restore X
  5167 50F8 68				PLA		;restore A
  5168 50F9 40				RTI		;return
  5169
  5170 				;	Check for SELECT previously pressed.
  5171
  5172 50FA A5 88		PMD3	LDA	STSPP	;SELECT previously pressed  flag
  5173 50FC D0 16			BNE	PMD4	;if SELECT previously pressed
  5174
  5175 				;	Check for SELECT pressed.
  5176
  5177 50FE AD 1F D0			LDA	CONSOL	;console switches
  5178 5101 29 02			AND	#$02	;SELECT key indicator
  5179 5103 D0 1A			BNE	PMD5	;if SELECT not pressed, exit
  5180
  5181 				;	Process SELECT pressed.
  5182
  5183 5105 A5 86			LDA	STSEL	;current selection
  5184 5107 2A				ROL
  5185 5108 26 86			ROL	STSEL	;next selection
  5186 510A A9 20			LDA	#$20	;blink indicator
  5187 510C 85 A2			STA	STBL	;blink counter
  5188 510E A9 FF			LDA	#$FF	;SELECT previously pressed indicator
  5189 5110 85 88			STA	STSPP	;SELECT previously pressed flag
  5190 5112 D0 0B			BNE	PMD5
  5191
  5192 				;	Process SELECT previously pressed.
  5193
  5194 5114 AD 1F D0		PMD4	LDA	CONSOL	;console switches
  5195 5117 29 02			AND	#$02	;SELECT key indicator
  5196 5119 F0 04			BEQ	PMD5	;if SELECT still pressed
  5197
  5198 511B A9 00			LDA	#0	;SELECT not previously pressed indicator
  5199 511D 85 88			STA	STSPP	;SELECT previously pressed flag
  5200
  5201 				;	???every 4th time???
  5202
  5203 511F A5 86		PMD5	LDA	STSEL	;selection
  5204 5121 29 0F			AND	#$0F
  5205 5123 09 10			ORA	#$10	;reset indicate memory test
  5206 5125 85 87			STA	STPASS	;pass indicator
  5207
  5208 				;	Advance main screen timer.
  5209
  5210 5127 E6 80			INC	STTIME
  5211 5129 D0 02			BNE	PMD6	;if low not zero
  5212
  5213 512B E6 81			INC	STTIME+1	
  5214
  5215 				;	Check main screen timer.
  5216
  5217 512D A5 81		PMD6	LDA	STTIME+1
  5218 512F C9 FA			CMP	#250	;main screen timeout
  5219 5131 D0 04			BNE	PMD7	;if main screen timed out
  5220
  5221 				;	Process main screen timeout.
  5222
  5223 5133 58				CLI
  5224 5134 4C 75 50			JMP	SEL4	;self-test all
  5225
  5226 				;	Continue.
  5227
  5228 5137 4C D3 50		PMD7	JMP	PMD1	;continue
  5229 					;SPACE	4,10
  5230 				;	DISL1 - Display List for Main Screen
  5231
  5232
  5233 513A 70 70 70 70 70	DISL1	.byte	$70,$70,$70,$70,$70
  5234 513F 47				.byte	$47
  5235 5140 61 51			.word	SMEM1
  5236 5142 70 70 70			.byte	$70,$70,$70
  5237 5145 4E				.byte	$4E
  5238 5146 00 30			.word	ST3000
  5239 5148 70				.byte	$70
  5240 5149 F0				.byte	$F0
  5241 514A C6				.byte	$C6
  5242 514B 71 51			.word	SMEM2
  5243 514D 70 86			.byte	$70,$86
  5244 514F 70 86			.byte	$70,$86
  5245 5151 70 06			.byte	$70,$06
  5246 5153 70 70			.byte	$70,$70
  5247 5155 4E				.byte	$4E
  5248 5156 00 30			.word	ST3000
  5249 5158 70 70 70			.byte	$70,$70,$70
  5250 515B 42				.byte	$42
  5251 515C B1 51			.word	SMEM3
  5252 515E 41				.byte	$41
  5253 515F 3A 51			.word	DISL1
  5254 					;SPACE	4,10
  5255 				;	SMEM1 - "SELF TEST" Text
  5256
  5257
  5258 5161 00 00 00 00		SMEM1	.byte	$00,$00,$00,$00
  5259 5165 33 25 2C 26			.byte	$33,$25,$2C,$26		;"SELF"
  5260 5169 00				.byte	$00
  5261 516A 34 25 33 34			.byte	$34,$25,$33,$34		;"TEST"
  5262 516E 00 00 00			.byte	$00,$00,$00
  5263 					;SPACE	4,10
  5264 				;	SMEM2 - "MEMORY AUDIO-VISUAL KEYBOARD ALL TESTS" Text
  5265
  5266
  5267 5171 00 00		SMEM2	.byte	$00,$00
  5268 5173 2D 25 2D 2F 32 39		.byte	$2D,$25,$2D,$2F,$32,$39			;"MEMORY"
  5269 5179 00 00 00 00 00		.byte	$00,$00,$00,$00,$00
  5270 517E 00 00 00 00 00		.byte	$00,$00,$00,$00,$00
  5271 5183 21 35 24 29 2F		.byte	$21,$35,$24,$29,$2F			;"AUDIO"
  5272 5188 0D				.byte	$0D					;"-"
  5273 5189 36 29 33 35 21 2C		.byte	$36,$29,$33,$35,$21,$2C			;"VISUAL"
  5274 518F 00 00 00 00			.byte	$00,$00,$00,$00
  5275 5193 2B 25 39 22 2F 21 + 	.byte	$2B,$25,$39,$22,$2F,$21,$32,$24		;"KEYBOARD"
  5276 519B 00 00 00 00 00 00 + 	.byte	$00,$00,$00,$00,$00,$00,$00,$00
  5277 51A3 21 2C 2C			.byte	$21,$2C,$2C				;"ALL"
  5278 51A6 00				.byte	$00
  5279 51A7 34 25 33 34 33		.byte	$34,$25,$33,$34,$33			;"TESTS"
  5280 51AC 00 00 00 00 00		.byte	$00,$00,$00,$00,$00
  5281 					;SPACE	4,10
  5282 				;	SMEM3 - "SELECT,START OR RESET" Text
  5283
  5284
  5285 51B1 00 00 00 00		SMEM3	.byte	$00,$00,$00,$00
  5286 51B5 42				.byte	$42
  5287 51B6 B3 A5 AC A5 A3 B4		.byte	$B3,$A5,$AC,$A5,$A3,$B4		;"SELECT"
  5288 51BC 56				.byte	$56
  5289 51BD 0C				.byte	$0C				;","
  5290 51BE 42				.byte	$42
  5291 51BF B3 B4 A1 B2 B4		.byte	$B3,$B4,$A1,$B2,$B4		;"START"
  5292 51C4 56				.byte	$56
  5293 51C5 2F 32			.byte	$2F,$32				;"OR"
  5294 51C7 42				.byte	$42
  5295 51C8 B2 A5 B3 A5 B4		.byte	$B2,$A5,$B3,$A5,$B4		;"RESET"
  5296 51CD 56				.byte	$56
  5297 51CE 00 00 00			.byte	$00,$00,$00
  5298 					;SPACE	4,10
  5299 				;	DISL2 - Display List for Memory Test
  5300
  5301
  5302 51D1 70 70 70		DISL2	.byte	$70,$70,$70
  5303 51D4 46				.byte	$46
  5304 51D5 00 30			.word	ST3000
  5305 51D7 70				.byte	$70
  5306 51D8 70 06			.byte	$70,$06
  5307 51DA 70 08			.byte	$70,$08
  5308 51DC 70				.byte	$70
  5309 51DD 70 06			.byte	$70,$06
  5310 51DF 70 08			.byte	$70,$08
  5311 51E1 70 08			.byte	$70,$08
  5312 51E3 70 08			.byte	$70,$08
  5313 51E5 70 08			.byte	$70,$08
  5314 51E7 70 70 70			.byte	$70,$70,$70
  5315 51EA 01				.byte	$01
  5316 51EB ED 51			.word	DISL3
  5317 					;SPACE	4,10
  5318 				;	DISL3 - Display List for Exit Text
  5319
  5320
  5321 51ED A0 40		DISL3	.byte	$A0,$40
  5322 51EF 42				.byte	$42
  5323 51F0 F5 51			.word	SMEM4
  5324 51F2 01				.byte	$01
  5325 51F3 83 00			.word	STJMP
  5326 					;SPACE	4,10
  5327 				;	SMEM4 - "RESET OR HELP TO EXIT" Text
  5328
  5329
  5330 51F5 00 00 00 00 00	SMEM4	.byte	$00,$00,$00,$00,$00
  5331 51FA 42				.byte	$42
  5332 51FB B2 A5 B3 A5 B4		.byte	$B2,$A5,$B3,$A5,$B4	;"RESET"
  5333 5200 56				.byte	$56
  5334 5201 2F 32			.byte	$2F,$32			;"OR"
  5335 5203 42				.byte	$42
  5336 5204 A8 A5 AC B0			.byte	$A8,$A5,$AC,$B0		;"HELP"
  5337 5208 56				.byte	$56
  5338 5209 34 2F			.byte	$34,$2F			;"TO"
  5339 520B 00				.byte	$00
  5340 520C 25 38 29 34			.byte	$25,$38,$29,$34		;"EXIT"
  5341 5210 00 00 00 00 00		.byte	$00,$00,$00,$00,$00
  5342 					;SPACE	4,10
  5343 				;	DISL4 - Display List for Keyboard Test
  5344
  5345
  5346 5215 70 70 70 70		DISL4	.byte	$70,$70,$70,$70
  5347 5219 46				.byte	$46
  5348 521A 00 30			.word	ST3000
  5349 521C 70 70 70			.byte	$70,$70,$70
  5350 521F 70 02			.byte	$70,$02
  5351 5221 70				.byte	$70
  5352 5222 70 02			.byte	$70,$02
  5353 5224 70 02			.byte	$70,$02
  5354 5226 70 02			.byte	$70,$02
  5355 5228 70 02			.byte	$70,$02
  5356 522A 70 02			.byte	$70,$02
  5357 522C 70 70			.byte	$70,$70
  5358 522E 01				.byte	$01
  5359 522F ED 51			.word	DISL3
  5360 					;SPACE	4,10
  5361 				;	DISL5 - Display List for Audio-visual Test
  5362
  5363
  5364 5231 70 70 70 70		DISL5	.byte	$70,$70,$70,$70
  5365 5235 46				.byte	$46
  5366 5236 71 52			.word	SMEM5
  5367 5238 70 06			.byte	$70,$06
  5368 523A 70 70			.byte	$70,$70
  5369 523C 4B				.byte	$4B
  5370 523D 00 31			.word	ST3100
  5371 523F 0B 0B 0B 0B 0B 0B + 	.byte	$0B,$0B,$0B,$0B,$0B,$0B,$0B,$0B
  5372 5247 0B 0B 0B 0B 0B 0B + 	.byte	$0B,$0B,$0B,$0B,$0B,$0B,$0B,$0B
  5373 524F 0B 0B 0B 0B 0B 0B + 	.byte	$0B,$0B,$0B,$0B,$0B,$0B,$0B,$0B
  5374 5257 0B 0B 0B 0B 0B 0B + 	.byte	$0B,$0B,$0B,$0B,$0B,$0B,$0B,$0B
  5375 525F 0B 0B 0B 0B 0B 0B + 	.byte	$0B,$0B,$0B,$0B,$0B,$0B,$0B,$0B
  5376 5267 0B 0B			.byte	$0B,$0B
  5377 5269 70				.byte	$70
  5378 526A 46				.byte	$46
  5379 526B 00 30			.word	ST3000
  5380 526D 70				.byte	$70
  5381 526E 01				.byte	$01
  5382 526F ED 51			.word	DISL3
  5383 					;SPACE	4,10
  5384 				;	SMEM5 - "AUDIO-VISUAL TEST" Text
  5385
  5386
  5387 5271 00 00		SMEM5	.byte	$00,$00
  5388 5273 21 35 24 29 2F		.byte	$21,$35,$24,$29,$2F		;"AUDIO"
  5389 5278 0D				.byte	$0D				;"-"
  5390 5279 36 29 33 35 21 2C		.byte	$36,$29,$33,$35,$21,$2C		;"VISUAL"
  5391 527F 00 00 00 00			.byte	$00,$00,$00,$00
  5392 5283 00 00 00 00			.byte	$00,$00,$00,$00
  5393 5287 34 25 33 34			.byte	$34,$25,$33,$34			;"TEST"
  5394 528B 00 00 00 00 00 00		.byte	$00,$00,$00,$00,$00,$00
  5395 				;	;SPACE	4,10
  5396 				;	STM - Self-test Memory
  5397 				*
  5398 				*	STM verifies ROM and RAM by verifying the ROM checksums and
  5399 				*	writing and reading all possible values to each byte of RAM.
  5400 				*
  5401 				*	ENTRY	JSR	STM
  5402 				*
  5403 				*	NOTES
  5404 				*		Problem: searches beyond end of TMNT.
  5405 				*
  5406 				*	MODS
  5407 				*		M. W. Colburn	10/26/82
  5408 				*		1. Bring closer to Coding Standard (object unchanged).
  5409 				*		   R. K. Nordin	11/01/83
  5410
  5411
  5412 = 5291			STM	=	*		;entry
  5413
  5414 				;	Initialize.
  5415
  5416 5291 A2 D1			LDX	#<DISL2	;memory test display list
  5417 5293 A0 51			LDY	#>DISL2
  5418 5295 A9 00			LDA	#0		;indicate not keyboard self-test
  5419 5297 20 9E 50			JSR	SDL		;set up display list
  5420 529A A2 01			LDX	#1		;memory test colors
  5421 529C 20 73 57			JSR	SUC		;set up colors
  5422 529F A2 00			LDX	#0		;offset to "MEMORY TEST   ROM" test
  5423 52A1 20 59 57			JSR	SSM		;set screen memory
  5424 52A4 A2 01			LDX	#1		;offset to "RAM" text
  5425 52A6 20 59 57			JSR	SSM		;set screen memory
  5426
  5427 				;	Test first 8K ROM.
  5428
  5429 52A9 AD 20 30		STM1	LDA	ST3020
  5430 52AC C9 AA			CMP	#$AA		;color 1 for failure
  5431 52AE F0 17			BEQ	STM4		;if first 8K ROM already failed
  5432
  5433 52B0 A9 55			LDA	#$55		;color 0 for test
  5434 52B2 20 8E 53			JSR	DFS		;display first ROM status
  5435 52B5 20 B1 53			JSR	DMW		;delay a middling while
  5436 52B8 20 73 FF			JSR	VFR		;verify first 8K ROM
  5437 52BB B0 05			BCS	STM2		;if ROM failed
  5438
  5439 52BD A9 FF			LDA	#$FF		;color 2 for success
  5440 52BF 4C C4 52			JMP	STM3
  5441
  5442 52C2 A9 AA		STM2	LDA	#$AA		;color 1 for failure
  5443
  5444 52C4 20 8E 53		STM3	JSR	DFS		;display first ROM status
  5445
  5446 				;	Test second 8K ROM.
  5447
  5448 52C7 AD 24 30		STM4	LDA	ST3024
  5449 52CA C9 AA			CMP	#$AA		;color 1 for failure
  5450 52CC F0 17			BEQ	STM7		;if second 8K ROM already failed
  5451
  5452 52CE A9 55			LDA	#$55		;color 0 for test
  5453 52D0 20 99 53			JSR	DSS		;display second ROM status
  5454 52D3 20 B1 53			JSR	DMW		;delay a middling while
  5455 52D6 20 92 FF			JSR	VSR		;verify second 8K ROM
  5456 52D9 B0 05			BCS	STM5		;if ROM failed
  5457
  5458 52DB A9 FF			LDA	#$FF		;color 2 for success
  5459 52DD 4C E2 52			JMP	STM6
  5460
  5461 52E0 A9 AA		STM5	LDA	#$AA		;color 1 for failure
  5462
  5463 52E2 20 99 53		STM6	JSR	DSS		;display second ROM status
  5464
  5465 				;	Test RAM.
  5466
  5467 52E5 A9 C0		STM7	LDA	#$C0		;mask for left side of a screen byte
  5468 52E7 85 8D			STA	STSMM
  5469 52E9 A9 04			LDA	#$04		;initially select LED 1 off
  5470 52EB 85 A4			STA	STLM		;LED mask
  5471 52ED A9 00			LDA	#0
  5472 52EF 85 8E			STA	STSMP		;initialize ???
  5473 52F1 85 90			STA	STPAG		;initialize current page
  5474 52F3 85 91			STA	STPAG+1
  5475 52F5 85 8F			STA	ST1K		;initialize current 1K to test
  5476
  5477 				;	Test 1K of RAM.
  5478
  5479 52F7 A6 8E		STM8	LDX	STSMP		;screen memory pointer
  5480 52F9 BD 38 30			LDA	ST3038,X
  5481 52FC 25 8D			AND	STSMM
  5482 52FE C9 80			CMP	#$80
  5483 5300 F0 5C			BEQ	STM17		;if already failed
  5484
  5485 5302 C9 08			CMP	#$08
  5486 5304 F0 58			BEQ	STM17		;if already failed
  5487
  5488 5306 A9 44			LDA	#$44		;color 0 for test
  5489 5308 20 C3 53			JSR	DRS		;display RAM block status
  5490 530B A5 A4			LDA	STLM		;LED mask
  5491 530D 20 A4 53			JSR	SLD		;set LED's
  5492 5310 A5 A4			LDA	STLM		;current LED mask
  5493 5312 49 0C			EOR	#$0C		;complement LED's selected
  5494 5314 85 A4			STA	STLM		;update LED mask
  5495
  5496 				;	Check for memory not to test.
  5497
  5498 5316 A2 07			LDX	#TMNTL-1+2	;2 bytes beyond last byte of table
  5499
  5500 5318 BD 4A 54		STM9	LDA	TMNT,X		;range to test
  5501 531B C5 91			CMP	STPAG+1		;high current page
  5502 531D F0 37			BEQ	STM15		;if not to test, indicate success
  5503
  5504 531F CA				DEX
  5505 5320 10 F6			BPL	STM9		;if not done
  5506
  5507 				;	Test 1K of RAM.
  5508
  5509 5322 A9 04			LDA	#4		;number of pages to test
  5510 5324 85 92			STA	STPC		;page count
  5511
  5512 				;	Write initial list to page.
  5513
  5514 5326 A2 00		STM10	LDX	#0		;initial value to write
  5515
  5516 				;	Write list to page.
  5517
  5518 5328 A0 00		STM11	LDY	#0		;offset to first byte of page
  5519
  5520 532A 8A			STM12	TXA
  5521 532B 91 90			STA	(STPAG),Y	;byte of page
  5522 532D E8				INX
  5523 532E C8				INY
  5524 532F D0 F9			BNE	STM12		;if not done writing page
  5525
  5526 				;	Verify list written to page.
  5527
  5528 5331 86 93			STX	STMVAL		;first correct value to test
  5529 5333 A0 00			LDY	#0		;offset to first byte of page
  5530
  5531 5335 B1 90		STM13	LDA	(STPAG),Y	;byte of page
  5532 5337 C5 93			CMP	STMVAL		;correct value
  5533 5339 D0 10			BNE	STM14		;if not correct value
  5534
  5535 533B E6 93			INC	STMVAL		;increment value to test
  5536 533D C8				INY
  5537 533E D0 F5			BNE	STM13		;if not done verifying page
  5538
  5539 				;	Increment and test initial value to write.
  5540
  5541 5340 E8				INX			;increment initial value to write
  5542 5341 D0 E5			BNE	STM11		;if not done, write another list
  5543
  5544 				;	Decrement and test page counter.
  5545
  5546 5343 E6 91			INC	STPAG+1		;increment high current page
  5547 5345 C6 92			DEC	STPC		;decrement page count
  5548 5347 D0 DD			BNE	STM10		;if not done testing pages
  5549
  5550 5349 F0 0E			BEQ	STM16		;indicate success
  5551
  5552 				;	Display failure.
  5553
  5554 534B 20 B1 53		STM14	JSR	DMW		;delay a middling while
  5555 534E A9 88			LDA	#$88		;color 1 for failure
  5556 5350 20 C3 53			JSR	DRS		;display RAM block status
  5557 5353 4C 5E 53			JMP	STM17
  5558
  5559 				;	Delay for simulating test of memory not to test.
  5560
  5561 5356 20 B5 53		STM15	JSR	DLW		;delay a long while
  5562
  5563 				;	Display success.
  5564
  5565 5359 A9 CC		STM16	LDA	#$CC		;color 2 for success
  5566 535B 20 C3 53			JSR	DRS		;display RAM block status
  5567
  5568 535E A5 8D		STM17	LDA	STSMM
  5569 5360 30 26			BMI	STM20
  5570
  5571 5362 A9 C0			LDA	#$C0
  5572 5364 85 8D			STA	STSMM
  5573 5366 E6 8E			INC	STSMP		;increment screen memory pointer
  5574
  5575 5368 18			STM18	CLC
  5576 5369 A5 8F			LDA	ST1K		;current 1K to test
  5577 536B 69 04			ADC	#>$0400	;add 1K
  5578 536D 85 91			STA	STPAG+1		;high current page
  5579 536F 85 8F			STA	ST1K		;update current 1K to test
  5580 5371 CD E4 02			CMP	RAMSIZ		;RAM size
  5581 5374 D0 81			BNE	STM8		;if not done testing RAM
  5582
  5583 				;	Check for auto-mode.
  5584
  5585 5376 A5 82			LDA	STAUT		;auto-mode flag
  5586 5378 D0 03			BNE	STM19		;if auto-mode, perform audio-visual test
  5587
  5588 				;	Test memory again.
  5589
  5590 537A 4C A9 52			JMP	STM1		;test memory again
  5591
  5592 				;	Process auto-mode.
  5593
  5594 537D A9 0C		STM19	LDA	#$0C	;indicate LED 1 and 2 off
  5595 537F 20 A4 53			JSR	SLD	;set LED's
  5596 5382 20 B5 53			JSR	DLW	;delay a long while
  5597 5385 4C 57 55			JMP	STV	;self-test audio-visual
  5598
  5599 5388 A9 0C		STM20	LDA	#$0C
  5600 538A 85 8D			STA	STSMM
  5601 538C D0 DA			BNE	STM18
  5602 					;SPACE	4,10
  5603 				;	DFS - Display First ROM Status
  5604 				*
  5605 				*	ENTRY	JSR	DFS
  5606 				*
  5607 				*	MODS
  5608 				*		M. W. Colburn	10/26/82
  5609 				*		1. Bring closer to Coding Standard (object unchanged).
  5610 				*		   R. K. Nordin	11/01/83
  5611
  5612
  5613 = 538E			DFS	=	*		;entry
  5614 538E A2 04			LDX	#1*4		;first 8K ROM display
  5615 5390 20 2A 57			JSR	SVR		;set value in range
  5616 5393 29 FC			AND	#$FC
  5617 5395 8D 23 30			STA	ST3020+3
  5618 5398 60				RTS			;return
  5619 					;SPACE	4,10
  5620 				;	DSS - Display Second ROM Status
  5621 				*
  5622 				*	ENTRY	JSR	DSS
  5623 				*
  5624 				*	MODS
  5625 				*		M. W. Colburn	10/26/82
  5626 				*		1. Bring closer to Coding Standard (object unchanged).
  5627 				*		   R. K. Nordin	11/01/83
  5628
  5629
  5630 = 5399			DSS	=	*		;entry
  5631 5399 A2 08			LDX	#2*4		;second 8K ROM display
  5632 539B 20 2A 57			JSR	SVR		;set value in range
  5633 539E 29 FC			AND	#$FC
  5634 53A0 8D 27 30			STA	ST3024+3
  5635 53A3 60				RTS			;return
  5636 					;SPACE	4,10
  5637 				;	SLD - Set LED's
  5638 				*
  5639 				*	ENTRY	JSR	SLD
  5640 				*		A = LED mask (bit 3 - LED 2, bit 2 - LED 1)
  5641 				*
  5642 				*	MODS
  5643 				*		M. W. Colburn	10/26/82
  5644 				*		1. Bring closer to Coding Standard (object unchanged).
  5645 				*		   R. K. Nordin	11/01/83
  5646
  5647
  5648 = 53A4			SLD	=	*		;entry
  5649 53A4 85 A5			STA	STTMP5		;save LED mask
  5650 53A6 AD 01 D3			LDA	PORTB
  5651 53A9 29 F3			AND	#$F3		;clear LED control
  5652 53AB 05 A5			ORA	STTMP5		;set LED control according to mask
  5653 53AD 8D 01 D3			STA	PORTB		;update port B memory control
  5654 53B0 60				RTS			;return
  5655 					;SPACE	4,10
  5656 				;	DMW - Delay a Middling While
  5657 				*
  5658 				*	ENTRY	JSR	DMW
  5659 				*
  5660 				*	MODS
  5661 				*		M. W. Colburn	10/26/82
  5662 				*		1. Bring closer to Coding Standard (object unchanged).
  5663 				*		   R. K. Nordin	11/01/83
  5664
  5665
  5666 = 53B1			DMW	=	*		;entry
  5667 53B1 A2 3C			LDX	#60		;60-VBLANK delay
  5668 53B3 D0 02			BNE	DAW		;delay a while
  5669 					;SPACE	4,10
  5670 				;	DLW - Delay a Long While
  5671 				*
  5672 				*	ENTRY	JSR	DLW
  5673 				*
  5674 				*	MODS
  5675 				*		M. W. Colburn	10/26/82
  5676 				*		1. Bring closer to Coding Standard (object unchanged).
  5677 				*		   R. K. Nordin	11/01/83
  5678
  5679
  5680 = 53B5			DLW	=	*		;entry
  5681 53B5 A2 96			LDX	#150		;150-VBLANK delay
  5682 				;	JMP	DAW		;delay a while, return
  5683 					;SPACE	4,10
  5684 				;	DAW - Delay a While
  5685 				*
  5686 				*	ENTRY	JSR	DAW
  5687 				*
  5688 				*	MODS
  5689 				*		M. W. Colburn	10/26/82
  5690 				*		1. Bring closer to Coding Standard (object unchanged).
  5691 				*		   R. K. Nordin	11/01/83
  5692
  5693
  5694 = 53B7			DAW	=	*		;entry
  5695
  5696 53B7 A0 FF		DAW1	LDY	#$FF		;initialize inner loop counter
  5697
  5698 53B9 8C 0A D4		DAW2	STY	WSYNC		;wait for HBLANK synchronization
  5699 53BC 88				DEY
  5700 53BD D0 FA			BNE	DAW2		;if inner loop not done
  5701
  5702 53BF CA				DEX
  5703 53C0 D0 F5			BNE	DAW1		;if outer loop not done
  5704
  5705 53C2 60				RTS			;return
  5706 					;SPACE	4,10
  5707 				;	DRS - Display RAM Block Status
  5708 				*
  5709 				*	ENTRY	JSR	DRS
  5710 				*
  5711 				*	MODS
  5712 				*		M. W. Colburn	10/26/82
  5713 				*		1. Bring closer to Coding Standard (object unchanged).
  5714 				*		   R. K. Nordin	11/01/83
  5715
  5716
  5717 = 53C3			DRS	=	*		;entry
  5718 53C3 48				PHA			;save color
  5719 53C4 A6 8E			LDX	STSMP
  5720 53C6 A5 8D			LDA	STSMM
  5721 53C8 49 FF			EOR	#$FF		;complement
  5722 53CA 3D 38 30			AND	ST3038,X
  5723 53CD 9D 38 30			STA	ST3038,X
  5724 53D0 68				PLA			;saved color
  5725 53D1 25 8D			AND	STSMM
  5726 53D3 1D 38 30			ORA	ST3038,X
  5727 53D6 9D 38 30			STA	ST3038,X
  5728 53D9 60				RTS			;return
  5729 					;SPACE	4,10
  5730 				;	POD - Process Other DLI's
  5731 				*
  5732 				*	POD turns the last line on the screen into white on black,
  5733 				*	handles keyboard self-test display of console switches, handles
  5734 				*	HELP key for exit, and ensures no attract-mode.
  5735 				*
  5736 				*	ENTRY	JMP	POD
  5737 				*
  5738 				*	EXIT
  5739 				*		Exits via RTI
  5740 				*
  5741 				*	MODS
  5742 				*		M. W. Colburn	10/26/82
  5743 				*		1. Bring closer to Coding Standard (object unchanged).
  5744 				*		   R. K. Nordin	11/01/83
  5745
  5746
  5747 = 53DA			POD	=	*	;entry
  5748
  5749 				;	Initialize.
  5750
  5751 53DA 48				PHA		;save A
  5752
  5753 				;	Select colors.
  5754
  5755 53DB A9 0C			LDA	#$0C	;white color
  5756 53DD 8D 17 D0			STA	COLPF1	;playfield 1 color
  5757 53E0 AD C8 02			LDA	COLOR4	;background color
  5758 53E3 8D 18 D0			STA	COLPF2	;playfield 2 color
  5759
  5760 				;	Ensure no attract-mode.
  5761
  5762 53E6 A9 00			LDA	#0	;no attract-mode
  5763 53E8 85 4D			STA	ATRACT	;attract-mode timer/flag
  5764
  5765 				;	Check HELP key.
  5766
  5767 53EA AD DC 02			LDA	HELPFG	;HELP key flag
  5768 53ED F0 0E			BEQ	POD1	;if HELP not pressed
  5769
  5770 				;	Process HELP key.
  5771
  5772 53EF A9 00			LDA	#0	;HELP key not pressed indicator
  5773 53F1 8D DC 02			STA	HELPFG	;HELP key flag
  5774 53F4 A9 0C			LDA	#$0C	;LED's off
  5775 53F6 20 A4 53			JSR	SLD	;set LED's
  5776 53F9 58				CLI
  5777 53FA 4C 0C 50			JMP	SEL	;start over with main screen
  5778
  5779 				;	Check for keyboard self-test.
  5780
  5781 53FD A5 8A		POD1	LDA	STKST	;keyboard self-test flag
  5782 53FF F0 47			BEQ	POD10	;if not keyboard self-test, exit
  5783
  5784 				;	Set display of console switches pressed.
  5785
  5786 5401 AD 1F D0			LDA	CONSOL	;console switches
  5787 5404 29 01			AND	#$01	;START key indicator
  5788 5406 F0 04			BEQ	POD2	;if START key pressed
  5789
  5790 5408 A9 B3			LDA	#$B3
  5791 540A D0 02			BNE	POD3	;set display
  5792
  5793 540C A9 33		POD2	LDA	#$33
  5794
  5795 540E 8D 1C 30		POD3	STA	ST301C	;set START key display
  5796
  5797 5411 AD 1F D0			LDA	CONSOL	;console switches
  5798 5414 29 02			AND	#$02	;SELECT key indicator
  5799 5416 F0 04			BEQ	POD4	;if SELECT key pressed
  5800
  5801 5418 A9 F3			LDA	#$F3
  5802 541A D0 02			BNE	POD5	;set display
  5803
  5804 541C A9 73		POD4	LDA	#$73
  5805
  5806 541E 8D 1E 30		POD5	STA	ST301E	;set SELECT key display
  5807
  5808 5421 AD 1F D0			LDA	CONSOL	;console switches
  5809 5424 29 04			AND	#$04	;OPTION key indicator
  5810 5426 F0 04			BEQ	POD6	;if OPTION key pressed
  5811
  5812 5428 A9 AF			LDA	#$AF
  5813 542A D0 02			BNE	POD7	;set display
  5814
  5815 542C A9 2F		POD6	LDA	#$2F
  5816
  5817 542E 8D 20 30		POD7	STA	ST3020	;set OPTION key display
  5818
  5819 				;	Sound tone if console switches pressed.
  5820
  5821 5431 AD 1F D0			LDA	CONSOL	;console switches
  5822 5434 29 07			AND	#$07	;key indicators
  5823 5436 C9 07			CMP	#$07	;no keys pressed
  5824 5438 F0 09			BEQ	POD8	;if no keys pressed
  5825
  5826 543A A9 64			LDA	#100	;frequency
  5827 543C 8D 02 D2			STA	AUDF2	;set frequency of voice 2
  5828 543F A9 A8			LDA	#$A8	;pure tone, half volume
  5829 5441 D0 02			BNE	POD9	;set control of voice 2
  5830
  5831 5443 A9 00		POD8	LDA	#0	;zero volume
  5832
  5833 5445 8D 03 D2		POD9	STA	AUDC2	;set control of voice 2
  5834
  5835 				;	Exit.
  5836
  5837 5448 68			POD10	PLA		;restore A
  5838 5449 40				RTI		;return
  5839 					;SPACE	4,10
  5840 				;	TMNT - Table of Memory Not to Test
  5841 				*
  5842 				*	NOTES
  5843 				*		Problem: bytes wasted by redundant entries.
  5844
  5845
  5846 544A 00			TMNT	.byte	>$0000	;$0000 - $03FF, zero page and stack
  5847 544B 50				.byte	>$5000	;$5000 - $53FF, self-test ROM
  5848 544C 54				.byte	>$5400	;$5400 - $57FF, self-test ROM
  5849 544D 30				.byte	>ST3000	;ST3000 - ST3000+$03FF, screen memory
  5850 544E 30				.byte	>ST3000	;ST3000 - ST3000+$03FF, screen memory
  5851 544F 30				.byte	>ST3000	;ST3000 - ST3000+$03FF, screen memory
  5852
  5853 = 0006			TMNTL	=	*-TMNT	;length
  5854 				;	;SPACE	4,10
  5855 				;	STK - Self-test Keyboard
  5856 				*
  5857 				*	STK verifies the operation of the keyboard by displaying
  5858 				*	keys as they are pressed.  In auto-mode, the verification
  5859 				*	is simulated.
  5860 				*
  5861 				*	ENTRY	JSR	STK
  5862 				*
  5863 				*	NOTES
  5864 				*		Problem: one too many bytes taken from TSKP table.
  5865 				*		Problem: wasted bytes for extra LDA CH.
  5866 				*		Problem: logic is convoluted (due to SBT and SAS
  5867 				*		subroutines appearing in the middle of STK).
  5868 				*
  5869 				*	MODS
  5870 				*		M. W. Colburn	10/26/82
  5871 				*		1. Bring closer to Coding Standard (object unchanged).
  5872 				*		   R. K. Nordin	11/01/83
  5873
  5874
  5875 = 5450			STK	=	*		;entry
  5876
  5877 				;	Initialize.
  5878
  5879 5450 A2 00			LDX	#0
  5880 5452 86 94			STX	STSKP		;initialize simulated keypress index
  5881 5454 A2 03			LDX	#3		;keyboard test colors
  5882 5456 20 73 57			JSR	SUC		;set up colors
  5883 5459 A2 15			LDX	#<DISL4	;keyboard display list
  5884 545B A0 52			LDY	#>DISL4
  5885 545D A9 FF			LDA	#$FF		;indicate keyboard self-test
  5886 545F 20 9E 50			JSR	SDL		;set up display list
  5887
  5888 				;	Test keyboard.
  5889
  5890 5462 A2 02		STK1	LDX	#2		;offset to "KEYBOARD TEST" text
  5891 5464 20 59 57			JSR	SSM		;set screen memory
  5892 5467 A2 07			LDX	#7		;offset to keyboard text
  5893 5469 20 59 57			JSR	SSM		;set screen memory
  5894
  5895 				;	Check auto-mode.
  5896
  5897 546C A5 82			LDA	STAUT		;auto-mode flag
  5898 546E F0 13			BEQ	STK3		;if not auto-mode
  5899
  5900 				;	Simulate keypress.
  5901
  5902 5470 A6 94		STK2	LDX	STSKP		;offset to next simulated keypress
  5903 5472 BD 45 55			LDA	TSKP,X		;simulated keypress
  5904 5475 E6 94			INC	STSKP		;advance offset to simulated keypress
  5905 5477 A6 94			LDX	STSKP		;offset to simulated keypress
  5906 5479 E0 13			CPX	#TSKPL+1	;last offset+1+1
  5907 547B D0 14			BNE	STK4		;if last keypress not processed
  5908
  5909 				;	Self-test memory.
  5910
  5911 547D 20 B5 53			JSR	DLW		;delay a long while
  5912 5480 4C 91 52			JMP	STM		;self-test memory
  5913
  5914 				;	Get a keypress.
  5915
  5916 5483 AD FC 02		STK3	LDA	CH		;key code
  5917 5486 C9 FF			CMP	#$FF		;clear code indicator
  5918 5488 F0 F9			BEQ	STK3		;if no key pressed
  5919
  5920 548A C9 C0			CMP	#$C0
  5921 548C B0 F5			BCS	STK3		;if ???
  5922
  5923 548E AD FC 02			LDA	CH		;key code
  5924
  5925 				;	Process keypress.
  5926
  5927 5491 A2 FF		STK4	LDX	#$FF		;clear code indicator
  5928 5493 8E FC 02			STX	CH		;key code
  5929 5496 48				PHA			;save key code
  5930 5497 29 80			AND	#$80
  5931 5499 F0 05			BEQ	STK5		;if not CTRL
  5932
  5933 549B A2 08			LDX	#8		;offset to control key text
  5934 549D 20 59 57			JSR	SSM		;set screen memory
  5935
  5936 				;	Check for shift key.
  5937
  5938 54A0 68			STK5	PLA			;saved key code
  5939 54A1 48				PHA			;save key code
  5940 54A2 29 40			AND	#$40
  5941 54A4 F0 0A			BEQ	STK6		;if not shift key
  5942
  5943 				;	Process keyboard shift key display.
  5944
  5945 54A6 A2 05			LDX	#5		;offset to "SH"
  5946 54A8 20 59 57			JSR	SSM		;set screen memory
  5947 54AB A2 04			LDX	#4		;offset to "SH"
  5948 54AD 20 59 57			JSR	SSM		;set screen memory
  5949
  5950 				;	Check for special keys.
  5951
  5952 54B0 68			STK6	PLA			;saved key code
  5953 54B1 29 3F			AND	#$3F
  5954 54B3 C9 21			CMP	#$21
  5955 54B5 F0 68			BEQ	KSB		;if space bar, process display
  5956
  5957 54B7 C9 2C			CMP	#$2C
  5958 54B9 F0 74			BEQ	KTK		;if tab key, process display
  5959
  5960 54BB C9 34			CMP	#$34
  5961 54BD F0 68			BEQ	KBK		;if backspace key, process display
  5962
  5963 54BF C9 0C			CMP	#$0C
  5964 54C1 F0 76			BEQ	KRK		;if return key, process display
  5965
  5966 				;	Process other key displays.
  5967
  5968 54C3 AA				TAX			;key code
  5969 54C4 BD 9C 57			LDA	TSMC,X		;display character
  5970 54C7 48				PHA			;save display character
  5971
  5972 54C8 A9 21			LDA	#<ST3021
  5973 54CA 85 95			STA	STTMP1		;screen pointer
  5974 54CC A9 30			LDA	#>ST3021
  5975 54CE 85 96			STA	STTMP1+1
  5976
  5977 				;	Find display character in screen memory.
  5978
  5979 54D0 68				PLA			;saved display character
  5980 54D1 A0 FF			LDY	#$FF		;preset offset
  5981
  5982 54D3 C8			STK7	INY
  5983 54D4 D1 95			CMP	(STTMP1),Y
  5984 54D6 D0 FB			BNE	STK7		;if not found
  5985
  5986 				;	Display inverse video.
  5987
  5988 54D8 B1 95			LDA	(STTMP1),Y
  5989 54DA 49 80			EOR	#$80		;invert video
  5990 54DC 91 95			STA	(STTMP1),Y
  5991
  5992 				;	Check auto-mode.
  5993
  5994 54DE A5 82		STK8	LDA	STAUT		;auto-mode flag
  5995 54E0 F0 13			BEQ	STK9		;if not auto-mode
  5996
  5997 				;	Process auto-mode.
  5998
  5999 54E2 20 05 55			JSR	SBT		;sound beep tone
  6000 54E5 A2 14			LDX	#20		;20-VBLANK delay
  6001 54E7 20 B7 53			JSR	DAW		;delay a while
  6002 54EA 20 10 55			JSR	SAS		;silence all sounds
  6003 54ED A2 0A			LDX	#10		;10-VBLANK delay
  6004 54EF 20 B7 53			JSR	DAW		;delay a while
  6005 54F2 4C 62 54			JMP	STK1		;get next simulated keypress
  6006
  6007 				;	Process manual mode.
  6008
  6009 54F5 20 05 55		STK9	JSR	SBT		;sound beep tone
  6010
  6011 54F8 AD 0F D2		STK10	LDA	SKSTAT
  6012 54FB 29 04			AND	#$04
  6013 54FD F0 F9			BEQ	STK10
  6014
  6015 54FF 20 10 55			JSR	SAS		;silence all sounds
  6016 5502 4C 62 54			JMP	STK1		;get next keypress
  6017 					;SPACE	4,10
  6018 				;	SBT - Sound Beep Tone
  6019 				*
  6020 				*	ENTRY	JSR	SBT
  6021 				*
  6022 				*	MODS
  6023 				*		M. W. Colburn	10/26/82
  6024 				*		1. Bring closer to Coding Standard (object unchanged).
  6025 				*		   R. K. Nordin	11/01/83
  6026
  6027
  6028 = 5505			SBT	=	*	;entry
  6029 5505 A9 64			LDA	#$64	;frequency
  6030 5507 8D 00 D2			STA	AUDF1	;set frequency
  6031 550A A9 A8			LDA	#$A8	;pure tone, half volume
  6032 550C 8D 01 D2			STA	AUDC1	;set control
  6033 550F 60				RTS		;return
  6034 					;SPACE	4,10
  6035 				;	SAS - Silence All Sounds
  6036 				*
  6037 				*	ENTRY	JSR	SAS
  6038 				*
  6039 				*	MODS
  6040 				*		M. W. Colburn	10/26/82
  6041 				*		1. Bring closer to Coding Standard (object unchanged).
  6042 				*		   R. K. Nordin	11/01/83
  6043
  6044
  6045 = 5510			SAS	=	*	;entry
  6046 5510 A9 00			LDA	#0	;volume 0
  6047 5512 8D 01 D2			STA	AUDC1	;silence voice 1
  6048 5515 8D 03 D2			STA	AUDC2	;silence voice 2
  6049 5518 8D 05 D2			STA	AUDC3	;silence voice 3
  6050 551B 8D 07 D2			STA	AUDC4	;silence voice 4
  6051 551E 60				RTS		;return
  6052 					;SPACE	4,10
  6053 				;	KSB - Process Keyboard Space Bar Display
  6054 				*
  6055 				*	ENTRY	JSR	KSB
  6056 				*
  6057 				*	MODS
  6058 				*		M. W. Colburn	10/26/82
  6059 				*		1. Bring closer to Coding Standard (object unchanged).
  6060 				*		   R. K. Nordin	11/01/83
  6061
  6062
  6063 = 551F			KSB	=	*	;entry
  6064 551F A2 03			LDX	#3	;offset to "S P A C E   B A R" text
  6065 5521 20 59 57			JSR	SSM	;set screen memory
  6066 5524 4C DE 54			JMP	STK8	;continue
  6067 					;SPACE	4,10
  6068 				;	KBK - Process Keyboard Backspace Key Display
  6069 				*
  6070 				*	ENTRY	JSR	KBK
  6071 				*
  6072 				*	MODS
  6073 				*		M. W. Colburn	10/26/82
  6074 				*		1. Bring closer to Coding Standard (object unchanged).
  6075 				*		   R. K. Nordin	11/01/83
  6076
  6077
  6078 = 5527			KBK	=	*	;entry
  6079 5527 A2 06			LDX	#6	;offset to "B S" text
  6080 5529 20 59 57			JSR	SSM	;set screen memory
  6081 552C 4C DE 54			JMP	STK8	;continue
  6082 					;SPACE	4,10
  6083 				;	KTK - Process Keyboard Tab Key Display
  6084 				*
  6085 				*	ENTRY	JSR	KTK
  6086 				*
  6087 				*	MODS
  6088 				*		M. W. Colburn	10/26/82
  6089 				*		1. Bring closer to Coding Standard (object unchanged).
  6090 				*		   R. K. Nordin	11/01/83
  6091
  6092
  6093 = 552F			KTK	=	*	;entry
  6094 552F A9 7F			LDA	#$7F
  6095 5531 8D 52 30			STA	ST3052
  6096 5534 8D 53 30			STA	ST3052+1
  6097 5537 D0 A5			BNE	STK8	;continue
  6098 					;SPACE	4,10
  6099 				;	KRK - Process Keyboard Return Key Display
  6100 				*
  6101 				*	ENTRY	JSR	KRK
  6102 				*
  6103 				*	MODS
  6104 				*		M. W. Colburn	10/26/82
  6105 				*		1. Bring closer to Coding Standard (object unchanged).
  6106 				*		   R. K. Nordin	11/01/83
  6107
  6108
  6109 = 5539			KRK	=	*	;entry
  6110 5539 A9 32			LDA	#$32
  6111 553B 8D 6D 30			STA	ST306D
  6112 553E A9 34			LDA	#$34
  6113 5540 8D 6E 30			STA	ST306D+1
  6114 5543 D0 99			BNE	STK8	;continue
  6115 					;SPACE	4,10
  6116 				;	TSKP - Table of Simulated Keypresses
  6117
  6118
  6119 5545 52 08 0A 2B 28 0D + TSKP	.byte	$52,$08,$0A,$2B,$28,$0D,$3D,$39,$2D	;"Copyright"
  6120 554E 1F 30 35 1A			.byte	$1F,$30,$35,$1A				;"1983"
  6121 5552 7F 2D 3F 28 0D		.byte	$7F,$2D,$3F,$28,$0D			;"Atari"
  6122
  6123 = 0012			TSKPL	=	*-TSKP	;length
  6124 				;	;SPACE	4,10
  6125 				;	STV - Self-test Audio-visual
  6126 				*
  6127 				*	STV verifies the operation of the display and voices by
  6128 				*	displaying and playing a tune.
  6129 				*
  6130 				*	ENTRY	JSR	STV
  6131 				*
  6132 				*	MODS	M. W. Colburn	10/26/82
  6133 				*		1. Bring closer to Coding Standard (object unchanged).
  6134 				*		   R. K. Nordin	11/01/83
  6135
  6136
  6137 = 5557			STV	=	*		;entry
  6138
  6139 				;	Initialize.
  6140
  6141 5557 A2 02			LDX	#2		;audio-visual test colors
  6142 5559 20 73 57			JSR	SUC		;set up colors
  6143
  6144 				;	Test audio-visual.
  6145
  6146 555C A9 00		STV1	LDA	#0
  6147 555E 85 97			STA	STVOC		;initialize voice indicator
  6148
  6149 				;	Test voice.
  6150
  6151 5560 A9 00		STV2	LDA	#0
  6152 5562 85 98			STA	STNOT		;initialize note counter
  6153 5564 A2 31			LDX	#<DISL5	;audio-visual display list
  6154 5566 A0 52			LDY	#>DISL5
  6155 5568 A9 00			LDA	#0		;indicate not keyboard self-test
  6156 556A 20 9E 50			JSR	SDL		;set up display list
  6157
  6158 				;	Display voice number.
  6159
  6160 556D A2 09			LDX	#9		;offset to "VOICE #" text
  6161 556F 20 59 57			JSR	SSM		;set screen memory
  6162 5572 A5 97			LDA	STVOC		;voice indicator
  6163 5574 4A				LSR		;voice number
  6164 5575 18				CLC
  6165 5576 69 11			ADC	#$11		;adjust for screen memory
  6166 5578 8D 0B 30			STA	ST300B		;voice number display
  6167
  6168 				;	Display staff.
  6169
  6170 557B A2 0F			LDX	#$0F		;offset to last byte of staff lines
  6171
  6172 557D A9 FF		STV3	LDA	#$FF		;color 2
  6173 557F 9D 50 31			STA	ST3150,X	;byte of first line of staff
  6174 5582 9D B0 31			STA	ST31B0,X	;byte of second line of staff
  6175 5585 9D 10 32			STA	ST3210,X	;byte of third line of staff
  6176 5588 9D 70 32			STA	ST3270,X	;byte of fourth line of staff
  6177 558B 9D D0 32			STA	ST32D0,X	;byte of fifth line of staff
  6178 558E CA				DEX
  6179 558F 10 EC			BPL	STV3		;if not done
  6180
  6181 				;	Display cleft.
  6182
  6183 5591 A9 00			LDA	#0		;offset to first cleft display address
  6184 5593 85 99			STA	STCDI		;cleft display pointer
  6185 5595 A9 0C			LDA	#2*6
  6186 5597 85 9A			STA	STCDA		;cleft data pointer
  6187
  6188 5599 A6 99		STV4	LDX	STCDI		;cleft display pointer
  6189 559B BD 17 57			LDA	TCDA+1,X	;high address of cleft display
  6190 559E A8				TAY
  6191 559F BD 16 57			LDA	TCDA,X		;low address of cleft display
  6192 55A2 AA				TAX
  6193 55A3 A5 9A			LDA	STCDA		;cleft data pointer
  6194 55A5 20 85 56			JSR	DVN		;display ???
  6195 55A8 18				CLC
  6196 55A9 A5 9A			LDA	STCDA		;cleft data pointer
  6197 55AB 69 06			ADC	#6
  6198 55AD 85 9A			STA	STCDA		;update cleft data pointer
  6199 55AF E6 99			INC	STCDI		;increment cleft display pointer
  6200 55B1 E6 99			INC	STCDI
  6201 55B3 A5 99			LDA	STCDI		;cleft display pointer
  6202 55B5 C9 14			CMP	#TCDAL		;length of cleft display table
  6203 55B7 D0 E0			BNE	STV4		;if not done
  6204
  6205 				;	Delay.
  6206
  6207 55B9 20 B1 53			JSR	DMW		;delay a middling while
  6208
  6209 				;	Display and play first note.
  6210
  6211 55BC A2 54			LDX	#<ST3154
  6212 55BE A0 31			LDY	#>ST3154
  6213 55C0 A9 00			LDA	#0*6
  6214 55C2 20 85 56			JSR	DVN
  6215
  6216 55C5 A9 51			LDA	#$51		;first note frequency
  6217 55C7 20 6C 56			JSR	SVN
  6218
  6219 				;	Display and play second note.
  6220
  6221 55CA A2 86			LDX	#<ST3186
  6222 55CC A0 31			LDY	#>ST3186
  6223 55CE A9 00			LDA	#0*6
  6224 55D0 20 85 56			JSR	DVN
  6225
  6226 55D3 A9 5B			LDA	#$5B		;second note frequency
  6227 55D5 20 6C 56			JSR	SVN
  6228
  6229 				;	Display and play third note.
  6230
  6231 55D8 A2 F8			LDX	#<ST30F8
  6232 55DA A0 30			LDY	#>ST30F8
  6233 55DC A9 48			LDA	#12*6
  6234 55DE 20 85 56			JSR	DVN
  6235 55E1 A2 C7			LDX	#<ST30C7
  6236 55E3 A0 30			LDY	#>ST30C7
  6237 55E5 A9 54			LDA	#14*6
  6238 55E7 20 85 56			JSR	DVN
  6239 55EA A2 48			LDX	#<ST3248
  6240 55EC A0 32			LDY	#>ST3248
  6241 55EE A9 4E			LDA	#13*6
  6242 55F0 20 85 56			JSR	DVN
  6243
  6244 55F3 A9 44			LDA	#$44		;third note frequency
  6245 55F5 20 6C 56			JSR	SVN
  6246
  6247 				;	Display and play fourth note.
  6248
  6249 55F8 A2 CA			LDX	#<ST30CA
  6250 55FA A0 30			LDY	#>ST30CA
  6251 55FC A9 48			LDA	#12*6
  6252 55FE 20 85 56			JSR	DVN
  6253 5601 A2 1A			LDX	#<ST321A
  6254 5603 A0 32			LDY	#>ST321A
  6255 5605 A9 4E			LDA	#13*6
  6256 5607 20 85 56			JSR	DVN
  6257 560A A2 CA			LDX	#<ST31CA
  6258 560C A0 31			LDY	#>ST31CA
  6259 560E A9 06			LDA	#1*6
  6260 5610 20 85 56			JSR	DVN
  6261
  6262 5613 A9 3C			LDA	#$3C		;fourth note frequency
  6263 5615 20 6C 56			JSR	SVN
  6264
  6265 				;	Display and play fifth note.
  6266
  6267 5618 A2 3C			LDX	#<ST303C
  6268 561A A0 30			LDY	#>ST303C
  6269 561C A9 48			LDA	#12*6
  6270 561E 20 85 56			JSR	DVN
  6271 5621 A2 8C			LDX	#<ST318C
  6272 5623 A0 31			LDY	#>ST318C
  6273 5625 A9 4E			LDA	#13*6
  6274 5627 20 85 56			JSR	DVN
  6275 562A A2 3C			LDX	#<ST313C
  6276 562C A0 31			LDY	#>ST313C
  6277 562E A9 06			LDA	#1*6
  6278 5630 20 85 56			JSR	DVN
  6279
  6280 5633 A9 2D			LDA	#$2D		;fifth note frequency
  6281 5635 20 6C 56			JSR	SVN
  6282
  6283 				;	Display and play sixth note.
  6284
  6285 5638 A2 9E			LDX	#<ST309E
  6286 563A A0 30			LDY	#>ST309E
  6287 563C A9 48			LDA	#12*6
  6288 563E 20 85 56			JSR	DVN
  6289 5641 A2 EE			LDX	#<ST31EE
  6290 5643 A0 31			LDY	#>ST31EE
  6291 5645 A9 4E			LDA	#13*6
  6292 5647 20 85 56			JSR	DVN
  6293
  6294 564A A9 35			LDA	#$35		;sixth note frequency
  6295 564C 20 6C 56			JSR	SVN
  6296
  6297 				;	Delay.
  6298
  6299 564F 20 B5 53			JSR	DLW		;delay a long while
  6300
  6301 				;	Advance to next voice.
  6302
  6303 5652 E6 97			INC	STVOC		;increment voice indicator
  6304 5654 E6 97			INC	STVOC
  6305 5656 A5 97			LDA	STVOC		;voice indicator
  6306 5658 C9 08			CMP	#8		;last voice indicator
  6307 565A D0 07			BNE	STV5		;if all voices not processed
  6308
  6309 				;	Process test completion.
  6310
  6311 565C A5 82			LDA	STAUT		;auto-mode flag
  6312 565E D0 06			BNE	STV6		;if auto-mode, perform keyboard test
  6313
  6314 5660 4C 5C 55			JMP	STV1		;repeat audio-visual test
  6315
  6316 				;	Test next voice.
  6317
  6318 5663 4C 60 55		STV5	JMP	STV2		;test next voice
  6319
  6320 				;	Self-test keyboard.
  6321
  6322 5666 20 B5 53		STV6	JSR	DLW		;delay a long while
  6323 5669 4C 50 54			JMP	STK		;self-test keyboard
  6324 					;SPACE	4,10
  6325 				;	SVN - Sound Tone
  6326 				*
  6327 				*	ENTRY	JSR	SVN
  6328 				*
  6329 				*	MODS
  6330 				*		M. W. Colburn	10/26/82
  6331 				*		1. Bring closer to Coding Standard (object unchanged).
  6332 				*		   R. K. Nordin	11/01/83
  6333
  6334
  6335 = 566C			SVN	=	*		;entry
  6336
  6337 				;	Sound note.
  6338
  6339 566C A4 97			LDY	STVOC		;current voice indicator
  6340 566E 99 00 D2			STA	AUDF1,Y		;set frequency
  6341 5671 A9 A8			LDA	#$A8		;pure tone, half volume
  6342 5673 99 01 D2			STA	AUDC1,Y		;set control
  6343
  6344 				;	Delay a while.
  6345
  6346 5676 A6 98			LDX	STNOT		;current note
  6347 5678 BD B6 56			LDA	TNDD,X		;delay time
  6348 567B AA				TAX
  6349 567C 20 B7 53			JSR	DAW		;delay a while
  6350
  6351 				;	Increment note counter.
  6352
  6353 567F E6 98			INC	STNOT		;increment note counter
  6354
  6355 				;	Exit.
  6356
  6357 5681 20 10 55			JSR	SAS		;silence all sounds
  6358 5684 60				RTS			;return
  6359 					;SPACE	4,10
  6360 				;	DVN - Display
  6361 				*
  6362 				*	ENTRY	JSR	DVN
  6363 				*
  6364 				*	MODS
  6365 				*		M. W. Colburn	10/26/82
  6366 				*		1. Bring closer to Coding Standard (object unchanged).
  6367 				*		   R. K. Nordin	11/01/83
  6368
  6369
  6370 = 5685			DVN	=	*		;entry
  6371 5685 86 9B			STX	STTMP2
  6372 5687 84 9C			STY	STTMP2+1
  6373 5689 AA				TAX
  6374 568A A0 00			LDY	#0
  6375 568C A9 10			LDA	#16
  6376 568E 85 9D			STA	STTMP3
  6377 5690 A9 06			LDA	#6
  6378 5692 85 A3			STA	STTMP4
  6379
  6380 5694 BD BC 56		DVN1	LDA	TAVD,X
  6381 5697 11 9B			ORA	(STTMP2),Y
  6382 5699 91 9B			STA	(STTMP2),Y
  6383 569B 20 AA 56			JSR	AST		;add 16
  6384 569E C6 9D			DEC	STTMP3
  6385 56A0 D0 F2			BNE	DVN1
  6386
  6387 56A2 E6 9D			INC	STTMP3
  6388 56A4 E8				INX
  6389 56A5 C6 A3			DEC	STTMP4
  6390 56A7 D0 EB			BNE	DVN1
  6391
  6392 56A9 60				RTS			;return
  6393 					;SPACE	4,10
  6394 				;	AST - Add Sixteen
  6395 				*
  6396 				*	ENTRY	JSR	AST
  6397 				*
  6398 				*	MODS
  6399 				*		M. W. Colburn	10/26/82
  6400 				*		1. Bring closer to Coding Standard (object unchanged).
  6401 				*		   R. K. Nordin	11/01/83
  6402
  6403
  6404 = 56AA			AST	=	*		;entry
  6405 56AA 18				CLC
  6406 56AB A5 9B			LDA	STTMP2		;current low value
  6407 56AD 69 10			ADC	#16		;add 16
  6408 56AF 85 9B			STA	STTMP2		;new low value
  6409 56B1 90 02			BCC	AST1		;if no carry
  6410
  6411 56B3 E6 9C			INC	STTMP2+1	;adjust high value
  6412
  6413 56B5 60			AST1	RTS			;return
  6414 					;SPACE	4,10
  6415 				;	TNDD - Table of Note Duration Delays
  6416
  6417
  6418 56B6 20			TNDD	.byte	32	;0 - first note
  6419 56B7 20				.byte	32	;1 - second note
  6420 56B8 20				.byte	32	;2 - third note
  6421 56B9 10				.byte	16	;3 - fourth note
  6422 56BA 10				.byte	16	;4 - fifth note
  6423 56BB 20				.byte	32	;5 - sixth note
  6424 					;SPACE	4,10
  6425 				;	TAVD - Table of Audio-visual Test Display Data
  6426
  6427
  6428 56BC 01 1F 3F 7F 3E 1C	TAVD	.byte	$01,$1F,$3F,$7F,$3E,$1C		;0
  6429 56C2 00 41 42 4C 70 40		.byte	$00,$41,$42,$4C,$70,$40		;1
  6430 56C8 00 01 02 04 08 10		.byte	$00,$01,$02,$04,$08,$10		;2
  6431 56CE 00 43 44 48 48 48		.byte	$00,$43,$44,$48,$48,$48		;3
  6432 56D4 00 44 22 10 08 07		.byte	$00,$44,$22,$10,$08,$07		;4
  6433 56DA 00 04 08 05 02 00		.byte	$00,$04,$08,$05,$02,$00		;5
  6434 56E0 00 30 48 88 84 84		.byte	$00,$30,$48,$88,$84,$84		;6
  6435 56E6 00 88 88 90 A0 C0		.byte	$00,$88,$88,$90,$A0,$C0		;7
  6436 56EC 00 F0 88 84 82 82		.byte	$00,$F0,$88,$84,$82,$82		;8
  6437 56F2 00 82 82 84 88 F0		.byte	$00,$82,$82,$84,$88,$F0		;9
  6438 56F8 00 00 00 00 00 80		.byte	$00,$00,$00,$00,$00,$80		;10
  6439 56FE 80 80 80 80 80 80		.byte	$80,$80,$80,$80,$80,$80		;11
  6440 5704 00 1C 3E 7F 7E 7C		.byte	$00,$1C,$3E,$7F,$7E,$7C		;12
  6441 570A 40 00 00 00 00 00		.byte	$40,$00,$00,$00,$00,$00		;13
  6442 5710 00 04 04 06 05 06		.byte	$00,$04,$04,$06,$05,$06		;14
  6443 					;SPACE	4,10
  6444 				;	TCDA - Table of Cleft Display Addresses
  6445
  6446
  6447 5716 C1 30		TCDA	.word	ST30C1	;0
  6448 5718 21 31			.word	ST3121	;1
  6449 571A 81 31			.word	ST3181	;2
  6450 571C F1 31			.word	ST31F1	;3
  6451 571E 02 30			.word	ST3002	;4
  6452 5720 62 30			.word	ST3062	;5
  6453 5722 22 31			.word	ST3122	;6
  6454 5724 82 31			.word	ST3182	;7
  6455 5726 C2 30			.word	ST30C2	;8
  6456 5728 C2 31			.word	ST31C2	;9
  6457
  6458 = 0014			TCDAL	=	*-TCDA		;length
  6459 					;SPACE	4,10
  6460 				;	SVR - Set Value in Range
  6461 				*
  6462 				*	ENTRY	JSR	SVR
  6463 				*		A = value to set
  6464 				*		X = offset to TARS range
  6465 				*
  6466 				*	EXIT
  6467 				*		A = value set
  6468 				*
  6469 				*	MODS
  6470 				*		M. W. Colburn	10/26/82
  6471 				*		1. Bring closer to Coding Standard (object unchanged).
  6472 				*		   R. K. Nordin	11/01/83
  6473
  6474
  6475 = 572A			SVR	=	*		;entry
  6476
  6477 				;	Initialize.
  6478
  6479 572A 48				PHA			;save value
  6480
  6481 				;	Set address range.
  6482
  6483 572B BD DC 57			LDA	TARS,X		;start of range
  6484 572E 85 9E			STA	STADR1
  6485 5730 BD DD 57			LDA	TARS+1,X
  6486 5733 85 9F			STA	STADR1+1
  6487 5735 BD DE 57			LDA	TARS+2,X	;end of range
  6488 5738 85 A0			STA	STADR2
  6489 573A BD DF 57			LDA	TARS+3,X
  6490 573D 85 A1			STA	STADR2+1
  6491
  6492 				;	Set value in range.
  6493
  6494 573F A0 00			LDY	#0		;offset to first byte
  6495
  6496 5741 68			SVR1	PLA			;saved value
  6497 5742 91 9E			STA	(STADR1),Y	;byte of range
  6498 5744 E6 9E			INC	STADR1		;increment low address
  6499 5746 D0 02			BNE	SVR2		;if no carry
  6500
  6501 5748 E6 9F			INC	STADR1+1	;adjust high address
  6502
  6503 574A 48			SVR2	PHA			;save value
  6504 574B A5 9E			LDA	STADR1		;low current address
  6505 574D C5 A0			CMP	STADR2		;low end of range
  6506 574F D0 F0			BNE	SVR1		;if definitely not done
  6507
  6508 5751 A5 9F			LDA	STADR1+1	;high current address
  6509 5753 C5 A1			CMP	STADR2+1	;high end of range
  6510 5755 D0 EA			BNE	SVR1		;if not done
  6511
  6512 				;	Exit.
  6513
  6514 5757 68				PLA			;restore value
  6515 5758 60				RTS			;return
  6516 					;SPACE	4,10
  6517 				;	SSM - Set Screen Memory
  6518 				*
  6519 				*	ENTRY	JSR	SSM
  6520 				*
  6521 				*	MODS
  6522 				*		M. W. Colburn	10/26/82
  6523 				*		1. Bring closer to Coding Standard (object unchanged).
  6524 				*		   R. K. Nordin	11/01/83
  6525
  6526
  6527 = 5759			SSM	=	*		;entry
  6528 5759 BD 57 CA			LDA	TSTO,X		;offset to source
  6529 575C A8				TAY
  6530 575D BD EC 57			LDA	TSTL,X		;length of source
  6531 5760 85 9E			STA	STADR1		;length
  6532 5762 BD F6 57			LDA	TSTD,X		;offset to destination
  6533 5765 AA				TAX
  6534
  6535 5766 B9 61 CA		SSM1	LDA	TTXT,Y		;byte of source
  6536 5769 9D 00 30			STA	ST3000,X	;byte of destination
  6537 576C C8				INY
  6538 576D E8				INX
  6539 576E C6 9E			DEC	STADR1		;decrement length
  6540 5770 D0 F4			BNE	SSM1		;if not done
  6541
  6542 5772 60				RTS			;return
  6543 					;SPACE	4,10
  6544 				;	SUC - Set Up Colors
  6545 				*
  6546 				*	ENTRY	JSR	SUC
  6547 				*		X = 0, if main screen colors
  6548 				*		  = 1, if memory test colors
  6549 				*		  = 2, if keyboard test colors
  6550 				*		  = 3, if audio-visual test colors
  6551 				*
  6552 				*	EXIT
  6553 				*		COLOR0, COLOR1, COLOR2 and COLOR4 set.
  6554 				*
  6555 				*	CHANGES
  6556 				*		A
  6557 				*
  6558 				*	CALLS
  6559 				*		-none-
  6560 				*
  6561 				*	MODS
  6562 				*		M. W. Colburn	10/26/82
  6563 				*		1. Bring closer to Coding Standard (object unchanged).
  6564 				*		   R. K. Nordin	11/01/83
  6565
  6566
  6567 = 5773			SUC	=	*		;entry
  6568
  6569 5773 BD 8C 57			LDA	SUCA,X
  6570 5776 8D C4 02			STA	COLOR0	;playfield 0 color
  6571
  6572 5779 BD 90 57			LDA	SUCB,X
  6573 577C 8D C5 02			STA	COLOR1	;playfield 1 color
  6574
  6575 577F BD 94 57			LDA	SUCC,X
  6576 5782 8D C6 02			STA	COLOR2	;playfield 2 color
  6577
  6578 5785 BD 98 57			LDA	SUCD,X
  6579 5788 8D C8 02			STA	COLOR4	;background color
  6580
  6581 578B 60				RTS		;return
  6582
  6583
  6584 578C 2C			SUCA	.byte	$2C	;0 - main screen playfield 0 color
  6585 578D 0C				.byte	$0C	;1 - memory test playfield 0 color
  6586 578E 2A				.byte	$2A	;2 - keyboard test playfield 0 color
  6587 578F 18				.byte	$18	;3 - audio-visual test playfield 0 color
  6588
  6589 5790 0F			SUCB	.byte	$0F	;0 - main screen playfield 1 color
  6590 5791 32				.byte	$32	;1 - memory test playfield 1 color
  6591 5792 0C				.byte	$0C	;2 - keyboard test playfield 1 color
  6592 5793 0E				.byte	$0E	;3 - audio-visual test playfield 1 color
  6593
  6594 5794 D2			SUCC	.byte	$D2	;0 - main screen playfield 2 color
  6595 5795 D6				.byte	$D6	;1 - memory test playfield 2 color
  6596 5796 00				.byte	$00	;2 - keyboard test playfield 2 color
  6597 5797 B4				.byte	$B4	;3 - audio-visual test playfield 2 color
  6598
  6599 5798 D2			SUCD	.byte	$D2	;0 - main screen background color
  6600 5799 A0				.byte	$A0	;1 - memory test background color
  6601 579A 30				.byte	$30	;2 - keyboard test background color
  6602 579B B4				.byte	$B4	;3 - audio-visual test background color
  6603 					;SPACE	4,10
  6604 				;	TSMC - Table of Screen Memory Character Codes
  6605 				*
  6606 				*	Entry n is the screen memory character code for key code n.
  6607
  6608
  6609 579C 2C			TSMC	.byte	$2C	;$00 - L key
  6610 579D 2A				.byte	$2A	;$01 - J key
  6611 579E 1B				.byte	$1B	;$02 - semicolon key
  6612 579F 91				.byte	$91	;$03
  6613 57A0 92				.byte	$92	;$04
  6614 57A1 2B				.byte	$2B	;$05 - K key
  6615 57A2 0B				.byte	$0B	;$06 - plus key
  6616 57A3 0A				.byte	$0A	;$07 - asterisk key
  6617 57A4 2F				.byte	$2F	;$08 - O key
  6618 57A5 00				.byte	$00	;$09
  6619 57A6 30				.byte	$30	;$0A - P key
  6620 57A7 35				.byte	$35	;$0B - U key
  6621 57A8 B2				.byte	$B2	;$0C - RETURN key
  6622 57A9 29				.byte	$29	;$0D - I key
  6623 57AA 0D				.byte	$0D	;$0E - minus key
  6624 57AB 1D				.byte	$1D	;$0F - = key
  6625
  6626 57AC 36				.byte	$36	;$10 - V key
  6627 57AD A8				.byte	$A8	;$11
  6628 57AE 23				.byte	$23	;$12 - C key
  6629 57AF 93				.byte	$93	;$13
  6630 57B0 94				.byte	$94	;$14
  6631 57B1 22				.byte	$22	;$15 - B key
  6632 57B2 38				.byte	$38	;$16 - X key
  6633 57B3 3A				.byte	$3A	;$17 - Z key
  6634 57B4 14				.byte	$14	;$18 - 4 key
  6635 57B5 00				.byte	$00	;$19
  6636 57B6 13				.byte	$13	;$1A - 3 key
  6637 57B7 16				.byte	$16	;$1B - 6 key
  6638 57B8 5B				.byte	$5B	;$1C - ESC key
  6639 57B9 15				.byte	$15	;$1D - 5 key
  6640 57BA 12				.byte	$12	;$1E - 2 key
  6641 57BB 11				.byte	$11	;$1F - 1 key
  6642
  6643 57BC 0C				.byte	$0C	;$20 - comma key
  6644 57BD 00				.byte	$00	;$21 - space key
  6645 57BE 0E				.byte	$0E	;$22 - period key
  6646 57BF 2E				.byte	$2E	;$23 - N key
  6647 57C0 00				.byte	$00	;$24
  6648 57C1 2D				.byte	$2D	;$25 - M key
  6649 57C2 0F				.byte	$0F	;$26 - / key
  6650 57C3 A1				.byte	$A1	;$27 - inverse video key
  6651 57C4 32				.byte	$32	;$28 - R key
  6652 57C5 00				.byte	$00	;$29
  6653 57C6 25				.byte	$25	;$2A - E key
  6654 57C7 39				.byte	$39	;$2B - Y key
  6655 57C8 FF				.byte	$FF	;$2C - TAB key
  6656 57C9 34				.byte	$34	;$2D - T key
  6657 57CA 37				.byte	$37	;$2E - W key
  6658 57CB 31				.byte	$31	;$2F - Q key
  6659
  6660 57CC 19				.byte	$19	;$30 - 9 key
  6661 57CD 00				.byte	$00	;$31
  6662 57CE 10				.byte	$10	;$32 - 0 key
  6663 57CF 17				.byte	$17	;$33 - 7 key
  6664 57D0 A2				.byte	$A2	;$34 - backspace key
  6665 57D1 18				.byte	$18	;$35 - 8 key
  6666 57D2 1C				.byte	$1C	;$36 - < key
  6667 57D3 1E				.byte	$1E	;$37 - > key
  6668 57D4 26				.byte	$26	;$38 - F key
  6669 57D5 28				.byte	$28	;$39 - H key
  6670 57D6 24				.byte	$24	;$3A - D key
  6671 57D7 00				.byte	$00	;$3B
  6672 57D8 A3				.byte	$A3	;$3C - CAPS key
  6673 57D9 27				.byte	$27	;$3D - G key
  6674 57DA 33				.byte	$33	;$3E - S key
  6675 57DB 21				.byte	$21	;$3F - A key
  6676 					;SPACE	4,10
  6677 				;	TARS - Table of Address Ranges to Set
  6678
  6679
  6680 57DC 00 30 FF 3E		TARS	.word	ST3000,ST3000+$0EFF	;0 - screen memory
  6681 57E0 20 30 24 30			.word	ST3020,ST3020+4		;1 - memory test first 8K ROM
  6682 57E4 24 30 28 30			.word	ST3024,ST3024+4		;2 - memory test second 8K ROM
  6683 57E8 00 30 20 30			.word	ST3000,ST3000+32	;3 - main screen bold lines
  6684 					;SPACE	4,10
  6685 				;	TSTL - Table of Self-test Text Lengths
  6686
  6687
  6688 57EC 13			TSTL	.byte	TXT0L	;0 - length of "MEMORY TEST   ROM" text
  6689 57ED 03				.byte	TXT1L	;1 - length of "RAM" text
  6690 57EE 13				.byte	TXT2L	;2 - length of "KEYBOARD TEST" text
  6691 57EF 13				.byte	TXT3L	;3 - length of "S P A C E   B A R" text
  6692 57F0 04				.byte	TXT4L	;4 - length of "SH" text
  6693 57F1 04				.byte	TXT5L	;5 - length of "SH" text
  6694 57F2 03				.byte	TXT6L	;6 - length of "B S" text
  6695 57F3 A8				.byte	TXT7L	;7 - length of keyboard text
  6696 57F4 03				.byte	TXT8L	;8 - length of control key text
  6697 57F5 07				.byte	TXT9L	;9 - length of "VOICE #" text
  6698 					;SPACE	4,10
  6699 				;	TSTD - Table of Self-test Text Destination Offsets
  6700
  6701
  6702 57F6 00			TSTD	.byte	ST3000-ST3000	;0 - offset to "MEMORY TEST   ROM" text
  6703 57F7 28				.byte	ST3028-ST3000	;1 - offset to "RAM" text
  6704 57F8 00				.byte	ST3000-ST3000	;2 - offset to "KEYBOARD TEST" text
  6705 57F9 B7				.byte	ST30B7-ST3000	;3 - offset to "S P A C E   B A R" text
  6706 57FA 92				.byte	ST3092-ST3000	;4 - offset to "SH" text
  6707 57FB AB				.byte	ST30AB-ST3000	;5 - offset to "SH" text
  6708 57FC 4C				.byte	ST304C-ST3000	;6 - offset to "B S" text
  6709 57FD 22				.byte	ST3022-ST3000	;7 - offset to keyboard text
  6710 57FE 72				.byte	ST3072-ST3000	;8 - offset to control key text
  6711 57FF 04				.byte	ST3004-ST3000	;9 - offset to "VOICE #" text
  6712 				;	;SUBTTL	'Floating Point Package'
  6713 					;SPACE	4,10
  6714 				;*	(C) Copyright 1978 Shepardson Microsystems, Inc.
  6715 					;SPACE	4,10
  6716 5800				ORG	$D800
  6717 					;SPACE	4,10
  6718 				;*	FPP - Floating Point Package
  6719 				*
  6720 				*	FPP is a collection of routines for floating point
  6721 				*	computations.  A floating point number is represented
  6722 				*	in 6 bytes:
  6723 				*
  6724 				*	Byte 0
  6725 				*		Bit 7		Sign of mantissa
  6726 				*		Bits 0 - 6	BCD exponent, biased by $40
  6727 				*
  6728 				*	Bytes 1 - 5		BCD mantissa
  6729 				*
  6730 				*	MODS
  6731 				*		Shepardson Microsystems
  6732 				*
  6733 				*		Produce 2K version.
  6734 				*		M. Lorenzen	09/06/81
  6735 					;SPACE	4,10
  6736 D800				ORG	AFP
  6737 					;SPACE	4,10
  6738 				;	AFP - Convert ASCII to Floating Point
  6739 				*
  6740 				*	ENTRY	JSR	AFP
  6741 				*		INBUFF = line buffer pointer
  6742 				*		CIX = offset to first byte of number
  6743 				*
  6744 				*	EXIT
  6745 				*		C clear, if valid number
  6746 				*		C set, if invalid number
  6747 				*
  6748 				*	NOTES
  6749 				*		Problem: bytes wasted by check for "-", near AFP7.
  6750 				*
  6751 				*	MODS
  6752 				*		Original Author Unknown
  6753 				*		1. Bring closer to Coding Standard (object unchanged).
  6754 				*		   R. K. Nordin	11/01/83
  6755
  6756
  6757 				;AFP	=	*		;entry
  6758
  6759 				;	Initialize.
  6760
  6761 D800 20 A1 DB			JSR	SLB	;skip leading blanks
  6762
  6763 				;	Check for number.
  6764
  6765 D803 20 BB DB			JSR	TVN	;test for valid number character
  6766 D806 B0 39			BCS	AFP5	;if not number character
  6767
  6768 				;	Set initial values.
  6769
  6770 D808 A2 ED			LDX	#EEXP	;exponent
  6771 D80A A0 04			LDY	#4	;indicate 4 bytes to clear
  6772 D80C 20 48 DA			JSR	ZXLY
  6773 D80F A2 FF			LDX	#$FF
  6774 D811 86 F1			STX	DIGRT	;number of digits after decimal point
  6775 D813 20 44 DA			JSR	ZFR0	;zero FR0
  6776 D816 F0 04			BEQ	AFP2	;get first character
  6777
  6778 				;	Indicate not first character.
  6779
  6780 D818 A9 FF		AFP1	LDA	#$FF	;indicate not first character
  6781 D81A 85 F0			STA	FCHFLG	;first character flag
  6782
  6783 				;	Get next character.
  6784
  6785 D81C 20 94 DB		AFP2	JSR	GNC	;get next character
  6786 D81F B0 21			BCS	AFP6	;if character not numeric
  6787
  6788 				;	Process numeric character.
  6789
  6790 D821 48				PHA			;save digit
  6791 D822 A6 D5			LDX	FR0M		;first byte
  6792 D824 D0 11			BNE	AFP3		;if not zero
  6793
  6794 D826 20 EB DB			JSR	S0L		;shift FR0 left 1 digit
  6795 D829 68				PLA			;saved digit
  6796 D82A 05 D9			ORA	FR0M+FMPREC-1	;insert into last byte
  6797 D82C 85 D9			STA	FR0M+FMPREC-1	;update last byte
  6798
  6799 				;	Check for decimal point.
  6800
  6801 D82E A6 F1			LDX	DIGRT	;number of digits after decimal point
  6802 D830 30 E6			BMI	AFP1	;if no decimal point, process next character
  6803
  6804 				;	Increment number of digits after decimal point.
  6805
  6806 D832 E8				INX		;increment number of digits
  6807 D833 86 F1			STX	DIGRT	;number of digits after decimal point
  6808 D835 D0 E1			BNE	AFP1	;process next character
  6809
  6810 				;	Increment exponent, if necessary.
  6811
  6812 D837 68			AFP3	PLA		;clean stack
  6813 D838 A6 F1			LDX	DIGRT	;number of digits after decimal point
  6814 D83A 10 02			BPL	AFP4	;if already have decimal point
  6815
  6816 D83C E6 ED			INC	EEXP	;increment number of digits more than 9
  6817
  6818 				;	Process next character.
  6819
  6820 D83E 4C 18 D8		AFP4	JMP	AFP1	;process next character
  6821
  6822 				;	Exit.
  6823
  6824 D841 60			AFP5	RTS		;return
  6825
  6826 				;	Process non-numeric character.
  6827
  6828 D842 C9 2E		AFP6	CMP	#'.'
  6829 D844 F0 14			BEQ	AFP8	;if ".", process decimal point
  6830
  6831 D846 C9 45			CMP	#'E'
  6832 D848 F0 19			BEQ	AFP9	;if "E", process exponent
  6833
  6834 D84A A6 F0			LDX	FCHFLG	;first character flag
  6835 D84C D0 68			BNE	AFP16	;if not first character, process end of input
  6836
  6837 D84E C9 2B			CMP	#'+'
  6838 D850 F0 C6			BEQ	AFP1	;if "+", process next character
  6839
  6840 D852 C9 2D			CMP	#'-'
  6841 D854 F0 00			BEQ	AFP7	;if "-", process negative sign
  6842
  6843 				;	Process negative sign.
  6844
  6845 D856 85 EE		AFP7	STA	NSIGN	;sign of number
  6846 D858 F0 BE			BEQ	AFP1	;process next character
  6847
  6848 				;	Process decimal point.
  6849
  6850 D85A A6 F1		AFP8	LDX	DIGRT	;number of digits after decimal point
  6851 D85C 10 58			BPL	AFP16	;if already have decimal point
  6852
  6853 D85E E8				INX		;zero
  6854 D85F 86 F1			STX	DIGRT	;number of digits after decimal point
  6855 D861 F0 B5			BEQ	AFP1	;process next character
  6856
  6857 				;	Process exponent.
  6858
  6859 D863 A5 F2		AFP9	LDA	CIX	;offset to character
  6860 D865 85 EC			STA	FRX	;save offset to character
  6861 D867 20 94 DB			JSR	GNC	;get next character
  6862 D86A B0 37			BCS	AFP13	;if not numeric
  6863
  6864 				;	Process numeric character in exponent.
  6865
  6866 D86C AA			AFP10	TAX		;first character of exponent
  6867 D86D A5 ED			LDA	EEXP	;number of digits more than 9
  6868 D86F 48				PHA		;save number of digits more than 9
  6869 D870 86 ED			STX	EEXP	;first character of exponent
  6870
  6871 				;	Process second character of exponent.
  6872
  6873 D872 20 94 DB			JSR	GNC	;get next character
  6874 D875 B0 17			BCS	AFP11	;if not numeric, no second digit
  6875
  6876 D877 48				PHA		;save second digit
  6877 D878 A5 ED			LDA	EEXP	;first digit
  6878 D87A 0A				ASL	;2 times first digit
  6879 D87B 85 ED			STA	EEXP	;2 times first digit
  6880 D87D 0A				ASL	;4 times first digit
  6881 D87E 0A				ASL	;8 times first digit
  6882 D87F 65 ED			ADC	EEXP	;add 2 times first digit
  6883 D881 85 ED			STA	EEXP	;save 10 times first digit
  6884 D883 68				PLA		;saved second digit
  6885 D884 18				CLC
  6886 D885 65 ED			ADC	EEXP	;insert in exponent
  6887 D887 85 ED			STA	EEXP	;update exponent
  6888
  6889 				;	Process third character of exponent???
  6890
  6891 D889 A4 F2			LDY	CIX	;offset to third character
  6892 D88B 20 9D DB			JSR	ICX	;increment offset
  6893
  6894 D88E A5 EF		AFP11	LDA	ESIGN	;sign of exponent
  6895 D890 F0 09			BEQ	AFP12	;if no sign on exponent
  6896
  6897 				;	Process negative exponent.
  6898
  6899 D892 A5 ED			LDA	EEXP	;exponent
  6900 D894 49 FF			EOR	#$FF	;complement exponent
  6901 D896 18				CLC
  6902 D897 69 01			ADC	#1	;add 1 for 2's complement
  6903 D899 85 ED			STA	EEXP	;update exponent
  6904
  6905 				;	Add in number of digits more than 9.
  6906
  6907 D89B 68			AFP12	PLA		;saved number of digits more than 9
  6908 D89C 18				CLC
  6909 D89D 65 ED			ADC	EEXP	;add exponent
  6910 D89F 85 ED			STA	EEXP	;update exponent
  6911 D8A1 D0 13			BNE	AFP16	;process end of input
  6912
  6913 				;	Process non-numeric in exponent.
  6914
  6915 D8A3 C9 2B		AFP13	CMP	#'+'
  6916 D8A5 F0 06			BEQ	AFP14	;if "+", process next character
  6917
  6918 D8A7 C9 2D			CMP	#'-'
  6919 D8A9 D0 07			BNE	AFP15	;if not "-", ???
  6920
  6921 D8AB 85 EF			STA	ESIGN	;save sign of exponent
  6922
  6923 				;	Process next character.
  6924
  6925 D8AD 20 94 DB		AFP14	JSR	GNC	;get next character
  6926 D8B0 90 BA			BCC	AFP10	;if numeric, process numeric character
  6927
  6928 				;	Process other non-numeric in exponent.
  6929
  6930 D8B2 A5 EC		AFP15	LDA	FRX	;saved offset
  6931 D8B4 85 F2			STA	CIX	;restore offset
  6932
  6933 				;	Process end of input.
  6934
  6935 D8B6 C6 F2		AFP16	DEC	CIX	;decrement offset
  6936 D8B8 A5 ED			LDA	EEXP	;exponent
  6937 D8BA A6 F1			LDX	DIGRT	;number of digits after decimal point
  6938 D8BC 30 05			BMI	AFP17	;if no decimal point
  6939
  6940 D8BE F0 03			BEQ	AFP17	;if no digits after decimal point
  6941
  6942 D8C0 38				SEC
  6943 D8C1 E5 F1			SBC	DIGRT	;subtract number of digits after decimal point
  6944
  6945 D8C3 48			AFP17	PHA		;save adjusted exponent
  6946 D8C4 2A				ROL	;set C with sign of exponent
  6947 D8C5 68				PLA		;saved adjusted exponent
  6948 D8C6 6A				ROR	;shift right
  6949 D8C7 85 ED			STA	EEXP	;save power of 100
  6950 D8C9 90 03			BCC	AFP18	;if no carry, process even number
  6951
  6952 D8CB 20 EB DB			JSR	S0L	;shift FR0 left 1 digit
  6953
  6954 D8CE A5 ED		AFP18	LDA	EEXP	;exponent
  6955 D8D0 18				CLC
  6956 D8D1 69 44			ADC	#$40+4	;add bias plus 4 for normalization
  6957 D8D3 85 D4			STA	FR0	;save exponent
  6958
  6959 D8D5 20 00 DC			JSR	NORM	;normalize number
  6960 D8D8 B0 0B			BCS	AFP20	;if error
  6961
  6962 				;	Check sign of number.
  6963
  6964 D8DA A6 EE			LDX	NSIGN	;sign of number
  6965 D8DC F0 06			BEQ	AFP19	;if sign of number not negative
  6966
  6967 				;	Process negative number.
  6968
  6969 D8DE A5 D4			LDA	FR0	;first byte of mantissa
  6970 D8E0 09 80			ORA	#$80	;indicate negative
  6971 D8E2 85 D4			STA	FR0	;update first byte of mantissa
  6972
  6973 				;	Exit.
  6974
  6975 D8E4 18			AFP19	CLC		;indicate valid number
  6976
  6977 D8E5 60			AFP20	RTS		;return
  6978 					;SPACE	4,10
  6979 D8E6				ORG	FASC
  6980 					;SPACE	4,10
  6981 				;	FASC - Convert Floating Point Number to ASCII
  6982 				*
  6983 				*	ENTRY	JSR	FASC
  6984 				*		FR0 - FR0+5 = number to convert
  6985 				*
  6986 				*	EXIT
  6987 				*		INBUFF = pointer to start of number
  6988 				*		High order bit of last charecter set
  6989 				*
  6990 				*	MODS
  6991 				*		Original Author Unknown
  6992 				*		1. Bring closer to Coding Standard (object unchanged).
  6993 				*		   R. K. Nordin	11/01/83
  6994
  6995
  6996 				;FASC	=	*	;entry
  6997
  6998 				;	Initialize.
  6999
  7000 D8E6 20 51 DA			JSR	ILP	;initialize line buffer pointer
  7001 D8E9 A9 30			LDA	#'0'
  7002 D8EB 8D 7F 05			STA	LBPR2	;put "0" in front of line buffer
  7003
  7004 				;	Check for E format required.
  7005
  7006 D8EE A5 D4			LDA	FR0	;exponent
  7007 D8F0 F0 28			BEQ	FASC2	;if exponent zero, number zero
  7008
  7009 D8F2 29 7F			AND	#$7F	;clear sign
  7010 D8F4 C9 3F			CMP	#$40-1	;bias-1
  7011 D8F6 90 28			BCC	FASC3	;if exponent < bias-1, E format required
  7012
  7013 D8F8 C9 45			CMP	#$40+5	;bias+5
  7014 D8FA B0 24			BCS	FASC3	;if >= bias+5, E format required
  7015
  7016 				;	Process E format not required.
  7017
  7018 D8FC 38				SEC
  7019 D8FD E9 3F			SBC	#$40-1	;subtract bias-1, yielding decimal position
  7020 D8FF 20 70 DC			JSR	C0A	;convert FR0 to ASCII
  7021 D902 20 A4 DC			JSR	FNZ	;find last non-zero character
  7022 D905 09 80			ORA	#$80	;set high order bit
  7023 D907 9D 80 05			STA	LBUFF,X	;update last character
  7024 D90A AD 80 05			LDA	LBUFF	;first character
  7025 D90D C9 2E			CMP	#'.'
  7026 D90F F0 03			BEQ	FASC1	;if decimal point
  7027
  7028 D911 4C 88 D9			JMP	FASC10
  7029
  7030 D914 20 C1 DC		FASC1	JSR	DLP	;decrement line buffer pointer
  7031 D917 4C 9C D9			JMP	FASC11	;perform final adjustment
  7032
  7033 				;	Process zero.
  7034
  7035 D91A A9 B0		FASC2	LDA	#$80+'0'	;"0" with high order bit set
  7036 D91C 8D 80 05			STA	LBUFF		;put zero character in line buffer
  7037 D91F 60				RTS			;return
  7038
  7039 				;	Process E format required.
  7040
  7041 D920 A9 01		FASC3	LDA	#1	;GET DECIMAL POSITION???
  7042 D922 20 70 DC			JSR	C0A	;convert FR0 to ASCII
  7043 D925 20 A4 DC			JSR	FNZ	;find last non-zero character
  7044 D928 E8				INX		;increment offset to last character
  7045 D929 86 F2			STX	CIX	;save offset to last character
  7046
  7047 				;	Adjust exponent.
  7048
  7049 D92B A5 D4			LDA	FR0	;exponent
  7050 D92D 0A				ASL	;double exponent
  7051 D92E 38				SEC
  7052 D92F E9 80			SBC	#$40*2	;subtract 2 times bias
  7053
  7054 				;	Check first character for "0".
  7055
  7056 D931 AE 80 05			LDX	LBUFF	;first character
  7057 D934 E0 30			CPX	#'0'
  7058 D936 F0 17			BEQ	FASC5	;if "0"
  7059
  7060 				;	Put decimal after first character.
  7061
  7062 D938 AE 81 05			LDX	LBUFF+1	;second character
  7063 D93B AC 82 05			LDY	LBUFF+2	;decimal point
  7064 D93E 8E 82 05			STX	LBUFF+2	;decimal point
  7065 D941 8C 81 05			STY	LBUFF+1	;third character
  7066 D944 A6 F2			LDX	CIX	;offset
  7067 D946 E0 02			CPX	#2	;former offset to decimal point
  7068 D948 D0 02			BNE	FASC4	;if offset pointed to second character
  7069
  7070 D94A E6 F2			INC	CIX	;increment offset
  7071
  7072 D94C 18			FASC4	CLC
  7073 D94D 69 01			ADC	#1	;adjust exponent for movement of decimal point
  7074
  7075 				;	Convert exponent to ASCII.
  7076
  7077 D94F 85 ED		FASC5	STA	EEXP	;exponent
  7078 D951 A9 45			LDA	#'E'
  7079 D953 A4 F2			LDY	CIX	;offset
  7080 D955 20 9F DC			JSR	SAL	;store ASCII character in line buffer
  7081 D958 84 F2			STY	CIX	;save offset
  7082 D95A A5 ED			LDA	EEXP	;exponent
  7083 D95C 10 0B			BPL	FASC6	;if exponent positive
  7084
  7085 D95E A9 00			LDA	#0
  7086 D960 38				SEC
  7087 D961 E5 ED			SBC	EEXP	;complement exponent
  7088 D963 85 ED			STA	EEXP	;update exponent
  7089 D965 A9 2D			LDA	#'-'
  7090 D967 D0 02			BNE	FASC7	;store "-"
  7091
  7092 D969 A9 2B		FASC6	LDA	#'+'
  7093
  7094 D96B 20 9F DC		FASC7	JSR	SAL	;store ASCII character in line buffer
  7095 D96E A2 00			LDX	#0	;initial number of 10's
  7096 D970 A5 ED			LDA	EEXP	;exponent
  7097
  7098 D972 38			FASC8	SEC
  7099 D973 E9 0A			SBC	#10	;subtract 10
  7100 D975 90 03			BCC	FASC9	;if < 0, done
  7101
  7102 D977 E8				INX		;increment number of 10's
  7103 D978 D0 F8			BNE	FASC8	;continue
  7104
  7105 D97A 18			FASC9	CLC
  7106 D97B 69 0A			ADC	#10	;add back 10
  7107 D97D 48				PHA		;save remainder
  7108 D97E 8A				TXA		;number of 10's
  7109 D97F 20 9D DC			JSR	SNL	;store number in line buffer
  7110 D982 68				PLA		;saved remainder
  7111 D983 09 80			ORA	#$80	;set high order bit
  7112 D985 20 9D DC			JSR	SNL	;store number in line buffer
  7113
  7114 				;	Perform final adjustment.
  7115
  7116 D988 AD 80 05		FASC10	LDA	LBUFF	;first character
  7117 D98B C9 30			CMP	#'0'
  7118 D98D D0 0D			BNE	FASC11	;if not "0", ???
  7119
  7120 				;	Increment pointer to point to non-zero character.
  7121
  7122 D98F 18				CLC
  7123 D990 A5 F3			LDA	INBUFF		;line buffer pointer
  7124 D992 69 01			ADC	#1		;add 1
  7125 D994 85 F3			STA	INBUFF		;update line buffer pointer
  7126 D996 A5 F4			LDA	INBUFF+1
  7127 D998 69 00			ADC	#0
  7128 D99A 85 F4			STA	INBUFF+1
  7129
  7130 				;	Check for positive exponent.
  7131
  7132 D99C A5 D4		FASC11	LDA	FR0		;exponent
  7133 D99E 10 09			BPL	FASC12		;if exponent positive, exit
  7134
  7135 				;	Process negative exponent.
  7136
  7137 D9A0 20 C1 DC			JSR	DLP		;decrement line buffer pointer
  7138 D9A3 A0 00			LDY	#0		;offset to first character
  7139 D9A5 A9 2D			LDA	#'-'
  7140 D9A7 91 F3			STA	(INBUFF),Y	;put "-" in line buffer
  7141
  7142 				;	Exit.
  7143
  7144 D9A9 60			FASC12	RTS			;return
  7145 					;SPACE	4,10
  7146 D9AA				ORG	IFP
  7147 					;SPACE	4,10
  7148 				;	IFP - Convert Integer to Floating Point Number
  7149 				*
  7150 				*	ENTRY	JSR	IFP
  7151 				*		FR0 - FR0+1 = integer to convert
  7152 				*
  7153 				*	EXIT
  7154 				*		FR0 - FR0+5 = floating point number
  7155 				*
  7156 				*	MODS
  7157 				*		Original Author Unknown
  7158 				*		1. Bring closer to Coding Standard (object unchanged).
  7159 				*		   R. K. Nordin	11/01/83
  7160
  7161
  7162 				;IFP	=	*	;entry
  7163
  7164 				;	Initialize.
  7165
  7166 D9AA A5 D4			LDA	FR0		;low integer
  7167 D9AC 85 F8			STA	ZTEMP4+1	;save low integer
  7168 D9AE A5 D5			LDA	FR0+1		;high integer
  7169 D9B0 85 F7			STA	ZTEMP4		;save high integer
  7170 D9B2 20 44 DA			JSR	ZFR0		;zero FR0
  7171
  7172 				;	Convert to floating point.
  7173
  7174 D9B5 F8				SED
  7175 D9B6 A0 10			LDY	#16		;number of bits in integer
  7176
  7177 D9B8 06 F8		IFP1	ASL	ZTEMP4+1	;shift integer
  7178 D9BA 26 F7			ROL	ZTEMP4		;shift integer, setting C if bit present
  7179
  7180 D9BC A2 03			LDX	#3		;offset to last possible byte of number
  7181
  7182 D9BE B5 D4		IFP2	LDA	FR0,X		;byte of number
  7183 D9C0 75 D4			ADC	FR0,X		;double byte, adding in carry
  7184 D9C2 95 D4			STA	FR0,X		;update byte of number
  7185 D9C4 CA				DEX
  7186 D9C5 D0 F7			BNE	IFP2		;if not done
  7187
  7188 D9C7 88				DEY			;decrement count of integer bits
  7189 D9C8 D0 EE			BNE	IFP1		;if not done
  7190
  7191 D9CA D8				CLD
  7192
  7193 				;	Set exponent.
  7194
  7195 D9CB A9 42			LDA	#$40+2		;indicate decimal after last digit
  7196 D9CD 85 D4			STA	FR0		;exponent
  7197
  7198 				;	Exit.
  7199
  7200 D9CF 4C 00 DC			JMP	NORM		;normalize, return
  7201 					;SPACE	4,10
  7202 D9D2				ORG	FPI
  7203 					;SPACE	4,10
  7204 				;	FPI - Convert Floating Point Number to Integer
  7205 				*
  7206 				*	ENTRY	JSR	FPI
  7207 				*		FR0 - FR0+5 = floating point number
  7208 				*
  7209 				*	EXIT
  7210 				*		C set, if error
  7211 				*		C clear, if no error
  7212 				*		FR0 - FR0+1 = integer
  7213 				*
  7214 				*	MODS
  7215 				*		Original Author Unknown
  7216 				*		1. Bring closer to Coding Standard (object unchanged).
  7217 				*		   R. K. Nordin	11/01/83
  7218
  7219
  7220 				;FPI	=	*		;entry
  7221
  7222 				;	Initialize.
  7223
  7224 D9D2 A9 00			LDA	#0
  7225 D9D4 85 F7			STA	ZTEMP4		;zero integer
  7226 D9D6 85 F8			STA	ZTEMP4+1
  7227
  7228 				;	Check exponent.
  7229
  7230 D9D8 A5 D4			LDA	FR0		;exponent
  7231 D9DA 30 66			BMI	FPI4		;if sign of exponent is negative, error
  7232
  7233 D9DC C9 43			CMP	#$40+3		;bias+3
  7234 D9DE B0 62			BCS	FPI4		;if number too big, error
  7235
  7236 D9E0 38				SEC
  7237 D9E1 E9 40			SBC	#$40		;subtract bias
  7238 D9E3 90 3F			BCC	FPI2		;if number less than 1, test for round
  7239
  7240 				;	Compute number of digits to convert.
  7241
  7242 D9E5 69 00			ADC	#0		;add carry
  7243 D9E7 0A				ASL		;2 times exponent-$40+1
  7244 D9E8 85 F5			STA	ZTEMP1		;number of digits to convert
  7245
  7246 				;	Convert.
  7247
  7248 D9EA 20 5A DA		FPI1	JSR	SIL		;shift integer left
  7249 D9ED B0 53			BCS	FPI4		;if number too big, error
  7250
  7251 D9EF A5 F7			LDA	ZTEMP4		;2 times integer
  7252 D9F1 85 F9			STA	ZTEMP3		;save 2 times integer
  7253 D9F3 A5 F8			LDA	ZTEMP4+1
  7254 D9F5 85 FA			STA	ZTEMP3+1
  7255 D9F7 20 5A DA			JSR	SIL		;shift integer left
  7256 D9FA B0 46			BCS	FPI4		;if number too big, error
  7257
  7258 D9FC 20 5A DA			JSR	SIL		;shift integer left
  7259 D9FF B0 41			BCS	FPI4		;if number too big, error
  7260
  7261 DA01 18				CLC
  7262 DA02 A5 F8			LDA	ZTEMP4+1	;8 times integer
  7263 DA04 65 FA			ADC	ZTEMP3+1	;add 2 times integer
  7264 DA06 85 F8			STA	ZTEMP4+1	;10 times integer
  7265 DA08 A5 F7			LDA	ZTEMP4
  7266 DA0A 65 F9			ADC	ZTEMP3
  7267 DA0C 85 F7			STA	ZTEMP4
  7268 DA0E B0 32			BCS	FPI4		;if overflow???, error
  7269
  7270 DA10 20 B9 DC			JSR	GND		;get next digit
  7271 DA13 18				CLC
  7272 DA14 65 F8			ADC	ZTEMP4+1	;insert digit in ???
  7273 DA16 85 F8			STA	ZTEMP4+1	;update ???
  7274 DA18 A5 F7			LDA	ZTEMP4		;???
  7275 DA1A 69 00			ADC	#0		;add carry
  7276 DA1C B0 24			BCS	FPI4		;if overflow, error
  7277
  7278 DA1E 85 F7			STA	ZTEMP4		;update ???
  7279 DA20 C6 F5			DEC	ZTEMP1		;decrement count of digits to convert
  7280 DA22 D0 C6			BNE	FPI1		;if not done
  7281
  7282 				;	Check for round required.
  7283
  7284 DA24 20 B9 DC		FPI2	JSR	GND		;get next digit
  7285 DA27 C9 05			CMP	#5
  7286 DA29 90 0D			BCC	FPI3		;if digit less than 5, do not round
  7287
  7288 				;	Round.
  7289
  7290 DA2B 18				CLC
  7291 DA2C A5 F8			LDA	ZTEMP4+1
  7292 DA2E 69 01			ADC	#1		;add 1 to round
  7293 DA30 85 F8			STA	ZTEMP4+1
  7294 DA32 A5 F7			LDA	ZTEMP4
  7295 DA34 69 00			ADC	#0
  7296 DA36 85 F7			STA	ZTEMP4
  7297
  7298 				;	Return integer.
  7299
  7300 DA38 A5 F8		FPI3	LDA	ZTEMP4+1	;low integer
  7301 DA3A 85 D4			STA	FR0		;low integer result
  7302 DA3C A5 F7			LDA	ZTEMP4		;high integer
  7303 DA3E 85 D5			STA	FR0+1		;high integer result
  7304 DA40 18				CLC			;indicate success
  7305 DA41 60				RTS			;return
  7306
  7307 				;	Return error.
  7308
  7309 DA42 38			FPI4	SEC			;indicate error
  7310 DA43 60				RTS			;return
  7311 				;	;SPACE	4,10
  7312 DA44				ORG	ZFR0
  7313 					;SPACE	4,10
  7314 				;	ZFR0 - Zero FR0
  7315 				*
  7316 				*	ENTRY	JSR	ZFR0
  7317 				*
  7318 				*	MODS
  7319 				*		Original Author Unknown
  7320 				*		1. Bring closer to Coding Standard (object unchanged).
  7321 				*		   R. K. Nordin	11/01/83
  7322
  7323
  7324 				;ZFR0	=	*	;entry
  7325
  7326 DA44 A2 D4			LDX	#FR0	;indicate zero FR0
  7327 				;	JMP	ZF1	;zero floating point number, return
  7328 					;SPACE	4,10
  7329 DA46				ORG	ZF1
  7330 					;SPACE	4,10
  7331 				;	ZF1 - Zero Floating Point Number
  7332 				*
  7333 				*	ENTRY	JSR	ZF1
  7334 				*		X = offset to register
  7335 				*
  7336 				*	MODS
  7337 				*		Original Author Unknown
  7338 				*		1. Bring closer to Coding Standard (object unchanged).
  7339 				*		   R. K. Nordin	11/01/83
  7340
  7341
  7342 				;ZF1	=	*	;entry
  7343
  7344 DA46 A0 06			LDY	#6	;number of bytes to zero
  7345 				;	JMP	ZXLY	;zero bytes, return
  7346 					;SPACE	4,10
  7347 				;	ZXLY - Zero Page Zero Location X for Length Y
  7348 				*
  7349 				*	ENTRY	JSR	ZXLY
  7350 				*		X = offset
  7351 				*		Y = length
  7352 				*
  7353 				*	MODS
  7354 				*		Original Author Unknown
  7355 				*		1. Bring closer to Coding Standard (object unchanged).
  7356 				*		   R. K. Nordin	11/01/83
  7357
  7358
  7359 = DA48			ZXLY	=	*	;entry
  7360
  7361 DA48 A9 00			LDA	#0
  7362
  7363 DA4A 95 00		ZXLY1	STA	$0000,X	;zero byte
  7364 DA4C E8				INX
  7365 DA4D 88				DEY
  7366 DA4E D0 FA			BNE	ZXLY1	;if not done
  7367
  7368 DA50 60				RTS		;return
  7369 					;SPACE	4,10
  7370 				;	ILP - Initialize Line Buffer Pointer
  7371 				*
  7372 				*	ENTRY	JSR	ILP
  7373 				*
  7374 				*	EXIT
  7375 				*		INBUFF - INBUFF+1 = line buffer address
  7376 				*
  7377 				*	MODS
  7378 				*		Original Author Unknown
  7379 				*		1. Bring closer to Coding Standard (object unchanged).
  7380 				*		   R. K. Nordin	11/01/83
  7381
  7382
  7383 = DA51			ILP	=	*		;entry
  7384 DA51 A9 05			LDA	#>LBUFF	;high buffer address
  7385 DA53 85 F4			STA	INBUFF+1	;high line buffer pointer
  7386 DA55 A9 80			LDA	#<LBUFF	;low buffer address
  7387 DA57 85 F3			STA	INBUFF		;low line buffer pointer
  7388 DA59 60				RTS			;return
  7389 					;SPACE	4,10
  7390 				;	SIL - Shift Integer Left
  7391 				*
  7392 				*	ENTRY	JSR	SIL
  7393 				*		ZTEMP4 - ZTEMP4+1 = number (high, low) to shift
  7394 				*
  7395 				*	EXIT
  7396 				*		ZTEMP4 - ZTEMP4+1 shifted left 1
  7397 				*
  7398 				*	MODS
  7399 				*		Original Author Unknown
  7400 				*		1. Bring closer to Coding Standard (object unchanged).
  7401 				*		   R. K. Nordin	11/01/83
  7402
  7403
  7404 = DA5A			SIL	=	*		;entry
  7405 DA5A 18				CLC
  7406 DA5B 26 F8			ROL	ZTEMP4+1	;shift low
  7407 DA5D 26 F7			ROL	ZTEMP4		;shift high
  7408 DA5F 60				RTS			;return
  7409 					;SPACE	4,10
  7410 DA60				ORG	FSUB
  7411 					;SPACE	4,10
  7412 				;	FSUB - Perform Floating Point Subtract
  7413 				*
  7414 				*	FSUB subtracts FR1 from FR0.
  7415 				*
  7416 				*	ENTRY	JSR	FSUB
  7417 				*		FR0 - FR0+5 = minuend
  7418 				*		FR1 - FR1+5 = subtrahend
  7419 				*
  7420 				*	EXIT
  7421 				*		C set, if error
  7422 				*		C clear, if no error
  7423 				*		FR0 - FR0+5 = difference
  7424 				*
  7425 				*	MODS
  7426 				*		Original Author Unknown
  7427 				*		1. Bring closer to Coding Standard (object unchanged).
  7428 				*		   R. K. Nordin	11/01/83
  7429
  7430
  7431 				;FSUB	=	*	;entry
  7432
  7433 				;	Complement sign of subtrahend and add.
  7434
  7435 DA60 A5 E0			LDA	FR1	;subtrahend exponent
  7436 DA62 49 80			EOR	#$80	;complement sign of subtrahend
  7437 DA64 85 E0			STA	FR1	;update subtrahend exponent
  7438 				;	JMP	FADD	;perform add, return
  7439 					;SPACE	4,10
  7440 DA66				ORG	FADD
  7441 					;SPACE	4,10
  7442 				;	FADD - Perform Floating Point Add
  7443 				*
  7444 				*	ENTRY	JSR	FADD
  7445 				*		FR0 - FR0+5 = augend
  7446 				*		FR1 - FR1+5 = addend
  7447 				*
  7448 				*	EXIT
  7449 				*		C set, if error
  7450 				*		C clear, if no error
  7451 				*		FR0 - FR0+5 = sum
  7452 				*
  7453 				*	MODS
  7454 				*		Original Author Unknown
  7455 				*		1. Bring closer to Coding Standard (object unchanged).
  7456 				*		   R. K. Nordin	11/01/83
  7457
  7458
  7459 				;FADD	=	*	;entry
  7460
  7461 				;	Initialize.
  7462
  7463 DA66 A5 E0		FADD1	LDA	FR1	;exponent of addend
  7464 DA68 29 7F			AND	#$7F	;clear sign of addend mantissa
  7465 DA6A 85 F7			STA	ZTEMP4	;save addend exponent
  7466 DA6C A5 D4			LDA	FR0	;exponent of augend
  7467 DA6E 29 7F			AND	#$7F	;clear sign of augend mantissa
  7468 DA70 38				SEC
  7469 DA71 E5 F7			SBC	ZTEMP4	;subtract addend exponent
  7470 DA73 10 10			BPL	FADD3	;if augend exponent >= addend exponent
  7471
  7472 				;	Swap augend and addend.
  7473
  7474 DA75 A2 05			LDX	#FPREC-1	;offset to last byte
  7475
  7476 DA77 B5 D4		FADD2	LDA	FR0,X		;byte of augend
  7477 DA79 B4 E0			LDY	FR1,X		;byte of addend
  7478 DA7B 95 E0			STA	FR1,X		;move byte of augend to addend
  7479 DA7D 98				TYA
  7480 DA7E 95 D4			STA	FR0,X		;move byte of addend to augend
  7481 DA80 CA				DEX
  7482 DA81 10 F4			BPL	FADD2		;if not done
  7483
  7484 DA83 30 E1			BMI	FADD1		;re-initialize
  7485
  7486 				;	Check alignment.
  7487
  7488 DA85 F0 07		FADD3	BEQ	FADD4	;if exponent difference zero, already aligned
  7489
  7490 DA87 C9 05			CMP	#FMPREC	;mantissa precision
  7491 DA89 B0 19			BCS	FADD6	;if exponent difference < mantissa precision
  7492
  7493 				;	Align.
  7494
  7495 DA8B 20 3E DC			JSR	S1R	;shift FR1 right
  7496
  7497 				;	Check for like signs of mantissas.
  7498
  7499 DA8E F8			FADD4	SED
  7500 DA8F A5 D4			LDA	FR0	;augend exponent
  7501 DA91 45 E0			EOR	FR1	;EOR with addend exponent
  7502 DA93 30 1E			BMI	FADD8	;if signs differ, subtract
  7503
  7504 				;	Add.
  7505
  7506 DA95 A2 04			LDX	#FMPREC-1	;offset to last byte of mantissa
  7507 DA97 18				CLC
  7508
  7509 DA98 B5 D5		FADD5	LDA	FR0M,X		;byte of augend mantissa
  7510 DA9A 75 E1			ADC	FR1M,X		;add byte of addend mantissa
  7511 DA9C 95 D5			STA	FR0M,X		;update byte of result mantissa
  7512 DA9E CA				DEX
  7513 DA9F 10 F7			BPL	FADD5		;if not done
  7514
  7515 DAA1 D8				CLD
  7516 DAA2 B0 03			BCS	FADD7		;if carry, process carry
  7517
  7518 				;	Exit.
  7519
  7520 DAA4 4C 00 DC		FADD6	JMP	NORM		;normalize, return
  7521
  7522 				;	Process carry.
  7523
  7524 DAA7 A9 01		FADD7	LDA	#1		;indicate shift 1
  7525 DAA9 20 3A DC			JSR	S0R		;shift FR0 right
  7526 DAAC A9 01			LDA	#1		;carry
  7527 DAAE 85 D5			STA	FR0M		;set carry in result
  7528
  7529 				;	Exit.
  7530
  7531 DAB0 4C 00 DC			JMP	NORM		;normalize, return
  7532
  7533 				;	Subtract.
  7534
  7535 DAB3 A2 04		FADD8	LDX	#FMPREC-1	;offset to last byte of mantissa
  7536 DAB5 38				SEC
  7537
  7538 DAB6 B5 D5		FADD9	LDA	FR0M,X		;byte of augend mantissa
  7539 DAB8 F5 E1			SBC	FR1M,X		;subtract byte of addend mantissa
  7540 DABA 95 D5			STA	FR0M,X		;update byte of result mantissa
  7541 DABC CA				DEX
  7542 DABD 10 F7			BPL	FADD9		;if not done
  7543
  7544 DABF 90 04			BCC	FADD10		;if borrow, process borrow
  7545
  7546 				;	Exit.
  7547
  7548 DAC1 D8				CLD
  7549 DAC2 4C 00 DC			JMP	NORM		;normalize ???, return
  7550
  7551 				;	Process borrow.
  7552
  7553 DAC5 A5 D4		FADD10	LDA	FR0		;result exponent
  7554 DAC7 49 80			EOR	#$80		;complement sign of result
  7555 DAC9 85 D4			STA	FR0		;update result exponent
  7556
  7557 DACB 38				SEC
  7558 DACC A2 04			LDX	#FMPREC-1	;offset to last byte of mantissa
  7559
  7560 DACE A9 00		FADD11	LDA	#0
  7561 DAD0 F5 D5			SBC	FR0M,X		;complement byte of result mantissa
  7562 DAD2 95 D5			STA	FR0M,X		;update byte of result mantissa
  7563 DAD4 CA				DEX
  7564 DAD5 10 F7			BPL	FADD11		;if not done
  7565
  7566 				;	Exit.
  7567
  7568 DAD7 D8				CLD
  7569 DAD8 4C 00 DC			JMP	NORM		;normalize ???, return
  7570 					;SPACE	4,10
  7571 DADB				ORG	FMUL
  7572 					;SPACE	4,10
  7573 				;	FMUL - Perform Floating Point Multiply
  7574 				*
  7575 				*	ENTRY	JSR	FMUL
  7576 				*		FR0 - FR0+5 = multiplicand
  7577 				*		FR1 - FR1+5 = multiplier
  7578 				*
  7579 				*	EXIT
  7580 				*		C set, if error
  7581 				*		C clear, if no error
  7582 				*		FR0 - FR0+5 = product
  7583 				*
  7584 				*	MODS
  7585 				*		Original Author Unknown
  7586 				*		1. Bring closer to Coding Standard (object unchanged).
  7587 				*		   R. K. Nordin	11/01/83
  7588
  7589
  7590 				;FMUL	=	*	;entry
  7591
  7592 				;	Check for zero multiplicand.
  7593
  7594 DADB A5 D4			LDA	FR0	;multiplicand exponent
  7595 DADD F0 45			BEQ	FMUL8	;if multiplicand exponent zero, result is zero
  7596
  7597 				;	Check for zero multiplier.
  7598
  7599 DADF A5 E0			LDA	FR1	;multiplier exponent
  7600 DAE1 F0 3E			BEQ	FMUL7	;if multiplier exponent zero, result is zero
  7601
  7602 DAE3 20 CF DC			JSR	SUE	;set up exponent
  7603 DAE6 38				SEC
  7604 DAE7 E9 40			SBC	#$40	;subtract bias
  7605 DAE9 38				SEC		;add 1
  7606 DAEA 65 E0			ADC	FR1	;add multiplier exponent
  7607 DAEC 30 38			BMI	FMUL9	;if overflow, error
  7608
  7609 				;	Set up.
  7610
  7611 DAEE 20 E0 DC			JSR	SUP	;set up
  7612
  7613 				;	Compute number of times to add multiplicand.
  7614
  7615 DAF1 A5 DF		FMUL1	LDA	FRE+FPREC-1	;last byte of FRE
  7616 DAF3 29 0F			AND	#$0F		;extract low order digit
  7617 DAF5 85 F6			STA	ZTEMP1+1
  7618
  7619 				;	Check for completion.
  7620
  7621 DAF7 C6 F6		FMUL2	DEC	ZTEMP1+1	;decrement counter
  7622 DAF9 30 06			BMI	FMUL3		;if done
  7623
  7624 DAFB 20 01 DD			JSR	FRA10		;add FR1 to FR0
  7625 DAFE 4C F7 DA			JMP	FMUL2		;continue
  7626
  7627 				;	Compute number of times to add 10 times multiplicand.
  7628
  7629 DB01 A5 DF		FMUL3	LDA	FRE+FPREC-1	;last byte of FRE
  7630 DB03 4A				LSR
  7631 DB04 4A				LSR
  7632 DB05 4A				LSR
  7633 DB06 4A				LSR		;high order digit
  7634 DB07 85 F6			STA	ZTEMP1+1
  7635
  7636 				;	Check for completion.
  7637
  7638 DB09 C6 F6		FMUL4	DEC	ZTEMP1+1	;decrement counter
  7639 DB0B 30 06			BMI	FMUL5		;if done
  7640
  7641 DB0D 20 05 DD			JSR	FRA20		;add FR2 to FR0
  7642 DB10 4C 09 DB			JMP	FMUL4		;continue
  7643
  7644 				;	Set up for next set of adds.
  7645
  7646 DB13 20 62 DC		FMUL5	JSR	S0ER		;shift FR0/FRE right
  7647
  7648 				;	Decrement counter and test for completion.
  7649
  7650 DB16 C6 F5			DEC	ZTEMP1		;decrement
  7651 DB18 D0 D7			BNE	FMUL1		;if not done
  7652
  7653 				;	Set exponent.
  7654
  7655 DB1A A5 ED		FMUL6	LDA	EEXP		;exponent
  7656 DB1C 85 D4			STA	FR0		;result exponent
  7657 DB1E 4C 04 DC			JMP	N0E		;normalize, return
  7658
  7659 				;	Return zero result.
  7660
  7661 DB21 20 44 DA		FMUL7	JSR	ZFR0		;zero FR0
  7662
  7663 				;	Return no error.
  7664
  7665 DB24 18			FMUL8	CLC			;indicate no error
  7666 DB25 60				RTS			;return
  7667
  7668 				;	Return error.
  7669
  7670 DB26 38			FMUL9	SEC			;indicate error
  7671 DB27 60				RTS			;return
  7672 					;SPACE	4,10
  7673 DB28				ORG	FDIV
  7674 					;SPACE	4,10
  7675 				;	FDIV - Perform Floating Point Divide
  7676 				*
  7677 				*	ENTRY	JSR	FDIV
  7678 				*		FR0 - FR0+5 = dividend
  7679 				*		FR1 - FR1+5 = divisor
  7680 				*
  7681 				*	EXIT
  7682 				*		C clear, if no error
  7683 				*		C set, if error
  7684 				*		FR0 - FR0+5 = quotient
  7685 				*
  7686 				*	MODS
  7687 				*		Original Author Unknown
  7688 				*		1. Bring closer to Coding Standard (object unchanged).
  7689 				*		   R. K. Nordin	11/01/83
  7690
  7691
  7692 				;FDIV	=	*	;entry
  7693
  7694 				;	Check for zero divisor.
  7695
  7696 DB28 A5 E0			LDA	FR1	;divisor exponent
  7697 DB2A F0 FA			BEQ	FMUL9	;if divisor exponent zero, error
  7698
  7699 				;	Check for zero dividend.
  7700
  7701 DB2C A5 D4			LDA	FR0	;dividend exponent
  7702 DB2E F0 F4			BEQ	FMUL8	;if dividend exponent zero, result is zero
  7703
  7704 DB30 20 CF DC			JSR	SUE	;set up exponent
  7705 DB33 38				SEC
  7706 DB34 E5 E0			SBC	FR1	;subtract divisor exponent
  7707 DB36 18				CLC
  7708 DB37 69 40			ADC	#$40	;add bias
  7709 DB39 30 EB			BMI	FMUL9	;if overflow, error
  7710
  7711 DB3B 20 E0 DC			JSR	SUP	;set up
  7712 DB3E E6 F5			INC	ZTEMP1	;divide requires extra pass
  7713 DB40 4C 4E DB			JMP	FDIV3	;skip shift
  7714
  7715 				;	Shift FR0/FRE left one byte.
  7716
  7717 DB43 A2 00		FDIV1	LDX	#0		;offset to first byte to shift
  7718
  7719 DB45 B5 D5		FDIV2	LDA	FR0+1,X		;byte to shift
  7720 DB47 95 D4			STA	FR0,X		;byte of destination
  7721 DB49 E8				INX
  7722 DB4A E0 0C			CPX	#FMPREC*2+2	;number of bytes to shift
  7723 DB4C D0 F7			BNE	FDIV2		;if not done
  7724
  7725 				;	Subtract 2 times divisor from dividend.
  7726
  7727 DB4E A0 05		FDIV3	LDY	#FPREC-1	;offset to last byte
  7728 DB50 38				SEC
  7729 DB51 F8				SED
  7730
  7731 DB52 B9 DA 00		FDIV4	LDA	FRE,Y		;byte of dividend
  7732 DB55 F9 E6 00			SBC	FR2,Y		;subtract byte of 2*divisor
  7733 DB58 99 DA 00			STA	FRE,Y		;update byte of dividend
  7734 DB5B 88				DEY
  7735 DB5C 10 F4			BPL	FDIV4		;if not done
  7736
  7737 DB5E D8				CLD
  7738 DB5F 90 04			BCC	FDIV5		;if difference < 0
  7739
  7740 DB61 E6 D9			INC	QTEMP		;increment
  7741 DB63 D0 E9			BNE	FDIV3		;continue
  7742
  7743 				;	Adjust.
  7744
  7745 DB65 20 0F DD		FDIV5	JSR	FRA2E	;add FR2 to FR0
  7746
  7747 				;	Shift last byte of quotient left one digit.
  7748
  7749 DB68 06 D9			ASL	QTEMP
  7750 DB6A 06 D9			ASL	QTEMP
  7751 DB6C 06 D9			ASL	QTEMP
  7752 DB6E 06 D9			ASL	QTEMP
  7753
  7754 				;	Subtract divisor from dividend.
  7755
  7756 DB70 A0 05		FDIV6	LDY	#FPREC-1	;offset to last byte
  7757 DB72 38				SEC
  7758 DB73 F8				SED
  7759
  7760 DB74 B9 DA 00		FDIV7	LDA	FRE,Y		;byte of dividend
  7761 DB77 F9 E0 00			SBC	FR1,Y		;subtract byte of divisor
  7762 DB7A 99 DA 00			STA	FRE,Y		;update byte of dividend
  7763 DB7D 88				DEY
  7764 DB7E 10 F4			BPL	FDIV7		;if not done
  7765
  7766 DB80 D8				CLD
  7767 DB81 90 04			BCC	FDIV8		;if difference < 0
  7768
  7769 DB83 E6 D9			INC	QTEMP		;increment
  7770 DB85 D0 E9			BNE	FDIV6		;continue
  7771
  7772 				;	Adjust.
  7773
  7774 DB87 20 09 DD		FDIV8	JSR	FRA1E	;add FR1 to FR0
  7775 DB8A C6 F5			DEC	ZTEMP1	;decrement
  7776 DB8C D0 B5			BNE	FDIV1	;if not done
  7777
  7778 				;	Clear exponent.
  7779
  7780 DB8E 20 62 DC			JSR	S0ER	;shift  FR0/FRE right
  7781
  7782 				;	Exit.
  7783
  7784 DB91 4C 1A DB			JMP	FMUL6
  7785 					;SPACE	4,10
  7786 				;	GNC - Get Next Character
  7787 				*
  7788 				*	ENTRY	JSR	GNC
  7789 				*		INBUFF - INBUFF+1 = line buffer pointer
  7790 				*		CIX = offset to character
  7791 				*
  7792 				*	EXIT
  7793 				*		C set, if character not numeric
  7794 				*		A = non-numeric character
  7795 				*		C clear, if character numeric
  7796 				*		CIX = offset to next character
  7797 				*
  7798 				*	MODS
  7799 				*		Original Author Unknown
  7800 				*		1. Bring closer to Coding Standard (object unchanged).
  7801 				*		   R. K. Nordin	11/01/83
  7802
  7803
  7804 = DB94			GNC	=	*		;entry
  7805 DB94 20 AF DB			JSR	TNC		;test for numeric character
  7806 DB97 A4 F2			LDY	CIX		;offset
  7807 DB99 90 02			BCC	ICX		;if numeric, increment offset, return
  7808
  7809 DB9B B1 F3			LDA	(INBUFF),Y	;character
  7810 				;	JMP	ICX		;increment offset, return
  7811 					;SPACE	4,10
  7812 				;	ICX - Increment Character Offset
  7813 				*
  7814 				*	ENTRY	JSR	ICX
  7815 				*		Y = offset
  7816 				*
  7817 				*	EXIT
  7818 				*		CIX = offset to next character
  7819 				*
  7820 				*	MODS
  7821 				*		Original Author Unknown
  7822 				*		1. Bring closer to Coding Standard (object unchanged).
  7823 				*		   R. K. Nordin	11/01/83
  7824
  7825
  7826 = DB9D			ICX	=	*	;entry
  7827 DB9D C8				INY		;increment offset
  7828 DB9E 84 F2			STY	CIX	;offset
  7829 DBA0 60				RTS		;return
  7830 					;SPACE	4,10
  7831 				;	SLB - Skip Leading Blanks
  7832 				*
  7833 				*	ENTRY	JSR	SLB
  7834 				*		INBUFF - INBUFF+1 = line buffer pointer
  7835 				*		CIX = offset
  7836 				*
  7837 				*	EXIT
  7838 				*		CIX = offset to first non-blank character
  7839 				*
  7840 				*	MODS
  7841 				*		Original Author Unknown
  7842 				*		1. Bring closer to Coding Standard (object unchanged).
  7843 				*		   R. K. Nordin	11/01/83
  7844
  7845
  7846 = DBA1			SLB	=	*		;entry
  7847
  7848 				;	Initialize.
  7849
  7850 DBA1 A4 F2			LDY	CIX		;offset to character
  7851 DBA3 A9 20			LDA	#' '
  7852
  7853 				;	Search for first non-blank character.
  7854
  7855 DBA5 D1 F3		SLB1	CMP	(INBUFF),Y	;character
  7856 DBA7 D0 03			BNE	SLB2		;if non-blank character
  7857
  7858 DBA9 C8				INY
  7859 DBAA D0 F9			BNE	SLB1		;if not done
  7860
  7861 				;	Exit.
  7862
  7863 DBAC 84 F2		SLB2	STY	CIX		;offset to first non-blank character
  7864 DBAE 60				RTS			;return
  7865 					;SPACE	4,10
  7866 				;	TNC - Test for Numeric Character
  7867 				*
  7868 				*	ENTRY	JSR	TNC
  7869 				*		INBUFF - INBUFF+1 = line buffer pointer
  7870 				*		CIX = offset
  7871 				*
  7872 				*	EXIT
  7873 				*		C set, if numeric
  7874 				*		C clear if non-numeric
  7875 				*
  7876 				*	MODS
  7877 				*		Original Author Unknown
  7878 				*		1. Bring closer to Coding Standard (object unchanged).
  7879 				*		   R. K. Nordin	11/01/83
  7880
  7881
  7882 = DBAF			TNC	=	*		;entry
  7883 DBAF A4 F2			LDY	CIX		;offset
  7884 DBB1 B1 F3			LDA	(INBUFF),Y	;character
  7885 DBB3 38				SEC
  7886 DBB4 E9 30			SBC	#'0'	
  7887 DBB6 90 18			BCC	TVN2		;if < "0", return failure
  7888
  7889 DBB8 C9 0A			CMP	#'9'-'0'+1	;return success or failure
  7890 DBBA 60				RTS			;return
  7891 					;SPACE	4,10
  7892 				;	TVN - Test for Valid Number Character
  7893 				*
  7894 				*	ENTRY	JSR	TVN
  7895 				*
  7896 				*	EXIT
  7897 				*		C set, if not number
  7898 				*		C clear, if number
  7899 				*
  7900 				*	NOTES
  7901 				*		Problem: bytes wasted by BCC TVN5.
  7902 				*
  7903 				*	MODS
  7904 				*		Original Author Unknown
  7905 				*		1. Bring closer to Coding Standard (object unchanged).
  7906 				*		   R. K. Nordin	11/01/83
  7907
  7908
  7909 = DBBB			TVN	=	*	;entry
  7910
  7911 				;	Initialize.
  7912
  7913 DBBB A5 F2			LDA	CIX	;offset
  7914 DBBD 48				PHA		;save offset
  7915
  7916 				;	Check next character.
  7917
  7918 DBBE 20 94 DB			JSR	GNC	;get next character
  7919 DBC1 90 1F			BCC	TVN5	;if numeric, return success
  7920
  7921 DBC3 C9 2E			CMP	#'.'
  7922 DBC5 F0 14			BEQ	TVN4	;if ".", check next character
  7923
  7924 DBC7 C9 2B			CMP	#'+'
  7925 DBC9 F0 07			BEQ	TVN3	;if "+", check next character
  7926
  7927 DBCB C9 2D			CMP	#'-'
  7928 DBCD F0 03			BEQ	TVN3	;if "-", check next character
  7929
  7930 				;	Clean stack.
  7931
  7932 DBCF 68			TVN1	PLA		;clean stack
  7933
  7934 				;	Return failure.
  7935
  7936 DBD0 38			TVN2	SEC		;indicate failure
  7937 DBD1 60				RTS		;return
  7938
  7939 				;	Check character after "+" or "-".
  7940
  7941 DBD2 20 94 DB		TVN3	JSR	GNC	;get next character
  7942 DBD5 90 0B			BCC	TVN5	;if numeric, return success
  7943
  7944 DBD7 C9 2E			CMP	#'.'
  7945 DBD9 D0 F4			BNE	TVN1	;if not ".", return failure
  7946
  7947 				;	Check character after ".".
  7948
  7949 DBDB 20 94 DB		TVN4	JSR	GNC	;get next character
  7950 DBDE 90 02			BCC	TVN5	;if numeric, return success
  7951
  7952 DBE0 B0 ED			BCS	TVN1	;return failure
  7953
  7954 				;	Return success.
  7955
  7956 DBE2 68			TVN5	PLA		;saved offset
  7957 DBE3 85 F2			STA	CIX	;restore offset
  7958 DBE5 18				CLC		;indicate success
  7959 DBE6 60				RTS		;return
  7960 				;	;SPACE	4,10
  7961 				;	S2L - Shift FR2 Left One Digit
  7962 				*
  7963 				*	ENTRY	JSR	S2L
  7964 				*
  7965 				*	MODS
  7966 				*		Original Author Unknown
  7967 				*		1. Bring closer to Coding Standard (object unchanged).
  7968 				*		   R. K. Nordin	11/01/83
  7969
  7970
  7971 = DBE7			S2L	=	*	;entry
  7972 DBE7 A2 E7			LDX	#FR2+1	;indicate shift of FR2 mantissa
  7973 DBE9 D0 02			BNE	SML	;shift mantissa left 1 digit, return
  7974 					;SPACE	4,10
  7975 				;	S0L - Shift FR0 Left One Digit
  7976 				*
  7977 				*	ENTRY	JSR	S0L
  7978 				*
  7979 				*	MODS
  7980 				*		Original Author Unknown
  7981 				*		1. Bring closer to Coding Standard (object unchanged).
  7982 				*		   R. K. Nordin	11/01/83
  7983
  7984
  7985 = DBEB			S0L	=	*	;entry
  7986 DBEB A2 D5			LDX	#FR0M	;indicate shift of FR0 mantissa
  7987 				;	JMP	SML	;shift mantissa left 1 digit, return
  7988 					;SPACE	4,10
  7989 				;	SML - Shift Mantissa Left One Digit
  7990 				*
  7991 				*	ENTRY	JSR	SML
  7992 				*
  7993 				*	EXIT
  7994 				*		FRX = excess digit
  7995 				*
  7996 				*	MODS
  7997 				*		Original Author Unknown
  7998 				*		1. Bring closer to Coding Standard (object unchanged).
  7999 				*		   R. K. Nordin	11/01/83
  8000
  8001
  8002 = DBED			SML	=	*	;entry
  8003 DBED A0 04			LDY	#4	;number of bits to shift
  8004
  8005 DBEF 18			SML2	CLC
  8006 DBF0 36 04			ROL	$0004,X	;shift 5th byte left 1 bit
  8007 DBF2 36 03			ROL	$0003,X	;shift 4th byte left 1 bit
  8008 DBF4 36 02			ROL	$0002,X	;shift 3rd byte left 1 bit
  8009 DBF6 36 01			ROL	$0001,X	;shift 2nd byte left 1 bit
  8010 DBF8 36 00			ROL	$0000,X	;shift 1st byte left 1 bit
  8011 DBFA 26 EC			ROL	FRX	;shift excess digit left 1 bit
  8012 DBFC 88				DEY
  8013 DBFD D0 F0			BNE	SML2	;if not done
  8014
  8015 DBFF 60				RTS		;return
  8016 					;SPACE	4,10
  8017 				;	NORM - Normalize FR0
  8018 				*
  8019 				*	ENTRY	JSR	NORM
  8020 				*
  8021 				*	MODS
  8022 				*		Original Author Unknown
  8023 				*		1. Bring closer to Coding Standard (object unchanged).
  8024 				*		   R. K. Nordin	11/01/83
  8025
  8026
  8027 = DC00			NORM	=	*		;entry
  8028 DC00 A2 00			LDX	#0
  8029 DC02 86 DA			STX	FRE		;byte to shift in
  8030 				;	JMP	N0E		;normalize FR0/FRE, return
  8031 					;SPACE	4,10
  8032 				;	N0E - Normalize FR0/FRE
  8033 				*
  8034 				*	ENTRY	JSR	N0E
  8035 				*
  8036 				*	MODS
  8037 				*		Original Author Unknown
  8038 				*		1. Bring closer to Coding Standard (object unchanged).
  8039 				*		   R. K. Nordin	11/01/83
  8040
  8041
  8042 = DC04			N0E	=	*		;entry
  8043 DC04 A2 04			LDX	#FMPREC-1	;mantissa size
  8044 DC06 A5 D4			LDA	FR0		;exponent
  8045 DC08 F0 2E			BEQ	N0E5		;if exponent zero, number is zero
  8046
  8047 DC0A A5 D5		N0E1	LDA	FR0M		;first byte of mantissa
  8048 DC0C D0 1A			BNE	N0E3		;if not zero, no shift
  8049
  8050 				;	Shift mantissa left 1 byte.
  8051
  8052 DC0E A0 00			LDY	#0		;offset to first byte of mantissa
  8053
  8054 DC10 B9 D6 00		N0E2	LDA	FR0M+1,Y	;byte to shift
  8055 DC13 99 D5 00			STA	FR0M,Y		;byte of destination
  8056 DC16 C8				INY
  8057 DC17 C0 05			CPY	#FMPREC		;size of mantissa
  8058 DC19 90 F5			BCC	N0E2		;if not done
  8059
  8060 				;	Decrement exponent and check for completion.
  8061
  8062 DC1B C6 D4			DEC	FR0		;decrement exponent
  8063 DC1D CA				DEX
  8064 DC1E D0 EA			BNE	N0E1		;if not done
  8065
  8066 				;	Check first byte of mantissa.
  8067
  8068 DC20 A5 D5			LDA	FR0M	;first byte of mantissa
  8069 DC22 D0 04			BNE	N0E3	;if mantissa not zero
  8070
  8071 				;	Zero exponent.
  8072
  8073 DC24 85 D4			STA	FR0	;zero exponent
  8074 DC26 18				CLC
  8075 DC27 60				RTS		;return
  8076
  8077 				;	Check for overflow.
  8078
  8079 DC28 A5 D4		N0E3	LDA	FR0	;exponent
  8080 DC2A 29 7F			AND	#$7F	;clear sign
  8081 DC2C C9 71			CMP	#$40+49	;bias+49
  8082 DC2E 90 01			BCC	N0E4	;if exponent < 49, no overflow
  8083
  8084 				;	Return error.
  8085
  8086 				;	SEC		;indicate error
  8087 DC30 60				RTS		;return
  8088
  8089 				;	Check for underflow.
  8090
  8091 DC31 C9 0F		N0E4	CMP	#$40-49
  8092 DC33 B0 03			BCS	N0E5	;if exponent >= -49, no underflow
  8093
  8094 				;	Zero result.
  8095
  8096 DC35 20 44 DA			JSR	ZFR0	;zero FR0
  8097
  8098 				;	Exit.
  8099
  8100 DC38 18			N0E5	CLC		;indicate no error
  8101 DC39 60				RTS		;return
  8102 					;SPACE	4,10
  8103 				;	S0R - Shift FR0 Right
  8104 				*
  8105 				*	ENTRY	JSR	S0R
  8106 				*		A = shift count
  8107 				*
  8108 				*	MODS
  8109 				*		Original Author Unknown
  8110 				*		1. Bring closer to Coding Standard (object unchanged).
  8111 				*		   R. K. Nordin	11/01/83
  8112
  8113
  8114 = DC3A			S0R	=	*	;entry
  8115 DC3A A2 D4			LDX	#FR0	;indicate shift of FR0
  8116 DC3C D0 02			BNE	SRR	;shift register right, return
  8117 					;SPACE	4,10
  8118 				;	S1R - Shift FR1 Right
  8119 				*
  8120 				*	ENTRY	JSR	S1R
  8121 				*		A = shift count
  8122 				*
  8123 				*	MODS
  8124 				*		Original Author Unknown
  8125 				*		1. Bring closer to Coding Standard (object unchanged).
  8126 				*		   R. K. Nordin	11/01/83
  8127
  8128
  8129 = DC3E			S1R	=	*	;entry
  8130 DC3E A2 E0			LDX	#FR1	;indicate shift of FR1
  8131 				;	JMP	SRR	;shift register right, return
  8132 					;SPACE	4,10
  8133 				;	SRR - Shift Register Right
  8134 				*
  8135 				*	ENTRY	JSR	SRR
  8136 				*		X = offset to register
  8137 				*		A = shift count
  8138 				*
  8139 				*	MODS
  8140 				*		Original Author Unknown
  8141 				*		1. Bring closer to Coding Standard (object unchanged).
  8142 				*		   R. K. Nordin	11/01/83
  8143
  8144
  8145 = DC40			SRR	=	*		;entry
  8146 DC40 86 F9			STX	ZTEMP3		;register
  8147 DC42 85 F7			STA	ZTEMP4		;shift count
  8148 DC44 85 F8			STA	ZTEMP4+1	;save shift count
  8149
  8150 DC46 A0 04		SRR1	LDY	#FMPREC-1	;mantissa size-1
  8151
  8152 DC48 B5 04		SRR2	LDA	$0004,X		;byte to shift
  8153 DC4A 95 05			STA	$0005,X		;byte of destination
  8154 DC4C CA				DEX
  8155 DC4D 88				DEY
  8156 DC4E D0 F8			BNE	SRR2		;if not done
  8157
  8158 DC50 A9 00			LDA	#0
  8159 DC52 95 05			STA	$0005,X		;first byte of mantissa
  8160 DC54 A6 F9			LDX	ZTEMP3		;register
  8161 DC56 C6 F7			DEC	ZTEMP4		;decrement shift count
  8162 DC58 D0 EC			BNE	SRR1		;if not done
  8163
  8164 				;	Adjust exponent.
  8165
  8166 DC5A B5 00			LDA	$0000,X		;exponent
  8167 DC5C 18				CLC
  8168 DC5D 65 F8			ADC	ZTEMP4+1	;subtract shift count
  8169 DC5F 95 00			STA	$0000,X		;update exponent
  8170 DC61 60				RTS			;return
  8171 					;SPACE	4,10
  8172 				;	S0ER - Shift FR0/FRE Right
  8173 				*
  8174 				*	ENTRY	JSR	S0ER
  8175 				*
  8176 				*	MODS
  8177 				*		Original Author Unknown
  8178 				*		1. Bring closer to Coding Standard (object unchanged).
  8179 				*		   R. K. Nordin	11/01/83
  8180
  8181
  8182 = DC62			S0ER	=	*		;entry
  8183 DC62 A2 0A			LDX	#FMPREC*2	;number of bytes to shift
  8184
  8185 DC64 B5 D4		S0ER1	LDA	FR0,X		;byte to shift
  8186 DC66 95 D5			STA	FR0+1,X		;byte of destination
  8187 DC68 CA				DEX
  8188 DC69 10 F9			BPL	S0ER1		;if not done
  8189
  8190 DC6B A9 00			LDA	#0
  8191 DC6D 85 D4			STA	FR0		;shift in 0
  8192 DC6F 60				RTS			;return
  8193 					;SPACE	4,10
  8194 				;	C0A - Convert FR0 to ASCII
  8195 				*
  8196 				*	ENTRY	JSR	C0A
  8197 				*		A = decimal point position
  8198 				*
  8199 				*	MODS
  8200 				*		Original Author Unknown
  8201 				*		1. Bring closer to Coding Standard (object unchanged).
  8202 				*		   R. K. Nordin	11/01/83
  8203
  8204
  8205 = DC70			C0A	=	*	;entry
  8206
  8207 				;	Initialize.
  8208
  8209 DC70 85 F7			STA	ZTEMP4	;decimal point position counter
  8210 DC72 A2 00			LDX	#0	;offset to first byte of FR0M
  8211 DC74 A0 00			LDY	#0	;offset to first byte of LBUF
  8212
  8213 				;	Convert next byte.
  8214
  8215 DC76 20 93 DC		C0A1	JSR	TDP	;test for decimal point
  8216 DC79 38				SEC
  8217 DC7A E9 01			SBC	#1	;decrement deciaml point position
  8218 DC7C 85 F7			STA	ZTEMP4	;update deciaml point position counter
  8219
  8220 				;	Convert first digit of next byte.
  8221
  8222 DC7E B5 D5			LDA	FR0M,X	;byte
  8223 DC80 4A				LSR
  8224 DC81 4A				LSR
  8225 DC82 4A				LSR
  8226 DC83 4A				LSR	;first digit
  8227 DC84 20 9D DC			JSR	SNL	;store number in line buffer
  8228
  8229 				;	Convert second digit of next byte.
  8230
  8231 DC87 B5 D5			LDA	FR0M,X	;byte
  8232 DC89 29 0F			AND	#$0F	;extract second digit
  8233 DC8B 20 9D DC			JSR	SNL	;store number in line buffer
  8234 DC8E E8				INX
  8235 DC8F E0 05			CPX	#FMPREC	;nuber of bytes
  8236 DC91 90 E3			BCC	C0A1	;if not done
  8237
  8238 				;	Exit.
  8239
  8240 				;	JMP	TDP	;test for decimal point, return
  8241 					;SPACE	4,10
  8242 				;	TDP - Test for Decimal Point
  8243 				*
  8244 				*	ENTRY	JSR	TDP
  8245 				*		ZTEMP4 = decimal point position counter
  8246 				*
  8247 				*	MODS
  8248 				*		Original Author Unknown
  8249 				*		1. Bring closer to Coding Standard (object unchanged).
  8250 				*		   R. K. Nordin	11/01/83
  8251
  8252
  8253 = DC93			TDP	=	*	;entry
  8254
  8255 				;	Check decimal point position counter.
  8256
  8257 DC93 A5 F7			LDA	ZTEMP4	;decimal point position counter
  8258 DC95 D0 05			BNE	TDP1	;if not decimal point position, exit
  8259
  8260 				;	Insert decimal point.
  8261
  8262 DC97 A9 2E			LDA	#'.'
  8263 DC99 20 9F DC			JSR	SAL	;store ASCII character in line buffer
  8264
  8265 				;	Exit.
  8266
  8267 DC9C 60			TDP1	RTS		;return
  8268 					;SPACE	4,10
  8269 				;	SNL - Store Number in Line Buffer
  8270 				*
  8271 				*	ENTRY	JSR	SNL
  8272 				*		A = digit to store
  8273 				*		Y = offset
  8274 				*
  8275 				*	EXIT
  8276 				*		ASCII digit placed in line buffer
  8277 				*
  8278 				*	MODS
  8279 				*		Original Author Unknown
  8280 				*		1. Bring closer to Coding Standard (object unchanged).
  8281 				*		   R. K. Nordin	11/01/83
  8282
  8283
  8284 = DC9D			SNL	=	*	;entry
  8285 DC9D 09 30			ORA	#$30	;convert digit to ASCII
  8286 				;	JMP	SAL	;store ASCII character in line buffer, return
  8287 					;SPACE	4,10
  8288 				;	SAL - Store ASCII Character in Line Buffer
  8289 				*
  8290 				*	ENTRY	JSR	SAL
  8291 				*		Y = offset
  8292 				*		A = character
  8293 				*
  8294 				*	EXIT
  8295 				*		Character placed in line buffer
  8296 				*		Y = incremented offset
  8297 				*
  8298 				*	MODS
  8299 				*		Original Author Unknown
  8300 				*		1. Bring closer to Coding Standard (object unchanged).
  8301 				*		   R. K. Nordin	11/01/83
  8302
  8303
  8304 = DC9F			SAL	=	*	;entry
  8305 DC9F 99 80 05			STA	LBUFF,Y	;store character in line buffer
  8306 DCA2 C8				INY		;increment offset
  8307 DCA3 60				RTS		;return
  8308 					;SPACE	4,10
  8309 				;	FNZ - Find Last Non-zero Character in Line Buffer
  8310 				*
  8311 				*	FNZ returns the last non-zero character.  If the last
  8312 				*	non-zero character is ".", FNZ returns the character
  8313 				*	preceding the ".".  If no other non-zero character is
  8314 				*	encountered, FNZ returns the first character.
  8315 				*
  8316 				*	ENTRY	JSR	FNZ
  8317 				*
  8318 				*	EXIT
  8319 				*		A = character
  8320 				*		X = offset to character
  8321 				*
  8322 				*	MODS
  8323 				*		Original Author Unknown
  8324 				*		1. Bring closer to Coding Standard (object unchanged).
  8325 				*		   R. K. Nordin	11/01/83
  8326
  8327
  8328 = DCA4			FNZ	=	*	;entry
  8329
  8330 				;	Initialize.
  8331
  8332 DCA4 A2 0A			LDX	#10	;offset to last possible character
  8333
  8334 				;	Check next character.
  8335
  8336 DCA6 BD 80 05		FNZ1	LDA	LBUFF,X	;character
  8337 DCA9 C9 2E			CMP	#'.'
  8338 DCAB F0 07			BEQ	FNZ2	;if ".", return preceding character
  8339
  8340 DCAD C9 30			CMP	#'0'
  8341 DCAF D0 07			BNE	FNZ3	;if not "0", exit
  8342
  8343 				;	Decrement offset and check for completion.
  8344
  8345 DCB1 CA				DEX
  8346 DCB2 D0 F2			BNE	FNZ1	;if not done
  8347
  8348 				;	Return character preceding "." or first character.
  8349
  8350 DCB4 CA			FNZ2	DEX		;offset to character
  8351 DCB5 BD 80 05			LDA	LBUFF,X	;character
  8352
  8353 				;	Exit.
  8354
  8355 DCB8 60			FNZ3	RTS		;return
  8356 					;SPACE	4,10
  8357 				;	GND - Get Next Digit
  8358 				*
  8359 				*	ENTRY	JSR	GND
  8360 				*		FR0 - FR0+5 = number
  8361 				*
  8362 				*	EXIT
  8363 				*		A = digit
  8364 				*
  8365 				*	MODS
  8366 				*		Original Author Unknown
  8367 				*		1. Bring closer to Coding Standard (object unchanged).
  8368 				*		   R. K. Nordin	11/01/83
  8369
  8370
  8371 = DCB9			GND	=	*	;entry
  8372 DCB9 20 EB DB			JSR	S0L	;shift FR0 left 1 digit
  8373 DCBC A5 EC			LDA	FRX	;excess digit
  8374 DCBE 29 0F			AND	#$0F	;extract low order digit
  8375 DCC0 60				RTS		;return
  8376 					;SPACE	4,10
  8377 				;	DLP - Decrement Line Buffer Pointer
  8378 				*
  8379 				*	ENTRY	JSR	DLP
  8380 				*		INBUFF - INBUFF+1 = line buffer pointer
  8381 				*
  8382 				*	EXIT
  8383 				*		INBUFF - INBUFF+1 = incremented line buffer pointer
  8384 				*
  8385 				*	MODS
  8386 				*		Original Author Unknown
  8387 				*		1. Bring closer to Coding Standard (object unchanged).
  8388 				*		   R. K. Nordin	11/01/83
  8389
  8390
  8391 = DCC1			DLP	=	*		;entry
  8392 DCC1 38				SEC
  8393 DCC2 A5 F3			LDA	INBUFF		;line buffer pointer
  8394 DCC4 E9 01			SBC	#1		;subtract 1
  8395 DCC6 85 F3			STA	INBUFF		;update line buffer pointer
  8396 DCC8 A5 F4			LDA	INBUFF+1
  8397 DCCA E9 00			SBC	#0
  8398 DCCC 85 F4			STA	INBUFF+1
  8399 DCCE 60				RTS			;return
  8400 					;SPACE	4,10
  8401 				;	SUE - Set Up Exponent for Multiply or Divide
  8402 				*
  8403 				*	ENTRY	JSR	SUE
  8404 				*
  8405 				*	EXIT
  8406 				*		A = FR0 exponent (without sign)
  8407 				*		FR1 = FR1 exponent (without sign)
  8408 				*		FRSIGN = sign of result
  8409 				*
  8410 				*	MODS
  8411 				*		Original Author Unknown
  8412 				*		1. Bring closer to Coding Standard (object unchanged).
  8413 				*		   R. K. Nordin	11/01/83
  8414
  8415
  8416 = DCCF			SUE	=	*	;entry
  8417 DCCF A5 D4			LDA	FR0	;FR0 exponent
  8418 DCD1 45 E0			EOR	FR1	;EOR with FR1 exponent
  8419 DCD3 29 80			AND	#$80	;extract sign
  8420 DCD5 85 EE			STA	FRSIGN	;sign of result
  8421 DCD7 06 E0			ASL	FR1	;shift out FR1 sign
  8422 DCD9 46 E0			LSR	FR1	;FR1 exponent without sign
  8423 DCDB A5 D4			LDA	FR0	;FR0 exponent
  8424 DCDD 29 7F			AND	#$7F	;FR0 exponent without sign
  8425 DCDF 60				RTS		;return
  8426 					;SPACE	4,10
  8427 				;	SUP - Set Up for Multiply or Divide
  8428 				*
  8429 				*	ENTRY	JSR	SUP
  8430 				*		A = exponent
  8431 				*
  8432 				*	MODS
  8433 				*		Original Author Unknown
  8434 				*		1. Bring closer to Coding Standard (object unchanged).
  8435 				*		   R. K. Nordin	11/01/83
  8436
  8437
  8438 = DCE0			SUP	=	*	;entry
  8439 DCE0 05 EE			ORA	FRSIGN	;place sign in exponent
  8440 DCE2 85 ED			STA	EEXP	;exponent
  8441 DCE4 A9 00			LDA	#0
  8442 DCE6 85 D4			STA	FR0	;clear FR0 exponent
  8443 DCE8 85 E0			STA	FR1	;clear FR0 exponent
  8444 DCEA 20 28 DD			JSR	M12	;move FR1 to FR2
  8445 DCED 20 E7 DB			JSR	S2L	;shift FR2 left 1 digit
  8446 DCF0 A5 EC			LDA	FRX	;excess digit
  8447 DCF2 29 0F			AND	#$0F	;extract low order digit
  8448 DCF4 85 E6			STA	FR2	;shift in low order digit
  8449 DCF6 A9 05			LDA	#FMPREC	;mantissa size
  8450 DCF8 85 F5			STA	ZTEMP1	;mantissa size
  8451 DCFA 20 34 DD			JSR	M0E	;move FR0 to FRE
  8452 DCFD 20 44 DA			JSR	ZFR0	;zero FR0
  8453 DD00 60				RTS		;return
  8454 					;SPACE	4,10
  8455 				;	FRA10 - Add FR1 to FR0
  8456 				*
  8457 				*	ENTRY	JSR	FRA10
  8458 				*		FR0 - FR0+5 = augend
  8459 				*		FR1 - FR1+5 = addend
  8460 				*
  8461 				*	EXIT
  8462 				*		FR0 - FR0+5 = sum
  8463 				*
  8464 				*	MODS
  8465 				*		Original Author Unknown
  8466 				*		1. Bring closer to Coding Standard (object unchanged).
  8467 				*		   R. K. Nordin	11/01/83
  8468
  8469
  8470 = DD01			FRA10	=	*		;entry
  8471 DD01 A2 D9			LDX	#FR0+FPREC-1	;offset to last byte of FR0
  8472 DD03 D0 06			BNE	F1R
  8473 					;SPACE	4,10
  8474 				;	FRA20 - Add FR2 to FR0
  8475 				*
  8476 				*	ENTRY	JSR	FRA20
  8477 				*		FR0 - FR0+5 = augend
  8478 				*		FR2 - FR2+5 = addend
  8479 				*
  8480 				*	EXIT
  8481 				*		FR0 - FR0+5 = sum
  8482 				*
  8483 				*	MODS
  8484 				*		Original Author Unknown
  8485 				*		1. Bring closer to Coding Standard (object unchanged).
  8486 				*		   R. K. Nordin	11/01/83
  8487
  8488
  8489 = DD05			FRA20	=	*		;entry
  8490 DD05 A2 D9			LDX	#FR0+FPREC-1	;offset to last byte of FR0
  8491 DD07 D0 08			BNE	F2R
  8492 					;SPACE	4,10
  8493 				;	FRA1E - Add FR1 to FRE
  8494 				*
  8495 				*	ENTRY	JSR	FRA1E
  8496 				*		FRE - FRE+5 = augend
  8497 				*		FR1 - FR1+5 = addend
  8498 				*
  8499 				*	EXIT
  8500 				*		FRE - FRE+5 = sum
  8501 				*
  8502 				*	MODS
  8503 				*		Original Author Unknown
  8504 				*		1. Bring closer to Coding Standard (object unchanged).
  8505 				*		   R. K. Nordin	11/01/83
  8506
  8507
  8508 = DD09			FRA1E	=	*		;entry
  8509 DD09 A2 DF			LDX	#FRE+FPREC-1	;offset to last byte of FRE
  8510 				;	JMP	F1R		;add FR1 to register, return
  8511 					;SPACE	4,10
  8512 				;	F1R - Add FR1 to Register
  8513 				*
  8514 				*	ENTRY	JSR	F1R
  8515 				*		X = offset to last byte of augend register
  8516 				*		FR1 - FR1+5 = addend
  8517 				*
  8518 				*	EXIT
  8519 				*		Sum in augend register
  8520 				*
  8521 				*	MODS
  8522 				*		Original Author Unknown
  8523 				*		1. Bring closer to Coding Standard (object unchanged).
  8524 				*		   R. K. Nordin	11/01/83
  8525
  8526
  8527 = DD0B			F1R	=	*		;entry
  8528 DD0B A0 E5			LDY	#FR1+FPREC-1	;offset to last byte of FR1
  8529 DD0D D0 04			BNE	FARR
  8530 					;SPACE	4,10
  8531 				;	FRA2E - Add FR2 to FRE
  8532 				*
  8533 				*	ENTRY	JSR	FRA2E
  8534 				*		FRE - FRE+5 = augend
  8535 				*		FR2 - FR2+5 = addend
  8536 				*
  8537 				*	EXIT
  8538 				*		FRE - FRE+5 = sum
  8539 				*
  8540 				*	MODS
  8541 				*		Original Author Unknown
  8542 				*		1. Bring closer to Coding Standard (object unchanged).
  8543 				*		   R. K. Nordin	11/01/83
  8544
  8545
  8546 = DD0F			FRA2E	=	*		;entry
  8547 DD0F A2 DF			LDX	#FRE+FPREC-1	;offset to last byte of FRE
  8548 				;	JMP	F2R
  8549 					;SPACE	4,10
  8550 				;	F2R - Add FR2 to Register
  8551 				*
  8552 				*	ENTRY	JSR	F2R
  8553 				*		X = offset to last byte of augend register
  8554 				*		FR2 - FR2+5 = addend
  8555 				*
  8556 				*	EXIT
  8557 				*		Sum in augend register
  8558 				*
  8559 				*	MODS
  8560 				*		Original Author Unknown
  8561 				*		1. Bring closer to Coding Standard (object unchanged).
  8562 				*		   R. K. Nordin	11/01/83
  8563
  8564
  8565 = DD11			F2R	=	*		;entry
  8566 DD11 A0 EB			LDY	#FR2+FPREC-1	;offset to last byte of FR2
  8567 				;	JMP	FARR
  8568 					;SPACE	4,10
  8569 				;	FARR - Add Register to Register
  8570 				*
  8571 				*	ENTRY	JSR	FARR
  8572 				*		X = offset to last byte of augend register
  8573 				*		Y = offset to last byte of addend register
  8574 				*
  8575 				*	EXIT
  8576 				*		Sum in augend register
  8577 				*
  8578 				*	MODS
  8579 				*		Original Author Unknown
  8580 				*		1. Bring closer to Coding Standard (object unchanged).
  8581 				*		   R. K. Nordin	11/01/83
  8582
  8583
  8584 = DD13			FARR	=	*		;entry
  8585
  8586 				;	Initialize.
  8587
  8588 DD13 A9 05			LDA	#FPREC-1	;floating point number size-1
  8589 DD15 85 F7			STA	ZTEMP4		;byte count
  8590 DD17 18				CLC
  8591 DD18 F8				SED
  8592
  8593 				;	Add.
  8594
  8595 DD19 B5 00		FARR1	LDA	$0000,X		;byte of augend
  8596 DD1B 79 00 00			ADC	$0000,Y		;add byte of addend
  8597 DD1E 95 00			STA	$0000,X		;update byte of augend
  8598 DD20 CA				DEX
  8599 DD21 88				DEY
  8600 DD22 C6 F7			DEC	ZTEMP4		;decrement byte count
  8601 DD24 10 F3			BPL	FARR1		;if not done
  8602
  8603 				;	Exit.
  8604
  8605 DD26 D8				CLD
  8606 DD27 60				RTS			;return
  8607 				;	;SPACE	4,10
  8608 				;	M12 - Move FR1 to FR2
  8609 				*
  8610 				*	ENTRY	JSR	M12
  8611 				*		FR1 - FR1+5 = number to move
  8612 				*
  8613 				*	EXIT
  8614 				*		FR2 - FR2+5 = moved number
  8615 				*
  8616 				*	MODS
  8617 				*		Original Author Unknown
  8618 				*		1. Bring closer to Coding Standard (object unchanged).
  8619 				*		   R. K. Nordin	11/01/83
  8620
  8621
  8622 = DD28			M12	=	*		;entry
  8623 DD28 A0 05			LDY	#FPREC-1	;offset to last byte
  8624
  8625 DD2A B9 E0 00		M121	LDA	FR1,Y		;byte of source
  8626 DD2D 99 E6 00			STA	FR2,Y		;byte of destination
  8627 DD30 88				DEY
  8628 DD31 10 F7			BPL	M121		;if not done
  8629
  8630 DD33 60				RTS			;return
  8631 					;SPACE	4,10
  8632 				;	M0E - Move FR0 to FRE
  8633 				*
  8634 				*	ENTRY	JSR	M0E
  8635 				*		FR0 - FR0+5 = number to move
  8636 				*
  8637 				*	EXIT
  8638 				*		FRE - FRE+5 = moved number
  8639 				*
  8640 				*	MODS
  8641 				*		Original Author Unknown
  8642 				*		1. Bring closer to Coding Standard (object unchanged).
  8643 				*		   R. K. Nordin	11/01/83
  8644
  8645
  8646 = DD34			M0E	=	*		;entry
  8647 DD34 A0 05			LDY	#FPREC-1	;offset to last byte
  8648
  8649 DD36 B9 D4 00		M0E1	LDA	FR0,Y		;byte of source
  8650 DD39 99 DA 00			STA	FRE,Y		;byte of destination
  8651 DD3C 88				DEY
  8652 DD3D 10 F7			BPL	M0E1		;if not done
  8653
  8654 DD3F 60				RTS			;return
  8655 					;SPACE	4,10
  8656 DD40				ORG	PLYEVL
  8657 					;SPACE	4,10
  8658 				;	PLYEVL - Evaluate Polynomial
  8659 				*
  8660 				*	Y = A(0)+A(1)*X+A(2)*X^2+...+A(N)*X^N
  8661 				*
  8662 				*	ENTRY	JSR	PLYEVL
  8663 				*		X = low address of coefficient table
  8664 				*		Y = high address of coefficient table
  8665 				*		FR0 - FR0+5 = X argument
  8666 				*		A = N+1
  8667 				*
  8668 				*	EXIT
  8669 				*		FR0 - FR0+5 = Y result
  8670 				*
  8671 				*	MODS
  8672 				*		Original Author Unknown
  8673 				*		1. Bring closer to Coding Standard (object unchanged).
  8674 				*		   R. K. Nordin	11/01/83
  8675
  8676
  8677 				;PLYEVL	=	*		;entry
  8678
  8679 DD40 86 FE			STX	FPTR2		;save pointer to coefficients
  8680 DD42 84 FF			STY	FPTR2+1
  8681 DD44 85 EF			STA	PLYCNT		;degree
  8682 DD46 A2 E0			LDX	#<PLYARG
  8683 DD48 A0 05			LDY	#>PLYARG
  8684 DD4A 20 A7 DD			JSR	FST0R		;save argument
  8685 DD4D 20 B6 DD			JSR	FMOVE		;move argument to FR1
  8686 DD50 A6 FE			LDX	FPTR2
  8687 DD52 A4 FF			LDY	FPTR2+1
  8688 DD54 20 89 DD			JSR	FLD0R		;initialize sum in FR0
  8689 DD57 C6 EF			DEC	PLYCNT		;decrement degree
  8690 DD59 F0 2D			BEQ	PLY3		;if complete, exit
  8691
  8692 DD5B 20 DB DA		PLY1	JSR	FMUL		;argument times current sum
  8693 DD5E B0 28			BCS	PLY3		;if overflow
  8694
  8695 DD60 18				CLC
  8696 DD61 A5 FE			LDA	FPTR2		;current low coefficient address
  8697 DD63 69 06			ADC	#FPREC		;add floating point number size
  8698 DD65 85 FE			STA	FPTR2		;update low coefficient address
  8699 DD67 90 06			BCC	PLY2		;if no carry
  8700
  8701 DD69 A5 FF			LDA	FPTR2+1		;current high coefficceint address
  8702 DD6B 69 00			ADC	#0		;adjust high coefficient address
  8703 DD6D 85 FF			STA	FPTR2+1		;update high coefficient address
  8704
  8705 DD6F A6 FE		PLY2	LDX	FPTR2		;low coefficient address
  8706 DD71 A4 FF			LDY	FPTR2+1		;high coefficient address
  8707 DD73 20 98 DD			JSR	FLD1R		;get next coefficient
  8708 DD76 20 66 DA			JSR	FADD		;add coefficient to argument times sum
  8709 DD79 B0 0D			BCS	PLY3		;if overflow
  8710
  8711 DD7B C6 EF			DEC	PLYCNT		;decrement degree
  8712 DD7D F0 09			BEQ	PLY3		;if complete, exit
  8713
  8714 DD7F A2 E0			LDX	#<PLYARG	;low argument address
  8715 DD81 A0 05			LDY	#>PLYARG	;high argument address
  8716 DD83 20 98 DD			JSR	FLD1R		;get argument
  8717 DD86 30 D3			BMI	PLY1		;continue
  8718
  8719 DD88 60			PLY3	RTS			;return
  8720 					;SPACE	4,10
  8721 DD89				ORG	FLD0R
  8722 					;SPACE	4,10
  8723 				;	FLD0R - ???
  8724 				*
  8725 				*	ENTRY	JSR	FLD0R
  8726 				*		X = low pointer
  8727 				*		Y = high pointer
  8728 				*
  8729 				*	EXIT
  8730 				*		FR0 loaded
  8731 				*
  8732 				*	MODS
  8733 				*		Original Author Unknown
  8734 				*		1. Bring closer to Coding Standard (object unchanged).
  8735 				*		   R. K. Nordin	11/01/83
  8736
  8737
  8738 				;FLD0R	=	*		;entry
  8739 DD89 86 FC			STX	FLPTR		;low pointer
  8740 DD8B 84 FD			STY	FLPTR+1		;high pointer
  8741 				;	JMP	FLD0P		;load FR0, return
  8742 					;SPACE	4,10
  8743 DD8D				ORG	FLD0P
  8744 					;SPACE	4,10
  8745 				;	FLD0P - Load FR0
  8746 				*
  8747 				*	ENTRY	JSR	FLD0P
  8748 				*		FLPTR - FLPTR+1 = pointer
  8749 				*
  8750 				*	EXIT
  8751 				*		FR0 loaded
  8752 				*
  8753 				*	MODS
  8754 				*		Original Author Unknown
  8755 				*		1. Bring closer to Coding Standard (object unchanged).
  8756 				*		   R. K. Nordin	11/01/83
  8757
  8758
  8759 				;FLD0P	=	*		;entry
  8760
  8761 DD8D A0 05			LDY	#FPREC-1	;offset to last byte
  8762
  8763 DD8F B1 FC		FLD01	LDA	(FLPTR),Y	;byte of source
  8764 DD91 99 D4 00			STA	FR0,Y		;byte of destination
  8765 DD94 88				DEY
  8766 DD95 10 F8			BPL	FLD01		;if not done
  8767
  8768 DD97 60				RTS			;return
  8769 					;SPACE	4,10
  8770 DD98				ORG	FLD1R
  8771 					;SPACE	4,10
  8772 				;	FLD1R - Load FR1
  8773 				*
  8774 				*	ENTRY	JSR	FLD1R
  8775 				*		X = low pointer
  8776 				*		Y = high pointer
  8777 				*
  8778 				*	EXIT
  8779 				*		FR1 loaded
  8780 				*
  8781 				*	MODS
  8782 				*		Original Author Unknown
  8783 				*		1. Bring closer to Coding Standard (object unchanged).
  8784 				*		   R. K. Nordin	11/01/83
  8785
  8786
  8787 				;FLD1R	=	*		;entry
  8788 DD98 86 FC			STX	FLPTR		;low pointer
  8789 DD9A 84 FD			STY	FLPTR+1		;high pointer
  8790 				;	JMP	FLD1P		;load FR1, return
  8791 					;SPACE	4,10
  8792 DD9C				ORG	FLD1P
  8793 					;SPACE	4,10
  8794 				;	FLD1P - Load FR1
  8795 				*
  8796 				*	ENTRY	JSR	FLD1P
  8797 				*		FLPTR - FLPTR+1 = pointer
  8798 				*
  8799 				*	EXIT
  8800 				*		FR1 loaded
  8801 				*
  8802 				*	MODS
  8803 				*		Original Author Unknown
  8804 				*		1. Bring closer to Coding Standard (object unchanged).
  8805 				*		   R. K. Nordin	11/01/83
  8806
  8807
  8808 				;FLD1P	=	*		;entry
  8809
  8810 DD9C A0 05			LDY	#FPREC-1	;offset to last byte
  8811
  8812 DD9E B1 FC		FLD11	LDA	(FLPTR),Y	;byte of source
  8813 DDA0 99 E0 00			STA	FR1,Y		;byte of destination
  8814 DDA3 88				DEY
  8815 DDA4 10 F8			BPL	FLD11		;if not done
  8816
  8817 DDA6 60				RTS			;return
  8818 					;SPACE	4,10
  8819 DDA7				ORG	FST0R
  8820 					;SPACE	4,10
  8821 				;	FST0R - Store FR0
  8822 				*
  8823 				*	ENTRY	JSR	FST0R
  8824 				*		FR0 - FR0+5 = number
  8825 				*		X = low pointer
  8826 				*		Y = high pointer
  8827 				*
  8828 				*	EXIT
  8829 				*		FR0 stored
  8830 				*
  8831 				*	MODS
  8832 				*		Original Author Unknown
  8833 				*		1. Bring closer to Coding Standard (object unchanged).
  8834 				*		   R. K. Nordin	11/01/83
  8835
  8836
  8837 				;FST0R	=	*		;entry
  8838 DDA7 86 FC			STX	FLPTR		;low pointer
  8839 DDA9 84 FD			STY	FLPTR+1		;high pointer
  8840 				;	JMP	FST0P		;???, return
  8841 					;SPACE	4,10
  8842 DDAB				ORG	FST0P
  8843 					;SPACE	4,10
  8844 				;	FST0P - Store FR0
  8845 				*
  8846 				*	ENTRY	JSR	FST0P
  8847 				*		FR0 - FR0+5 = number
  8848 				*		FLPTR - FLPTR+1 = pointer
  8849 				*
  8850 				*	EXIT
  8851 				*		FR0 stored
  8852 				*
  8853 				*	MODS
  8854 				*		Original Author Unknown
  8855 				*		1. Bring closer to Coding Standard (object unchanged).
  8856 				*		   R. K. Nordin	11/01/83
  8857
  8858
  8859 				;FST0P	=	*		;entry
  8860
  8861 DDAB A0 05			LDY	#FPREC-1	;offset to last byte
  8862
  8863 DDAD B9 D4 00		FST01	LDA	FR0,Y		;byte of source
  8864 DDB0 91 FC			STA	(FLPTR),Y	;byte of destination
  8865 DDB2 88				DEY
  8866 DDB3 10 F8			BPL	FST01		;if not done
  8867
  8868 DDB5 60				RTS			;return
  8869 					;SPACE	4,10
  8870 DDB6				ORG	FMOVE
  8871 					;SPACE	4,10
  8872 				;	FMOVE - Move FR0 to FR1
  8873 				*
  8874 				*	ENTRY	JSR	FMOVE
  8875 				*
  8876 				*	MODS
  8877 				*		Original Author Unknown
  8878 				*		1. Bring closer to Coding Standard (object unchanged).
  8879 				*		   R. K. Nordin	11/01/83
  8880
  8881
  8882 				;FMOVE	=	*		;entry
  8883
  8884 DDB6 A2 05			LDX	#FPREC-1	;offset to last byte
  8885
  8886 DDB8 B5 D4		FMO1	LDA	FR0,X		;byte of source
  8887 DDBA 95 E0			STA	FR1,X		;byte of destination
  8888 DDBC CA				DEX
  8889 DDBD 10 F9			BPL	FMO1		;if not done
  8890
  8891 DDBF 60				RTS			;return
  8892 					;SPACE	4,10
  8893 DDC0				ORG	EXP
  8894 					;SPACE	4,10
  8895 				;	EXP - Compute Power of e
  8896 				*
  8897 				*	ENTRY	JSR	EXP
  8898 				*
  8899 				*	MODS
  8900 				*		Original Author Unknown
  8901 				*		1. Bring closer to Coding Standard (object unchanged).
  8902 				*		   R. K. Nordin	11/01/83
  8903
  8904
  8905 				;EXP	=	*		;entry
  8906
  8907 				;	Initialize.
  8908
  8909 DDC0 A2 89			LDX	#<LOG10E	;base 10 logarithm of e
  8910 DDC2 A0 DE			LDY	#>LOG10E
  8911 DDC4 20 98 DD			JSR	FLD1R		;load FR1
  8912
  8913 				;	Compute X*LOG10(E).
  8914
  8915 DDC7 20 DB DA			JSR	FMUL		;multiply
  8916 DDCA B0 7F			BCS	EXP6		;if overflow, error
  8917
  8918 				;	Compute result = 10^(X*LOG10(E)).
  8919
  8920 				;	JMP	EXP10		;compute power of 10, return
  8921 					;SPACE	4,10
  8922 DDCC				ORG	EXP10
  8923 					;SPACE	4,10
  8924 				;	EXP10 - Compute Power of 10
  8925 				*
  8926 				*	ENTRY	JSR	EXP10
  8927 				*
  8928 				*	MODS
  8929 				*		Original Author Unknown
  8930 				*		1. Bring closer to Coding Standard (object unchanged).
  8931 				*		   R. K. Nordin	11/01/83
  8932
  8933
  8934 				;EXP10	=	*		;entry
  8935
  8936 				;	Initialize.
  8937
  8938 DDCC A9 00			LDA	#0
  8939 DDCE 85 F1			STA	XFMFLG		;zero integer part
  8940 DDD0 A5 D4			LDA	FR0
  8941 DDD2 85 F0			STA	SGNFLG		;save argument sign
  8942 DDD4 29 7F			AND	#$7F		;extract absolute value
  8943 DDD6 85 D4			STA	FR0		;update argument
  8944
  8945 				;	Check for argument less than 1.
  8946
  8947 DDD8 38				SEC
  8948 DDD9 E9 40			SBC	#$40		;subtract bias
  8949 DDDB 30 26			BMI	EXP1		;if argument < 1
  8950
  8951 				;	Extract integer and fractional parts of exponent.
  8952
  8953 DDDD C9 04			CMP	#FPREC-2
  8954 DDDF 10 6A			BPL	EXP6		;if argument too big, error
  8955
  8956 DDE1 A2 E6			LDX	#<FPSCR
  8957 DDE3 A0 05			LDY	#>FPSCR
  8958 DDE5 20 A7 DD			JSR	FST0R		;save argument
  8959 DDE8 20 D2 D9			JSR	FPI		;convert argument to integer
  8960 DDEB A5 D4			LDA	FR0
  8961 DDED 85 F1			STA	XFMFLG		;save interger part
  8962 DDEF A5 D5			LDA	FR0+1		;most significant byte of integer part
  8963 DDF1 D0 58			BNE	EXP6		;if integer part too large, error
  8964
  8965 DDF3 20 AA D9			JSR	IFP		;convert integer part to floating point
  8966 DDF6 20 B6 DD			JSR	FMOVE		;???
  8967 DDF9 A2 E6			LDX	#<FPSCR
  8968 DDFB A0 05			LDY	#>FPSCR
  8969 DDFD 20 89 DD			JSR	FLD0R		;argument
  8970 DE00 20 60 DA			JSR	FSUB		;subtract to get fractional part
  8971
  8972 				;	Compute 10 to fractional exponent.
  8973
  8974 DE03 A9 0A		EXP1	LDA	#NPCOEF
  8975 DE05 A2 4D			LDX	#<P10COF
  8976 DE07 A0 DE			LDY	#>P10COF
  8977 DE09 20 40 DD			JSR	PLYEVL		;P(X)
  8978 DE0C 20 B6 DD			JSR	FMOVE
  8979 DE0F 20 DB DA			JSR	FMUL		;P(X)*P(X)
  8980
  8981 				;	Check integer part.
  8982
  8983 DE12 A5 F1			LDA	XFMFLG		;integer part
  8984 DE14 F0 23			BEQ	EXP4		;if integer part zero
  8985
  8986 				;	Compute 10 to integer part.
  8987
  8988 DE16 18				CLC
  8989 DE17 6A				ROR		;integer part divided by 2
  8990 DE18 85 E0			STA	FR1		;exponent
  8991 DE1A A9 01			LDA	#1		;assume mantissa 1
  8992 DE1C 90 02			BCC	EXP2		;if integer part even
  8993
  8994 DE1E A9 10			LDA	#$10		;substitute mantissa 10
  8995
  8996 DE20 85 E1		EXP2	STA	FR1M		;mantissa
  8997 DE22 A2 04			LDX	#FMPREC-1	;offset to last byte of mantissa
  8998 DE24 A9 00			LDA	#0
  8999
  9000 DE26 95 E2		EXP3	STA	FR1M+1,X	;zero byte of mantissa
  9001 DE28 CA				DEX
  9002 DE29 10 FB			BPL	EXP3		;if not done
  9003
  9004 DE2B A5 E0			LDA	FR1		;exponent
  9005 DE2D 18				CLC
  9006 DE2E 69 40			ADC	#$40		;add bias
  9007 DE30 B0 19			BCS	EXP6		;if too big, error
  9008
  9009 DE32 30 17			BMI	EXP6		;if underflow, error
  9010
  9011 DE34 85 E0			STA	FR1		;10 to integer part
  9012
  9013 				;	Compute product of 10 to integer part and 10 to fractional part.
  9014
  9015 DE36 20 DB DA			JSR	FMUL		;multiply to get result
  9016
  9017 				;	Invert result if argument < 0.
  9018
  9019 DE39 A5 F0		EXP4	LDA	SGNFLG		;argument sign
  9020 DE3B 10 0D			BPL	EXP5		;if argument >= 0
  9021
  9022 DE3D 20 B6 DD			JSR	FMOVE
  9023 DE40 A2 8F			LDX	#<FONE
  9024 DE42 A0 DE			LDY	#>FONE
  9025 DE44 20 89 DD			JSR	FLD0R		;load FR0
  9026 DE47 20 28 DB			JSR	FDIV		;divide to get result
  9027
  9028 				;	Exit.
  9029
  9030 DE4A 60			EXP5	RTS			;return
  9031
  9032 				;	Return error.
  9033
  9034 DE4B 38			EXP6	SEC			;indicate error
  9035 DE4C 60				RTS			;return
  9036 					;SPACE	4,10
  9037 				;	P10COF - Power of 10 Coefficients
  9038
  9039
  9040 DE4D 3D 17 94 19 00 00	P10COF	.byte	$3D,$17,$94,$19,$00,$00	;0.0000179419
  9041 DE53 3D 57 33 05 00 00		.byte	$3D,$57,$33,$05,$00,$00	;0.0000573305
  9042 DE59 3E 05 54 76 62 00		.byte	$3E,$05,$54,$76,$62,$00	;0.0005547662
  9043 DE5F 3E 32 19 62 27 00		.byte	$3E,$32,$19,$62,$27,$00	;0.0032176227
  9044 DE65 3F 01 68 60 30 36		.byte	$3F,$01,$68,$60,$30,$36	;0.0168603036
  9045 DE6B 3F 07 32 03 27 41		.byte	$3F,$07,$32,$03,$27,$41	;0.0732032741
  9046 DE71 3F 25 43 34 56 75		.byte	$3F,$25,$43,$34,$56,$75	;0.2543345675
  9047 DE77 3F 66 27 37 30 50		.byte	$3F,$66,$27,$37,$30,$50	;0.6627373050
  9048 DE7D 40 01 15 12 92 55		.byte	$40,$01,$15,$12,$92,$55	;1.15129255
  9049 DE83 3F 99 99 99 99 99		.byte	$3F,$99,$99,$99,$99,$99	;0.9999999999
  9050
  9051 = 000A			NPCOEF	=	[*-P10COF]/FPREC
  9052 					;SPACE	4,10
  9053 				;	LOG10E - Base 10 Logarithm of e
  9054
  9055
  9056 DE89 3F 43 42 94 48 19	LOG10E	.byte	$3F,$43,$42,$94,$48,$19	;base 10 logarithm of e
  9057 					;SPACE	4,10
  9058 				;	FONE - 1.0
  9059
  9060
  9061 DE8F 40 01 00 00 00 00	FONE	.byte	$40,$01,$00,$00,$00,$00	;1.0
  9062 					;SPACE	4,10
  9063 				;	XFORM - Transform
  9064 				*
  9065 				*	Z = (X-C)/(X+C)
  9066 				*
  9067 				*	ENTRY	JSR	XFORM
  9068 				*
  9069 				*	MODS
  9070 				*		Original Author Unknown
  9071 				*		1. Bring closer to Coding Standard (object unchanged).
  9072 				*		   R. K. Nordin	11/01/83
  9073
  9074
  9075 = DE95			XFORM	=	*		;entry
  9076 DE95 86 FE			STX	FPTR2
  9077 DE97 84 FF			STY	FPTR2+1
  9078 DE99 A2 E0			LDX	#<PLYARG
  9079 DE9B A0 05			LDY	#>PLYARG
  9080 DE9D 20 A7 DD			JSR	FST0R		;save argument
  9081 DEA0 A6 FE			LDX	FPTR2
  9082 DEA2 A4 FF			LDY	FPTR2+1
  9083 DEA4 20 98 DD			JSR	FLD1R		;load FR1
  9084 DEA7 20 66 DA			JSR	FADD		;X+C
  9085 DEAA A2 E6			LDX	#<FPSCR
  9086 DEAC A0 05			LDY	#>FPSCR
  9087 DEAE 20 A7 DD			JSR	FST0R		;store FR0
  9088 DEB1 A2 E0			LDX	#<PLYARG
  9089 DEB3 A0 05			LDY	#>PLYARG
  9090 DEB5 20 89 DD			JSR	FLD0R		;load FR0
  9091 DEB8 A6 FE			LDX	FPTR2
  9092 DEBA A4 FF			LDY	FPTR2+1
  9093 DEBC 20 98 DD			JSR	FLD1R		;load FR1
  9094 DEBF 20 60 DA			JSR	FSUB		;X-C
  9095 DEC2 A2 E6			LDX	#<FPSCR
  9096 DEC4 A0 05			LDY	#>FPSCR
  9097 DEC6 20 98 DD			JSR	FLD1R		;load FR1
  9098 DEC9 20 28 DB			JSR	FDIV		;divide to get result
  9099 DECC 60				RTS			;return
  9100 					;SPACE	4,10
  9101 DECD				ORG	LOG
  9102 					;SPACE	4,10
  9103 				;	LOG - Compute Base e Logarithm
  9104 				*
  9105 				*	ENTRY	JSR	LOG
  9106 				*		FR0 - FR0+5 = argument
  9107 				*
  9108 				*	MODS
  9109 				*		Original Author Unknown
  9110 				*		1. Bring closer to Coding Standard (object unchanged).
  9111 				*		   R. K. Nordin	11/01/83
  9112
  9113
  9114 				;LOG	=	*	;entry
  9115
  9116 DECD A9 01			LDA	#1	;indicate base e logarithm
  9117 DECF D0 02			BNE	LOGS	;compute logartihm, return
  9118 					;SPACE	4,10
  9119 DED1				ORG	LOG10
  9120 					;SPACE	4,10
  9121 				;	LOG10 - Compute Base 10 Logarithm
  9122 				*
  9123 				*	ENTRY	JSR	LOG10
  9124 				*		FR0 - FR0+5 = argument
  9125 				*
  9126 				*	MODS
  9127 				*		Original Author Unknown
  9128 				*		1. Bring closer to Coding Standard (object unchanged).
  9129 				*		   R. K. Nordin	11/01/83
  9130
  9131
  9132 				;LOG10	=	*	;entry
  9133
  9134 DED1 A9 00			LDA	#0	;indicate base 10 logartihm
  9135 				;	JMP	LOGS	;compute logarithm, return
  9136 					;SPACE	4,10
  9137 				;	LOGS - Compute Logarithm
  9138 				*
  9139 				*	ENTRY	JSR	LOGS
  9140 				*		A = 0, if base 10 logarithm
  9141 				*		  = 1, if base e logartihm
  9142 				*		FR0 - FR0+5 = argument
  9143 				*
  9144 				*	EXIT
  9145 				*		C set, if error
  9146 				*		C clear, if no error
  9147 				*		FR0 - FR0+5 = result
  9148 				*
  9149 				*	MODS
  9150 				*		Original Author Unknown
  9151 				*		1. Bring closer to Coding Standard (object unchanged).
  9152 				*		   R. K. Nordin	11/01/83
  9153
  9154
  9155 = DED3			LOGS	=	*	;entry
  9156
  9157 				;	Initialize.
  9158
  9159 DED3 85 F0			STA	SGNFLG	;save logarithm base indicator
  9160
  9161 				;	Check argument.
  9162
  9163 DED5 A5 D4			LDA	FR0	;argument exponent
  9164 DED7 F0 05			BEQ	LOGS1	;if argument zero, error
  9165
  9166 DED9 30 03			BMI	LOGS1	;if argument negative, error
  9167
  9168 				;	X = F*(10^Y), 1<F<10
  9169 				;	10^Y HAS SAME EXP BYTE AS X
  9170 				;	& MANTISSA BYTE = 1 OR 10
  9171
  9172 DEDB 4C F6 DF			JMP	LOGQ
  9173
  9174 				;	Return error.
  9175
  9176 DEDE 38			LOGS1	SEC		;indicate error
  9177 DEDF 60				RTS		;return
  9178 					;SPACE	4,10
  9179 				;	LOGC - Complete Computation of Logarithm
  9180 				*
  9181 				*	ENTRY	JSR	LOGC
  9182 				*		SGNFLG = 0, if base 10 logarithmr
  9183 				*		       = 1, if base e logarithm
  9184 				*
  9185 				*	NOTES
  9186 				*		Problem: logic is convoluted because LOGQ code
  9187 				*		was moved.
  9188 				*
  9189 				*	MODS
  9190 				*		Original Author Unknown
  9191 				*		1. Bring closer to Coding Standard (object unchanged).
  9192 				*		   R. K. Nordin	11/01/83
  9193
  9194
  9195 = DEE0			LOGC	=	*		;entry
  9196
  9197 				;	Initialize.
  9198
  9199 DEE0 E9 40			SBC	#$40
  9200 DEE2 0A				ASL
  9201 DEE3 85 F1			STA	XFMFLG		;save Y
  9202 DEE5 A5 D5			LDA	FR0+1
  9203 DEE7 29 F0			AND	#$F0
  9204 DEE9 D0 04			BNE	LOGC2
  9205
  9206 DEEB A9 01			LDA	#1		;mantissa is 1
  9207 DEED D0 04			BNE	LOGC3		;set mantissa
  9208
  9209 DEEF E6 F1		LOGC2	INC	XFMFLG		;increment Y
  9210 DEF1 A9 10			LDA	#$10		;mantissa is 10
  9211
  9212 DEF3 85 E1		LOGC3	STA	FR1M		;mantissa
  9213 DEF5 A2 04			LDX	#FMPREC-1	;offset to last byte of mantissa
  9214 DEF7 A9 00			LDA	#0
  9215
  9216 DEF9 95 E2		LOGC4	STA	FR1M+1,X	;zero byte of mantissa
  9217 DEFB CA				DEX
  9218 DEFC 10 FB			BPL	LOGC4		;if not done
  9219
  9220 DEFE 20 28 DB			JSR	FDIV		;X = X/(10^Y), S.B. IN (1,10)
  9221
  9222 				;	Compute LOG10(X), 1 <= X <= 10.
  9223
  9224 DF01 A2 66			LDX	#<SQR10
  9225 DF03 A0 DF			LDY	#>SQR10
  9226 DF05 20 95 DE			JSR	XFORM		;Z = (X-C)/(X+C); C*C = 10
  9227 DF08 A2 E6			LDX	#<FPSCR
  9228 DF0A A0 05			LDY	#>FPSCR
  9229 DF0C 20 A7 DD			JSR	FST0R		;SAVE Z
  9230 DF0F 20 B6 DD			JSR	FMOVE
  9231 DF12 20 DB DA			JSR	FMUL		;Z*Z
  9232 DF15 A9 0A			LDA	#NLCOEF
  9233 DF17 A2 72			LDX	#<LGCOEF
  9234 DF19 A0 DF			LDY	#>LGCOEF
  9235 DF1B 20 40 DD			JSR	PLYEVL		;P(Z*Z)
  9236 DF1E A2 E6			LDX	#<FPSCR
  9237 DF20 A0 05			LDY	#>FPSCR
  9238 DF22 20 98 DD			JSR	FLD1R		;load FR1
  9239 DF25 20 DB DA			JSR	FMUL		;Z*P(Z*Z)
  9240 DF28 A2 6C			LDX	#<FHALF
  9241 DF2A A0 DF			LDY	#>FHALF
  9242 DF2C 20 98 DD			JSR	FLD1R
  9243 DF2F 20 66 DA			JSR	FADD		;0.5 + Z*P(Z*Z)
  9244 DF32 20 B6 DD			JSR	FMOVE
  9245 DF35 A9 00			LDA	#0
  9246 DF37 85 D5			STA	FR0+1
  9247 DF39 A5 F1			LDA	XFMFLG
  9248 DF3B 85 D4			STA	FR0
  9249 DF3D 10 07			BPL	LOGC5
  9250
  9251 DF3F 49 FF			EOR	#-$01		;complement sign
  9252 DF41 18				CLC
  9253 DF42 69 01			ADC	#1
  9254 DF44 85 D4			STA	FR0
  9255
  9256 DF46 20 AA D9		LOGC5	JSR	IFP		;convert integer to floating point
  9257 DF49 24 F1			BIT	XFMFLG
  9258 DF4B 10 06			BPL	LOGC6
  9259
  9260 DF4D A9 80			LDA	#$80
  9261 DF4F 05 D4			ORA	FR0
  9262 DF51 85 D4			STA	FR0		;update exponent
  9263
  9264 DF53 20 66 DA		LOGC6	JSR	FADD		;LOG(X) = LOG(X)+Y
  9265
  9266 				;	Check base of logarithm.
  9267
  9268 DF56 A5 F0			LDA	SGNFLG		;logarithm base indicator
  9269 DF58 F0 0A			BEQ	LOGC7		;if LOG10 (not LOG)
  9270
  9271 				;	Compute base e logarithm.
  9272
  9273 DF5A A2 89			LDX	#<LOG10E	;base 10 logarithm of e
  9274 DF5C A0 DE			LDY	#>LOG10E
  9275 DF5E 20 98 DD			JSR	FLD1R		;load FR1
  9276 DF61 20 28 DB			JSR	FDIV		;result is LOG(X) divided by LOG10(e)
  9277
  9278 				;	Exit.
  9279
  9280 DF64 18			LOGC7	CLC			;indicate success
  9281 DF65 60				RTS			;return
  9282 					;SPACE	4,10
  9283 				;	SQR10 - Square Root of 10
  9284
  9285
  9286 DF66 40 03 16 22 77 66	SQR10	.byte	$40,$03,$16,$22,$77,$66	;square root of 10
  9287 					;SPACE	4,10
  9288 				;	FHALF - 0.5
  9289
  9290
  9291 DF6C 3F 50 00 00 00 00	FHALF	.byte	$3F,$50,$00,$00,$00,$00	;0.5
  9292 					;SPACE	4,10
  9293 				;	LGCOEF - Logartihm Coefficients
  9294
  9295
  9296 DF72 3F 49 15 57 11 08	LGCOEF	.byte	$3F,$49,$15,$57,$11,$08	;0.4915571108
  9297 DF78 BF 51 70 49 47 08		.byte	$BF,$51,$70,$49,$47,$08	;-0.5170494708
  9298 DF7E 3F 39 20 57 61 95		.byte	$3F,$39,$20,$57,$61,$95	;0.3920576195
  9299 DF84 BF 04 39 63 03 55		.byte	$BF,$04,$39,$63,$03,$55	;-0.0439630355
  9300 DF8A 3F 10 09 30 12 64		.byte	$3F,$10,$09,$30,$12,$64	;0.1009301264
  9301 DF90 3F 09 39 08 04 60		.byte	$3F,$09,$39,$08,$04,$60	;0.0939080460
  9302 DF96 3F 12 42 58 47 42		.byte	$3F,$12,$42,$58,$47,$42	;0.1242584742
  9303 DF9C 3F 17 37 12 06 08		.byte	$3F,$17,$37,$12,$06,$08	;0.1737120608
  9304 DFA2 3F 28 95 29 71 17		.byte	$3F,$28,$95,$29,$71,$17	;0.2895297117
  9305 DFA8 3F 86 85 88 96 44		.byte	$3F,$86,$85,$88,$96,$44	;0.8685889644
  9306
  9307 = 000A			NLCOEF	=	[*-LGCOEF]/FPREC
  9308 					;SPACE	4,10
  9309 				;	ATCOEF - Arctangent Coefficients
  9310 				*
  9311 				*	NOTES
  9312 				*		Problem: not used.
  9313
  9314
  9315 DFAE 3E 16 05 44 49 00		.byte	$3E,$16,$05,$44,$49,$00	;0.001605444900
  9316 DFB4 BE 95 68 38 45 00		.byte	$BE,$95,$68,$38,$45,$00	;-0.009568384500
  9317 DFBA 3F 02 68 79 94 16		.byte	$3F,$02,$68,$79,$94,$16	;0.0268799416
  9318 DFC0 BF 04 92 78 90 80		.byte	$BF,$04,$92,$78,$90,$80	;-0.0492789080
  9319 DFC6 3F 07 03 15 20 00		.byte	$3F,$07,$03,$15,$20,$00	;0.0703152000
  9320 DFCC BF 08 92 29 12 44		.byte	$BF,$08,$92,$29,$12,$44	;-0.0892291244
  9321 DFD2 3F 11 08 40 09 11		.byte	$3F,$11,$08,$40,$09,$11	;0.1108400911
  9322 DFD8 BF 14 28 31 56 04		.byte	$BF,$14,$28,$31,$56,$04	;-0.1428315604
  9323 DFDE 3F 19 99 98 77 44		.byte	$3F,$19,$99,$98,$77,$44	;0.1999987744
  9324 DFE4 BF 33 33 33 31 13		.byte	$BF,$33,$33,$33,$31,$13	;-0.3333333113
  9325 DFEA 3F 99 99 99 99 99		.byte	$3F,$99,$99,$99,$99,$99	;0.9999999999
  9326
  9327 DFF0 3F 78 53 98 16 34		.byte	$3F,$78,$53,$98,$16,$34	;pi/4 = arctan 1
  9328 					;SPACE	4,10
  9329 				;	LOGQ - Continue Computation of Loagarithm
  9330 				*
  9331 				*	ENTRY	JSR	LOGQ
  9332 				*
  9333 				*	NOTES
  9334 				*		Problem: logic is convoluted because this code was
  9335 				*		moved.
  9336 				*		Problem: for readability, this might be relocated
  9337 				*		before tables.
  9338 				*
  9339 				*	MODS
  9340 				*		Original Author Unknown
  9341 				*		1. Bring closer to Coding Standard (object unchanged).
  9342 				*		   R. K. Nordin	11/01/83
  9343
  9344
  9345 = DFF6			LOGQ	=	*	;entry
  9346 DFF6 A5 D4			LDA	FR0
  9347 DFF8 85 E0			STA	FR1
  9348 DFFA 38				SEC
  9349 DFFB 4C E0 DE			JMP	LOGC	;complete computation of logarithm, return
  9350 				;	;SUBTTL	'Domestic Character Set'
  9351 					;SPACE	4,10
  9352 DFFE				ORG	DCSORG
  9353 					;SPACE	4,10
  9354 				;	Domestic Character Set
  9355
  9356
  9357 E000 00 00 00 00 00 00 + 	.byte	$00,$00,$00,$00,$00,$00,$00,$00	;$00 - space
  9358 E008 00 18 18 18 18 00 + 	.byte	$00,$18,$18,$18,$18,$00,$18,$00	;$01 - !
  9359 E010 00 66 66 66 00 00 + 	.byte	$00,$66,$66,$66,$00,$00,$00,$00	;$02 - "
  9360 E018 00 66 FF 66 66 FF + 	.byte	$00,$66,$FF,$66,$66,$FF,$66,$00	;$03 - #
  9361 E020 18 3E 60 3C 06 7C + 	.byte	$18,$3E,$60,$3C,$06,$7C,$18,$00	;$04 - $
  9362 E028 00 66 6C 18 30 66 + 	.byte	$00,$66,$6C,$18,$30,$66,$46,$00	;$05 - %
  9363 E030 1C 36 1C 38 6F 66 + 	.byte	$1C,$36,$1C,$38,$6F,$66,$3B,$00	;$06 - &
  9364 E038 00 18 18 18 00 00 + 	.byte	$00,$18,$18,$18,$00,$00,$00,$00	;$07 - '
  9365 E040 00 0E 1C 18 18 1C + 	.byte	$00,$0E,$1C,$18,$18,$1C,$0E,$00	;$08 - (
  9366 E048 00 70 38 18 18 38 + 	.byte	$00,$70,$38,$18,$18,$38,$70,$00	;$09 - )
  9367 E050 00 66 3C FF 3C 66 + 	.byte	$00,$66,$3C,$FF,$3C,$66,$00,$00	;$0A - asterisk
  9368 E058 00 18 18 7E 18 18 + 	.byte	$00,$18,$18,$7E,$18,$18,$00,$00	;$0B - plus
  9369 E060 00 00 00 00 00 18 + 	.byte	$00,$00,$00,$00,$00,$18,$18,$30	;$0C - comma
  9370 E068 00 00 00 7E 00 00 + 	.byte	$00,$00,$00,$7E,$00,$00,$00,$00	;$0D - minus
  9371 E070 00 00 00 00 00 18 + 	.byte	$00,$00,$00,$00,$00,$18,$18,$00	;$0E - period
  9372 E078 00 06 0C 18 30 60 + 	.byte	$00,$06,$0C,$18,$30,$60,$40,$00	;$0F - /
  9373
  9374 E080 00 3C 66 6E 76 66 + 	.byte	$00,$3C,$66,$6E,$76,$66,$3C,$00	;$10 - 0
  9375 E088 00 18 38 18 18 18 + 	.byte	$00,$18,$38,$18,$18,$18,$7E,$00	;$11 - 1
  9376 E090 00 3C 66 0C 18 30 + 	.byte	$00,$3C,$66,$0C,$18,$30,$7E,$00	;$12 - 2
  9377 E098 00 7E 0C 18 0C 66 + 	.byte	$00,$7E,$0C,$18,$0C,$66,$3C,$00	;$13 - 3
  9378 E0A0 00 0C 1C 3C 6C 7E + 	.byte	$00,$0C,$1C,$3C,$6C,$7E,$0C,$00	;$14 - 4
  9379 E0A8 00 7E 60 7C 06 66 + 	.byte	$00,$7E,$60,$7C,$06,$66,$3C,$00	;$15 - 5
  9380 E0B0 00 3C 60 7C 66 66 + 	.byte	$00,$3C,$60,$7C,$66,$66,$3C,$00	;$16 - 6
  9381 E0B8 00 7E 06 0C 18 30 + 	.byte	$00,$7E,$06,$0C,$18,$30,$30,$00	;$17 - 7
  9382 E0C0 00 3C 66 3C 66 66 + 	.byte	$00,$3C,$66,$3C,$66,$66,$3C,$00	;$18 - 8
  9383 E0C8 00 3C 66 3E 06 0C + 	.byte	$00,$3C,$66,$3E,$06,$0C,$38,$00	;$19 - 9
  9384 E0D0 00 00 18 18 00 18 + 	.byte	$00,$00,$18,$18,$00,$18,$18,$00	;$1A - colon
  9385 E0D8 00 00 18 18 00 18 + 	.byte	$00,$00,$18,$18,$00,$18,$18,$30	;$1B - semicolon
  9386 E0E0 06 0C 18 30 18 0C + 	.byte	$06,$0C,$18,$30,$18,$0C,$06,$00	;$1C - <
  9387 E0E8 00 00 7E 00 00 7E + 	.byte	$00,$00,$7E,$00,$00,$7E,$00,$00	;$1D - =
  9388 E0F0 60 30 18 0C 18 30 + 	.byte	$60,$30,$18,$0C,$18,$30,$60,$00	;$1E - >
  9389 E0F8 00 3C 66 0C 18 00 + 	.byte	$00,$3C,$66,$0C,$18,$00,$18,$00	;$1F - ?
  9390
  9391 E100 00 3C 66 6E 6E 60 + 	.byte	$00,$3C,$66,$6E,$6E,$60,$3E,$00	;$20 - @
  9392 E108 00 18 3C 66 66 7E + 	.byte	$00,$18,$3C,$66,$66,$7E,$66,$00	;$21 - A
  9393 E110 00 7C 66 7C 66 66 + 	.byte	$00,$7C,$66,$7C,$66,$66,$7C,$00	;$22 - B
  9394 E118 00 3C 66 60 60 66 + 	.byte	$00,$3C,$66,$60,$60,$66,$3C,$00	;$23 - C
  9395 E120 00 78 6C 66 66 6C + 	.byte	$00,$78,$6C,$66,$66,$6C,$78,$00	;$24 - D
  9396 E128 00 7E 60 7C 60 60 + 	.byte	$00,$7E,$60,$7C,$60,$60,$7E,$00	;$25 - E
  9397 E130 00 7E 60 7C 60 60 + 	.byte	$00,$7E,$60,$7C,$60,$60,$60,$00	;$26 - F
  9398 E138 00 3E 60 60 6E 66 + 	.byte	$00,$3E,$60,$60,$6E,$66,$3E,$00	;$27 - G
  9399 E140 00 66 66 7E 66 66 + 	.byte	$00,$66,$66,$7E,$66,$66,$66,$00	;$28 - H
  9400 E148 00 7E 18 18 18 18 + 	.byte	$00,$7E,$18,$18,$18,$18,$7E,$00	;$29 - I
  9401 E150 00 06 06 06 06 66 + 	.byte	$00,$06,$06,$06,$06,$66,$3C,$00	;$2A - J
  9402 E158 00 66 6C 78 78 6C + 	.byte	$00,$66,$6C,$78,$78,$6C,$66,$00	;$2B - K
  9403 E160 00 60 60 60 60 60 + 	.byte	$00,$60,$60,$60,$60,$60,$7E,$00	;$2C - L
  9404 E168 00 63 77 7F 6B 63 + 	.byte	$00,$63,$77,$7F,$6B,$63,$63,$00	;$2D - M
  9405 E170 00 66 76 7E 7E 6E + 	.byte	$00,$66,$76,$7E,$7E,$6E,$66,$00	;$2E - N
  9406 E178 00 3C 66 66 66 66 + 	.byte	$00,$3C,$66,$66,$66,$66,$3C,$00	;$2F - O
  9407
  9408 E180 00 7C 66 66 7C 60 + 	.byte	$00,$7C,$66,$66,$7C,$60,$60,$00	;$30 - P
  9409 E188 00 3C 66 66 66 6C + 	.byte	$00,$3C,$66,$66,$66,$6C,$36,$00	;$31 - Q
  9410 E190 00 7C 66 66 7C 6C + 	.byte	$00,$7C,$66,$66,$7C,$6C,$66,$00	;$32 - R
  9411 E198 00 3C 60 3C 06 06 + 	.byte	$00,$3C,$60,$3C,$06,$06,$3C,$00	;$33 - S
  9412 E1A0 00 7E 18 18 18 18 + 	.byte	$00,$7E,$18,$18,$18,$18,$18,$00	;$34 - T
  9413 E1A8 00 66 66 66 66 66 + 	.byte	$00,$66,$66,$66,$66,$66,$7E,$00	;$35 - U
  9414 E1B0 00 66 66 66 66 3C + 	.byte	$00,$66,$66,$66,$66,$3C,$18,$00	;$36 - V
  9415 E1B8 00 63 63 6B 7F 77 + 	.byte	$00,$63,$63,$6B,$7F,$77,$63,$00	;$37 - W
  9416 E1C0 00 66 66 3C 3C 66 + 	.byte	$00,$66,$66,$3C,$3C,$66,$66,$00	;$38 - X
  9417 E1C8 00 66 66 3C 18 18 + 	.byte	$00,$66,$66,$3C,$18,$18,$18,$00	;$39 - Y
  9418 E1D0 00 7E 0C 18 30 60 + 	.byte	$00,$7E,$0C,$18,$30,$60,$7E,$00	;$3A - Z
  9419 E1D8 00 1E 18 18 18 18 + 	.byte	$00,$1E,$18,$18,$18,$18,$1E,$00	;$3B - [
  9420 E1E0 00 40 60 30 18 0C + 	.byte	$00,$40,$60,$30,$18,$0C,$06,$00	;$3C - \
  9421 E1E8 00 78 18 18 18 18 + 	.byte	$00,$78,$18,$18,$18,$18,$78,$00	;$3D - ]
  9422 E1F0 00 08 1C 36 63 00 + 	.byte	$00,$08,$1C,$36,$63,$00,$00,$00	;$3E - ^
  9423 E1F8 00 00 00 00 00 00 + 	.byte	$00,$00,$00,$00,$00,$00,$FF,$00	;$3F - underline
  9424
  9425 E200 00 36 7F 7F 3E 1C + 	.byte	$00,$36,$7F,$7F,$3E,$1C,$08,$00	;$40 - heart card
  9426 E208 18 18 18 1F 1F 18 + 	.byte	$18,$18,$18,$1F,$1F,$18,$18,$18	;$41 - mid left window
  9427 E210 03 03 03 03 03 03 + 	.byte	$03,$03,$03,$03,$03,$03,$03,$03	;$42 - right box
  9428 E218 18 18 18 F8 F8 00 + 	.byte	$18,$18,$18,$F8,$F8,$00,$00,$00	;$43 - low right window
  9429 E220 18 18 18 F8 F8 18 + 	.byte	$18,$18,$18,$F8,$F8,$18,$18,$18	;$44 - mid right window
  9430 E228 00 00 00 F8 F8 18 + 	.byte	$00,$00,$00,$F8,$F8,$18,$18,$18	;$45 - up right window
  9431 E230 03 07 0E 1C 38 70 + 	.byte	$03,$07,$0E,$1C,$38,$70,$E0,$C0	;$46 - right slant box
  9432 E238 C0 E0 70 38 1C 0E + 	.byte	$C0,$E0,$70,$38,$1C,$0E,$07,$03	;$47 - left slant box
  9433 E240 01 03 07 0F 1F 3F + 	.byte	$01,$03,$07,$0F,$1F,$3F,$7F,$FF	;$48 - right slant solid
  9434 E248 00 00 00 00 0F 0F + 	.byte	$00,$00,$00,$00,$0F,$0F,$0F,$0F	;$49 - low right solid
  9435 E250 80 C0 E0 F0 F8 FC + 	.byte	$80,$C0,$E0,$F0,$F8,$FC,$FE,$FF	;$4A - left slant solid
  9436 E258 0F 0F 0F 0F 00 00 + 	.byte	$0F,$0F,$0F,$0F,$00,$00,$00,$00	;$4B - up right solid
  9437 E260 F0 F0 F0 F0 00 00 + 	.byte	$F0,$F0,$F0,$F0,$00,$00,$00,$00	;$4C - up left solid
  9438 E268 FF FF 00 00 00 00 + 	.byte	$FF,$FF,$00,$00,$00,$00,$00,$00	;$4D - top box
  9439 E270 00 00 00 00 00 00 + 	.byte	$00,$00,$00,$00,$00,$00,$FF,$FF	;$4E - bottom box
  9440 E278 00 00 00 00 F0 F0 + 	.byte	$00,$00,$00,$00,$F0,$F0,$F0,$F0	;$4F - low left solid
  9441
  9442 E280 00 1C 1C 77 77 08 + 	.byte	$00,$1C,$1C,$77,$77,$08,$1C,$00	;$50 - club card
  9443 E288 00 00 00 1F 1F 18 + 	.byte	$00,$00,$00,$1F,$1F,$18,$18,$18	;$51 - up left window
  9444 E290 00 00 00 FF FF 00 + 	.byte	$00,$00,$00,$FF,$FF,$00,$00,$00	;$52 - mid box
  9445 E298 18 18 18 FF FF 18 + 	.byte	$18,$18,$18,$FF,$FF,$18,$18,$18	;$53 - mid window
  9446 E2A0 00 00 3C 7E 7E 7E + 	.byte	$00,$00,$3C,$7E,$7E,$7E,$3C,$00	;$54 - solid circle
  9447 E2A8 00 00 00 00 FF FF + 	.byte	$00,$00,$00,$00,$FF,$FF,$FF,$FF	;$55 - bottom solid
  9448 E2B0 C0 C0 C0 C0 C0 C0 + 	.byte	$C0,$C0,$C0,$C0,$C0,$C0,$C0,$C0	;$56 - left box
  9449 E2B8 00 00 00 FF FF 18 + 	.byte	$00,$00,$00,$FF,$FF,$18,$18,$18	;$57 - up mid window
  9450 E2C0 18 18 18 FF FF 00 + 	.byte	$18,$18,$18,$FF,$FF,$00,$00,$00	;$58 - low mid window
  9451 E2C8 F0 F0 F0 F0 F0 F0 + 	.byte	$F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0	;$59 - left solid
  9452 E2D0 18 18 18 1F 1F 00 + 	.byte	$18,$18,$18,$1F,$1F,$00,$00,$00	;$5A - low left window
  9453 E2D8 78 60 78 60 7E 18 + 	.byte	$78,$60,$78,$60,$7E,$18,$1E,$00	;$5B - display escape
  9454 E2E0 00 18 3C 7E 18 18 + 	.byte	$00,$18,$3C,$7E,$18,$18,$18,$00	;$5C - up arrow
  9455 E2E8 00 18 18 18 7E 3C + 	.byte	$00,$18,$18,$18,$7E,$3C,$18,$00	;$5D - down arrow
  9456 E2F0 00 18 30 7E 30 18 + 	.byte	$00,$18,$30,$7E,$30,$18,$00,$00	;$5E - left arrow
  9457 E2F8 00 18 0C 7E 0C 18 + 	.byte	$00,$18,$0C,$7E,$0C,$18,$00,$00	;$5F - right arrow
  9458
  9459 E300 00 18 3C 7E 7E 3C + 	.byte	$00,$18,$3C,$7E,$7E,$3C,$18,$00	;$60 - diamond card
  9460 E308 00 00 3C 06 3E 66 + 	.byte	$00,$00,$3C,$06,$3E,$66,$3E,$00	;$61 - a
  9461 E310 00 60 60 7C 66 66 + 	.byte	$00,$60,$60,$7C,$66,$66,$7C,$00	;$62 - b
  9462 E318 00 00 3C 60 60 60 + 	.byte	$00,$00,$3C,$60,$60,$60,$3C,$00	;$63 - c
  9463 E320 00 06 06 3E 66 66 + 	.byte	$00,$06,$06,$3E,$66,$66,$3E,$00	;$64 - d
  9464 E328 00 00 3C 66 7E 60 + 	.byte	$00,$00,$3C,$66,$7E,$60,$3C,$00	;$65 - e
  9465 E330 00 0E 18 3E 18 18 + 	.byte	$00,$0E,$18,$3E,$18,$18,$18,$00	;$66 - f
  9466 E338 00 00 3E 66 66 3E + 	.byte	$00,$00,$3E,$66,$66,$3E,$06,$7C	;$67 - g
  9467 E340 00 60 60 7C 66 66 + 	.byte	$00,$60,$60,$7C,$66,$66,$66,$00	;$68 - h
  9468 E348 00 18 00 38 18 18 + 	.byte	$00,$18,$00,$38,$18,$18,$3C,$00	;$69 - i
  9469 E350 00 06 00 06 06 06 + 	.byte	$00,$06,$00,$06,$06,$06,$06,$3C	;$6A - j
  9470 E358 00 60 60 6C 78 6C + 	.byte	$00,$60,$60,$6C,$78,$6C,$66,$00	;$6B - k
  9471 E360 00 38 18 18 18 18 + 	.byte	$00,$38,$18,$18,$18,$18,$3C,$00	;$6C - l
  9472 E368 00 00 66 7F 7F 6B + 	.byte	$00,$00,$66,$7F,$7F,$6B,$63,$00	;$6D - m
  9473 E370 00 00 7C 66 66 66 + 	.byte	$00,$00,$7C,$66,$66,$66,$66,$00	;$6E - n
  9474 E378 00 00 3C 66 66 66 + 	.byte	$00,$00,$3C,$66,$66,$66,$3C,$00	;$6F - o
  9475
  9476 E380 00 00 7C 66 66 7C + 	.byte	$00,$00,$7C,$66,$66,$7C,$60,$60	;$70 - p
  9477 E388 00 00 3E 66 66 3E + 	.byte	$00,$00,$3E,$66,$66,$3E,$06,$06	;$71 - q
  9478 E390 00 00 7C 66 60 60 + 	.byte	$00,$00,$7C,$66,$60,$60,$60,$00	;$72 - r
  9479 E398 00 00 3E 60 3C 06 + 	.byte	$00,$00,$3E,$60,$3C,$06,$7C,$00	;$73 - s
  9480 E3A0 00 18 7E 18 18 18 + 	.byte	$00,$18,$7E,$18,$18,$18,$0E,$00	;$74 - t
  9481 E3A8 00 00 66 66 66 66 + 	.byte	$00,$00,$66,$66,$66,$66,$3E,$00	;$75 - u
  9482 E3B0 00 00 66 66 66 3C + 	.byte	$00,$00,$66,$66,$66,$3C,$18,$00	;$76 - v
  9483 E3B8 00 00 63 6B 7F 3E + 	.byte	$00,$00,$63,$6B,$7F,$3E,$36,$00	;$77 - w
  9484 E3C0 00 00 66 3C 18 3C + 	.byte	$00,$00,$66,$3C,$18,$3C,$66,$00	;$78 - x
  9485 E3C8 00 00 66 66 66 3E + 	.byte	$00,$00,$66,$66,$66,$3E,$0C,$78	;$79 - y
  9486 E3D0 00 00 7E 0C 18 30 + 	.byte	$00,$00,$7E,$0C,$18,$30,$7E,$00	;$7A - z
  9487 E3D8 00 18 3C 7E 7E 18 + 	.byte	$00,$18,$3C,$7E,$7E,$18,$3C,$00	;$7B - spade card
  9488 E3E0 18 18 18 18 18 18 + 	.byte	$18,$18,$18,$18,$18,$18,$18,$18	;$7C - |
  9489 E3E8 00 7E 78 7C 6E 66 + 	.byte	$00,$7E,$78,$7C,$6E,$66,$06,$00	;$7D - display clear
  9490 E3F0 08 18 38 78 38 18 + 	.byte	$08,$18,$38,$78,$38,$18,$08,$00	;$7E - display backspace
  9491 E3F8 10 18 1C 1E 1C 18 + 	.byte	$10,$18,$1C,$1E,$1C,$18,$10,$00	;$7F - display tab
  9492 				;	;SUBTTL	'Device Handler Vector Tables'
  9493 					;SPACE	4,10
  9494 E400				ORG	EDITRV
  9495 					;SPACE	4,10
  9496 				;	EDITRV - Editor Handler Vector Table
  9497
  9498
  9499 E400 93 EF			.word	EOP-1	;perform editor OPEN
  9500 E402 2D F2			.word	ECL-1	;perform editor CLOSE
  9501 E404 49 F2			.word	EGB-1	;perform editor GET-BYTE
  9502 E406 AF F2			.word	EPB-1	;perform editor PUT-BYTE
  9503 E408 1D F2			.word	SST-1	;perform editor STATUS (screen STAT:
  9504 E40A 2C F2			.word	ESP-1	;perform editor SPECIAL
  9505 E40C 4C 6E EF			JMP	SIN	;initialize editor (initialize scre:
  9506 E40F 00				.byte	0	;reserved
  9507 					;SPACE	4,10
  9508 E410				ORG	SCRENV
  9509 					;SPACE	4,10
  9510 				;	SCRENV - Screen Handler Vector Table
  9511
  9512
  9513 E410 8D EF			.word	SOP-1	;perform screen OPEN
  9514 E412 2D F2			.word	ECL-1	;perform screen CLOSE (editor CLOSE:
  9515 E414 7F F1			.word	SGB-1	;perform screen GET-BYTE
  9516 E416 A3 F1			.word	SPB-1	;perform screen PUT-BYTE
  9517 E418 1D F2			.word	SST-1	;perform screen STATUS
  9518 E41A AE F9			.word	SSP-1	;perform screen SPECIAL
  9519 E41C 4C 6E EF			JMP	SIN	;initialize screen
  9520 E41F 00				.byte	0	;reserved
  9521 					;SPACE	4,10
  9522 E420				ORG	KEYBDV
  9523 					;SPACE	4,10
  9524 				;	KEYBDV - Keyboard Handler Vector Table
  9525
  9526
  9527 E420 1D F2			.word	SST-1	;perform keyboard OPEN (screen STAT:
  9528 E422 1D F2			.word	SST-1	;perform keyboard CLOSE (screen STA:
  9529 E424 FC F2			.word	KGB-1	;perform keyboard GET-BYTE
  9530 E426 2C F2			.word	ESP-1	;perform keyboard SPECIAL (editor S:
  9531 E428 1D F2			.word	SST-1	;perform keyboard STATUS (screen ST:
  9532 E42A 2C F2			.word	ESP-1	;perform keyboard SPECIAL (editor S:
  9533 E42C 4C 6E EF			JMP	SIN	;initialize keyboard (initialize sc:
  9534 E42F 00				.byte	0	;reserved
  9535 					;SPACE	4,10
  9536 E430				ORG	PRINTV
  9537 					;SPACE	4,10
  9538 				;	PRINTV - Printer Handler Vector Table
  9539
  9540
  9541 E430 C1 FE			.word	POP-1	;perform printer OPEN
  9542 E432 06 FF			.word	PCL-1	;perform printer CLOSE
  9543 E434 C0 FE			.word	PSP-1	;perform printer SPECIAL
  9544 E436 CA FE			.word	PPB-1	;perform printer PUT-BYTE
  9545 E438 A2 FE			.word	PST-1	;perform printer STATUS
  9546 E43A C0 FE			.word	PSP-1	;perform printer SPECIAL
  9547 E43C 4C 99 FE			JMP	PIN	;initialize printer
  9548 E43F 00				.byte	0	;reserved
  9549 					;SPACE	4,10
  9550 E440				ORG	CASETV
  9551 					;SPACE	4,10
  9552 				;	CASETV - Cassette Handler Vector Table
  9553
  9554
  9555 E440 E5 FC			.word	COP-1	;perform cassette OPEN
  9556 E442 CE FD			.word	CCL-1	;perform cassette CLOSE
  9557 E444 79 FD			.word	CGB-1	;perform cassette GET-BYTE
  9558 E446 B3 FD			.word	CPB-1	;perform cassette PUT-BYTE
  9559 E448 CB FD			.word	CST-1	;perform cassette STATUS
  9560 E44A E4 FC			.word	CSP-1	;perform cassette SPECIAL
  9561 E44C 4C DB FC			JMP	CIN	;initialize cassette
  9562 E44F 00				.byte	0	;reserved
  9563 					;SUBTTL	'Jump Vectors'
  9564 					;SPACE	4,10
  9565 				;	Jump Vectors
  9566
  9567
  9568 E450				ORG	DINITV
  9569 E450 4C A3 C6			JMP	IDIO	;initialize DIO
  9570
  9571 E453				ORG	DSKINV
  9572 E453 4C B3 C6			JMP	DIO	;perform DIO
  9573
  9574 E456				ORG	CIOV
  9575 E456 4C DF E4			JMP	CIO	;perform CIO
  9576
  9577 E459				ORG	SIOV
  9578 E459 4C 33 C9			JMP	PIO	;perform PIO
  9579
  9580 E45C				ORG	SETVBV
  9581 E45C 4C 72 C2			JMP	SVP	;set VBLANK parameters
  9582
  9583 E45F				ORG	SYSVBV
  9584 E45F 4C E2 C0			JMP	IVNM	;process immediate VBLANK NMI
  9585
  9586 E462				ORG	XITVBV
  9587 E462 4C 8A C2			JMP	DVNM	;process deferred VBLANK NMI
  9588
  9589 E465				ORG	SIOINV
  9590 E465 4C 5C E9			JMP	ISIO	;initialize SIO
  9591
  9592 E468				ORG	SENDEV
  9593 E468 4C 17 EC			JMP	ESS	;enable SIO SEND
  9594
  9595 E46B				ORG	INTINV
  9596 E46B 4C 0C C0			JMP	IIH	;initialize interrupt handler
  9597
  9598 E46E				ORG	CIOINV
  9599 E46E 4C C1 E4			JMP	ICIO	;initialize CIO
  9600
  9601 E471				ORG	BLKBDV
  9602 E471 4C 23 F2			JMP	PPD	;perform power-up display
  9603
  9604 E474				ORG	WARMSV
  9605 E474 4C 90 C2			JMP	PWS	;perform warmstart
  9606
  9607 E477				ORG	COLDSV
  9608 E477 4C C8 C2			JMP	PCS	;perform coldstart
  9609
  9610 E47A				ORG	RBLOKV
  9611 E47A 4C 8D FD		        JMP     RCB	;read cassette block
  9612
  9613 E47D				ORG	CSOPIV
  9614 E47D 4C F7 FC		        JMP     OCI	;open cassette for input
  9615
  9616 E480				ORG	PUPDIV
  9617 E480 4C 23 F2			JMP	PPD	;perform power-up display
  9618
  9619 E483				ORG	SLFTSV
  9620 E483 4C 00 50			JMP	STH	;self-test hardware
  9621
  9622 E486				ORG	PHENTV
  9623 E486 4C BC EE			JMP	PHE	;perform peripheral handler entry
  9624
  9625 E489				ORG	PHUNLV
  9626 E489 4C 15 E9			JMP	PHU	;perform peripheral handler unlinking
  9627
  9628 E48C				ORG	PHINIV
  9629 E48C 4C 98 E8			JMP	PHI	;perform peripheral handler initialization
  9630 					;SUBTTL	'Generic Parallel Device Handler Vector Table'
  9631 					;SPACE	4,10
  9632 E48F				ORG	GPDVV
  9633 					;SPACE	4,10
  9634 				;	GPDVV - Generic Parallel Device Handler Vector Table
  9635
  9636
  9637 E48F 90 C9			.word	GOP-1	;perform generic parallel device OPEN
  9638 E491 95 C9			.word	GCL-1	;perform generic parallel device CLOSE
  9639 E493 9A C9			.word	GGB-1	;perform generic parallel device GET-BYTE
  9640 E495 9F C9			.word	GPB-1	;perform generic parallel device PUT-BYTE
  9641 E497 A4 C9			.word	GST-1	;perform generic parallel device STATUS
  9642 E499 A9 C9			.word	GSP-1	;perform generic parallel device SPECIAL
  9643 E49B 4C 0C C9			JMP	GIN	;initialize generic parallel device
  9644 				;	;SUBTTL	'$E4C0 Patch'
  9645 					;SPACE	4,10
  9646 E49E				ORG	$E4C0
  9647 					;SPACE	4,10
  9648 				;	E4C0 - $E4C0 Patch
  9649 				*
  9650 				*	For compatibility with OS Revision B, return.
  9651
  9652
  9653 E4C0 60				RTS		;return
  9654 				;	;SUBTTL	'Central Input/Output'
  9655 					;SPACE	4,10
  9656 				;	ICIO - Initialize CIO
  9657 				*
  9658 				*	ENTRY	JSR	ICIO
  9659 				*
  9660 				*	MODS
  9661 				*		Original Author Unknown
  9662 				*		1. Bring closer to Coding Standard (object unchanged).
  9663 				*		   R. K. Nordin	11/01/83
  9664
  9665
  9666 = E4C1			ICIO	=	*		;entry
  9667
  9668 				;	Initialize IOCB's.
  9669
  9670 E4C1 A2 00			LDX	#0		;index of first IOCB
  9671
  9672 E4C3 A9 FF		ICIO1	LDA	#IOCFRE		;IOCB free indicator
  9673 E4C5 9D 40 03			STA	ICHID,X		;set IOCB free
  9674 E4C8 A9 DB			LDA	#<[IIN-1]
  9675 E4CA 9D 46 03			STA	ICPTL,X		;initialize PUT-BYTE routine address
  9676 E4CD A9 E4			LDA	#>[IIN-1]
  9677 E4CF 9D 47 03			STA	ICPTH,X
  9678 E4D2 8A				TXA			;index of current IOCB
  9679 E4D3 18				CLC
  9680 E4D4 69 10			ADC	#IOCBSZ		;add IOCB size
  9681 E4D6 AA				TAX			;index of next IOCB
  9682 E4D7 C9 80			CMP	#MAXIOC		;index of first invalid IOCB
  9683 E4D9 90 E8			BCC	ICIO1		;if not done
  9684
  9685 E4DB 60				RTS			;return
  9686 					;SPACE	4,10
  9687 				;	IIN - Indicate IOCB Not Open Error
  9688 				*
  9689 				*	ENTRY	JSR	IIN
  9690 				*
  9691 				*	EXIT
  9692 				*		Y = IOCB Not Open error code
  9693 				*
  9694 				*	MODS
  9695 				*		Original Author Unknown
  9696 				*		1. Bring closer to Coding Standard (object unchanged).
  9697 				*		   R. K. Nordin	11/01/83
  9698
  9699
  9700 = E4DC			IIN	=	*	;entry
  9701 E4DC A0 85			LDY	#NOTOPN	;IOCB not open error
  9702 E4DE 60				RTS		;return
  9703 					;SPACE	4,10
  9704 				;	CIO - Central Input/Output
  9705 				*
  9706 				*	ENTRY	JSR	CIO
  9707 				*
  9708 				*	MODS
  9709 				*		Original Author Unknown
  9710 				*		1. Bring closer to Coding Standard (object unchanged).
  9711 				*		   R. K. Nordin	11/01/83
  9712
  9713
  9714 = E4DF			CIO	=	*	;entry
  9715
  9716 				;	Initialize.
  9717
  9718 E4DF 85 2F			STA	CIOCHR	;save possible output byte value
  9719 E4E1 86 2E			STX	ICIDNO	;save IOCB index
  9720
  9721 				;	Check IOCB index validity.
  9722
  9723 E4E3 8A				TXA		;IOCB index
  9724 E4E4 29 0F			AND	#$0F	;index modulo 16
  9725 E4E6 D0 04			BNE	CIO1	;if IOCB not multiple of 16, error
  9726
  9727 E4E8 E0 80			CPX	#MAXIOC	;index of first invalid IOCB
  9728 E4EA 90 05			BCC	CIO2	;if index within range
  9729
  9730 				;	Indicate Invalid IOCB Index error.
  9731
  9732 E4EC A0 86		CIO1	LDY	#BADIOC	;invalid IOCB index error
  9733 E4EE 4C 70 E6			JMP	SSC	;set status and complete operation, return
  9734
  9735 				;	Move part of IOCB to zero page IOCB.
  9736
  9737 E4F1 A0 00		CIO2	LDY	#0		;offset to first byte of page zero IOCB
  9738
  9739 E4F3 BD 40 03		CIO3	LDA	IOCB,X		;byte of IOCB
  9740 E4F6 99 20 00			STA	IOCBAS,Y	;byte of zero page IOCB
  9741 E4F9 E8				INX
  9742 E4FA C8				INY
  9743 E4FB C0 0C			CPY	#ICSPRZ-IOCBAS	;offset to first undesired byte
  9744 E4FD 90 F4			BCC	CIO3		;if not done
  9745
  9746 				;	Check for provisionally open IOCB.
  9747
  9748 E4FF A5 20			LDA	ICHIDZ	;handler ID
  9749 E501 C9 7F			CMP	#$7F	;provisionally open indicator
  9750 E503 D0 15			BNE	PCC	;if not provisionally open, perform:
  9751
  9752 				;	Check for CLOSE command.
  9753
  9754 E505 A5 22			LDA	ICCOMZ	;command
  9755 E507 C9 0C			CMP	#CLOSE
  9756 E509 F0 71			BEQ	XCL	;if CLOSE command
  9757
  9758 				;	Check handler load flag.
  9759
  9760 E50B AD E9 02			LDA	HNDLOD
  9761 E50E D0 05			BNE	LHO	;if handler load desired
  9762
  9763 				;	Indicate nonexistent device error.
  9764
  9765 				;	JMP	IND	;indicate nonexistent device error,:
  9766 					;SPACE	4,10
  9767 				;	IND - Indicate Nonexistent Device Error
  9768 				*
  9769 				*	ENTRY	JSR	IND
  9770 				*
  9771 				*	MODS
  9772 				*		Original Author Unknown
  9773 				*		1. Bring closer to Coding Standard (object unchanged).
  9774 				*		   R. K. Nordin	11/01/83
  9775
  9776
  9777 = E510			IND	=	*	;entry
  9778 E510 A0 82			LDY	#NONDEV	;nonexistent device error
  9779
  9780 E512 4C 70 E6		IND1	JMP	SSC	;set status and complete operation,:
  9781 					;SPACE	4,10
  9782 				;	LHO - Load Peripheral Handler for OPEN
  9783 				*
  9784 				*	ENTRY	JSR	LHO
  9785 				*
  9786 				*	MODS
  9787 				*		Original Author Unknown
  9788 				*		1. Bring closer to Coding Standard (object unchanged).
  9789 				*		   R. K. Nordin	11/01/83
  9790
  9791
  9792 = E515			LHO	=	*	;entry
  9793 E515 20 29 CA			JSR	PHL	;load and initialize peripheral han:
  9794 E518 30 F8			BMI	IND1	;if error
  9795
  9796 				;	JMP	PCC	;perform CIO command, return
  9797 					;SPACE	4,10
  9798 				;	PCC - Perform CIO Command
  9799 				*
  9800 				*	ENTRY	JSR	PCC
  9801 				*
  9802 				*	MODS
  9803 				*		Original Author Unknown
  9804 				*		1. Bring closer to Coding Standard (object unchanged).
  9805 				*		   R. K. Nordin	11/01/83
  9806
  9807
  9808 = E51A			PCC	=	*	;entry
  9809
  9810 				;	Check command validity.
  9811
  9812 E51A A0 84			LDY	#NVALID		;assume invalid code
  9813 E51C A5 22			LDA	ICCOMZ		;command
  9814 E51E C9 03			CMP	#OPEN		;first valid command
  9815 E520 90 25			BCC	XOP1		;if command invalid
  9816
  9817 E522 A8				TAY			;command
  9818
  9819 E523 C0 0E			CPY	#SPECIL		;last valid command
  9820 E525 90 02			BCC	PCC1		;if valid
  9821
  9822 E527 A0 0E			LDY	#SPECIL		;substitute SPECIAL command
  9823
  9824 				;	Obtain vector offset.
  9825
  9826 E529 84 17		PCC1	STY	ICCOMT		;save command
  9827 E52B B9 2A E7			LDA	TCVO-3,Y	;vector offset for command
  9828 E52E F0 0F			BEQ	XOP		;if OPEN command, process
  9829
  9830 				;	Perform command.
  9831
  9832 E530 C9 02			CMP	#2
  9833 E532 F0 48			BEQ	XCL		;if CLOSE command, process
  9834
  9835 E534 C9 08			CMP	#8
  9836 E536 B0 5F			BCS	XSS		;if STATUS or SPECIAL command, process
  9837
  9838 E538 C9 04			CMP	#4
  9839 E53A F0 76			BEQ	XGT		;if GET command, process
  9840
  9841 E53C 4C 1E E6			JMP	XPT		;process PUT command, process
  9842 					;SPACE	4,10
  9843 				;	XOP - Execute OPEN Command
  9844 				*
  9845 				*	ENTRY	JSR	XOP
  9846 				*
  9847 				*	MODS
  9848 				*		Original Author Unknown
  9849 				*		1. Bring closer to Coding Standard (object unchanged).
  9850 				*		   R. K. Nordin	11/01/83
  9851
  9852
  9853 = E53F			XOP	=	*	;entry
  9854
  9855 				;	Check IOCB free.
  9856
  9857 E53F A5 20			LDA	ICHIDZ	;handler ID
  9858 E541 C9 FF			CMP	#IOCFRE	;IOCB free indicator
  9859 E543 F0 05			BEQ	XOP2	;if IOCB free
  9860
  9861 				;	Process error.
  9862
  9863 E545 A0 81			LDY	#PRVOPN	;IOCB previously open error
  9864
  9865 E547 4C 70 E6		XOP1	JMP	SSC	;set status and complete operation, return
  9866
  9867 				;	Check handler load.
  9868
  9869 E54A AD E9 02		XOP2	LDA	HNDLOD
  9870 E54D D0 27			BNE	PPO	;if user wants unconditional poll
  9871
  9872 				;	Search handler table.
  9873
  9874 E54F 20 FF E6			JSR	SHT	;search handler table
  9875 E552 B0 22			BCS	PPO	;if not found, poll
  9876
  9877 				;	Initialize status.
  9878
  9879 E554 A9 00			LDA	#0
  9880 E556 8D EA 02			STA	DVSTAT	;clear status
  9881 E559 8D EB 02			STA	DVSTAT+1
  9882
  9883 				;	Initialize IOCB.
  9884
  9885 				;	JMP	IIO	;initialize IOCB for OPEN, return
  9886 					;SPACE	4,10
  9887 				;	IIO - Initialize IOCB for OPEN
  9888 				*
  9889 				*	ENTRY	JSR	IIO
  9890 				*
  9891 				*	MODS
  9892 				*		Original Author Unknown
  9893 				*		1. Bring closer to Coding Standard (object unchanged).
  9894 				*		   R. K. Nordin	11/01/83
  9895
  9896
  9897 = E55C			IIO	=	*	;entry
  9898
  9899 				;	Compute handler entry point.
  9900
  9901 E55C 20 95 E6			JSR	CEP	;compute handler entry point
  9902 E55F B0 E6			BCS	XOP1	;if error
  9903
  9904 				;	Execute command.
  9905
  9906 E561 20 EA E6			JSR	EHC	;execute handler command
  9907
  9908 				;	Set PUT-BYTE routine address in IOCB.
  9909
  9910 E564 A9 0B			LDA	#PUTCHR
  9911 E566 85 17			STA	ICCOMT	;command
  9912 E568 20 95 E6			JSR	CEP	;compute handler entry point
  9913 E56B A5 2C			LDA	ICSPRZ	;PUT-BYTE routine address
  9914 E56D 85 26			STA	ICPTLZ	;IOCB PUT-BYTE routine address
  9915 E56F A5 2D			LDA	ICSPRZ+1
  9916 E571 85 27			STA	ICPTHZ
  9917 E573 4C 72 E6			JMP	CCO	;complete CIO operation, return
  9918 					;SPACE	4,10
  9919 				;	PPO - Peripheral for OPEN
  9920 				*
  9921 				*	ENTRY	JSR	PPO
  9922 				*
  9923 				*	MODS
  9924 				*		Original Author Unknown
  9925 				*		1. Bring closer to Coding Standard (object unchanged).
  9926 				*		   R. K. Nordin	11/01/83
  9927
  9928
  9929 = E576			PPO	=	*	;entry
  9930 E576 20 F9 EE			JSR	PHO	;poll
  9931 E579 4C 70 E6			JMP	SSC	;set status and complete operation,:
  9932 					;SPACE	4,10
  9933 				;	XCL - Execute CLOSE Command
  9934 				*
  9935 				*	ENTRY	JSR	XCL
  9936 				*
  9937 				*	MODS
  9938 				*		Original Author Unknown
  9939 				*		1. Bring closer to Coding Standard (object unchanged).
  9940 				*		   R. K. Nordin	11/01/83
  9941
  9942
  9943 = E57C			XCL	=	*		;entry
  9944
  9945 				;	Initialize.
  9946
  9947 E57C A0 01			LDY	#SUCCES		;assume success
  9948 E57E 84 23			STY	ICSTAZ		;status
  9949 E580 20 95 E6			JSR	CEP		;compute handler entry point
  9950 E583 B0 03			BCS	XCL1		;if error
  9951
  9952 				;	Execute command.
  9953
  9954 E585 20 EA E6			JSR	EHC		;execute handler command
  9955
  9956 				;	Close IOCB.
  9957
  9958 E588 A9 FF		XCL1	LDA	#IOCFRE		;IOCB free indicator
  9959 E58A 85 20			STA	ICHIDZ		;indicate IOCB free
  9960 E58C A9 E4			LDA	#>[IIN-1]
  9961 E58E 85 27			STA	ICPTHZ		;reset initial PUT-BYTE routine address
  9962 E590 A9 DB			LDA	#<[IIN-1]
  9963 E592 85 26			STA	ICPTLZ
  9964 E594 4C 72 E6			JMP	CCO		;complete CIO operation, return
  9965 					;SPACE	4,10
  9966 				;	XSS - Execute STATUS and SPECIAL Commands
  9967 				*
  9968 				*	???word about implicit OPEN and CLOSE.
  9969 				*
  9970 				*	ENTRY	JSR	XSS
  9971 				*
  9972 				*	MODS
  9973 				*		Original Author Unknown
  9974 				*		1. Bring closer to Coding Standard (object unchanged).
  9975 				*		   R. K. Nordin	11/01/83
  9976
  9977
  9978 = E597			XSS	=	*	;entry
  9979
  9980 				;	Check IOCB free.
  9981
  9982 E597 A5 20			LDA	ICHIDZ	;handler ID
  9983 E599 C9 FF			CMP	#IOCFRE
  9984 E59B D0 05			BNE	XSS1	;if IOCB not free
  9985
  9986 				;	Open IOCB.
  9987
  9988 E59D 20 FF E6			JSR	SHT	;search handler table
  9989 E5A0 B0 A5			BCS	XOP1	;if error
  9990
  9991 				;	Execute command.
  9992
  9993 E5A2 20 95 E6		XSS1	JSR	CEP	;compute handler entry point
  9994 E5A5 20 EA E6			JSR	EHC	;execute handler command
  9995
  9996 				;	Restore handler ID, in case IOCB implicitly opened.
  9997
  9998 E5A8 A6 2E			LDX	ICIDNO	;IOCB index
  9999 E5AA BD 40 03			LDA	ICHID,X	;original handler ID
 10000 E5AD 85 20			STA	ICHIDZ	;restore zero page handler ID
 10001 E5AF 4C 72 E6			JMP	CCO	;complete CIO operation, return
 10002 					;SPACE	4,10
 10003 				;	XGT - Execute GET Command
 10004 				*
 10005 				*	ENTRY	JSR	XGT
 10006 				*
 10007 				*	MODS
 10008 				*		Original Author Unknown
 10009 				*		1. Bring closer to Coding Standard (object unchanged).
 10010 				*		   R. K. Nordin	11/01/83
 10011
 10012
 10013 = E5B2			XGT	=	*	;entry
 10014
 10015 				;	Check GET validity.
 10016
 10017 E5B2 A5 22			LDA	ICCOMZ	;command
 10018 E5B4 25 2A			AND	ICAX1Z	;???
 10019 E5B6 D0 05			BNE	XGT2	;if GET command valid
 10020
 10021 				;	Process error.
 10022
 10023 E5B8 A0 83			LDY	#WRONLY	;IOCB opened for write only error
 10024
 10025 E5BA 4C 70 E6		XGT1	JMP	SSC	;set status and complete operation, return
 10026
 10027 				;	Compute and check handler entry point.
 10028
 10029 E5BD 20 95 E6		XGT2	JSR	CEP	;compute handler entry point
 10030 E5C0 B0 F8			BCS	XGT1	;if error
 10031
 10032 				;	Check buffer length.
 10033
 10034 E5C2 A5 28			LDA	ICBLLZ		;buffer length
 10035 E5C4 05 29			ORA	ICBLLZ+1
 10036 E5C6 D0 08			BNE	XGT3		;if buffer length non-zero
 10037
 10038 				;	Get byte.
 10039
 10040 E5C8 20 EA E6			JSR	EHC	;execute handler command
 10041 E5CB 85 2F			STA	CIOCHR	;data
 10042 E5CD 4C 72 E6			JMP	CCO	;complete CIO operation, return
 10043
 10044 				;	Fill buffer.    	
 10045
 10046 E5D0 20 EA E6		XGT3	JSR	EHC		;execute handler command
 10047 E5D3 85 2F			STA	CIOCHR		;data
 10048 E5D5 30 41			BMI	XGT7		;if error, end transfer
 10049
 10050 E5D7 A0 00			LDY	#0
 10051 E5D9 91 24			STA	(ICBALZ),Y	;byte of buffer
 10052 E5DB 20 D1 E6			JSR	IBP		;increment buffer pointer
 10053 E5DE A5 22			LDA	ICCOMZ		;command
 10054 E5E0 29 02			AND	#$02
 10055 E5E2 D0 0C			BNE	XGT4		;if GET RECORD command
 10056
 10057 				;	Check for EOL.
 10058
 10059 E5E4 A5 2F			LDA	CIOCHR	;data
 10060 E5E6 C9 9B			CMP	#EOL
 10061 E5E8 D0 06			BNE	XGT4	;if not EOL
 10062
 10063 				;	Process EOL.
 10064
 10065 E5EA 20 BB E6			JSR	DBL	;decrement buffer length
 10066 E5ED 4C 18 E6			JMP	XGT7	;clean up
 10067
 10068 				;	Check buffer full.
 10069
 10070 E5F0 20 BB E6		XGT4	JSR	DBL	;decrement buffer length
 10071 E5F3 D0 DB			BNE	XGT3	;if buffer not full, continue
 10072
 10073 				;	Check command.
 10074
 10075 E5F5 A5 22			LDA	ICCOMZ	;command
 10076 E5F7 29 02			AND	#$02
 10077 E5F9 D0 1D			BNE	XGT7	;if GET CHARACTER command, clean up
 10078
 10079 				;	Process GET RECORD.
 10080
 10081 E5FB 20 EA E6		XGT5	JSR	EHC	;execute handler command
 10082 E5FE 85 2F			STA	CIOCHR	;data
 10083 E600 30 0A			BMI	XGT6	;if error
 10084
 10085 				;	Check for EOL.
 10086
 10087 E602 A5 2F			LDA	CIOCHR	;data
 10088 E604 C9 9B			CMP	#EOL
 10089 E606 D0 F3			BNE	XGT5	;if not EOL, continue
 10090
 10091 				;	Process end of record.
 10092
 10093 E608 A9 89			LDA	#TRNRCD	;truncated record error
 10094 E60A 85 23			STA	ICSTAZ	;status
 10095
 10096 				;	Process error.
 10097
 10098 E60C 20 C8 E6		XGT6	JSR	DBP		;decrement buffer pointer
 10099 E60F A0 00			LDY	#0
 10100 E611 A9 9B			LDA	#EOL
 10101 E613 91 24			STA	(ICBALZ),Y	;set EOL in buffer
 10102 E615 20 D1 E6			JSR	IBP		;increment buffer pointer
 10103
 10104 				;	Clean up.
 10105
 10106 E618 20 D8 E6		XGT7	JSR	SFL	;set final buffer length
 10107 E61B 4C 72 E6			JMP	CCO	;complete CIO operation, return
 10108 					;SPACE	4,10
 10109 				;	XPT - Execute PUT Command
 10110 				*
 10111 				*	ENTRY	JSR	XPT
 10112 				*
 10113 				*	MODS
 10114 				*		Original Author Unknown
 10115 				*		1. Bring closer to Coding Standard (object unchanged).
 10116 				*		   R. K. Nordin	11/01/83
 10117
 10118
 10119 = E61E			XPT	=	*	;entry
 10120
 10121 				;	Check PUT validity.
 10122
 10123 E61E A5 22			LDA	ICCOMZ	;command
 10124 E620 25 2A			AND	ICAX1Z
 10125 E622 D0 05			BNE	XPT2	;if PUT command valid
 10126
 10127 				;	Process error.
 10128
 10129 E624 A0 87			LDY	#RDONLY	;IOCB opened for read only error
 10130
 10131 E626 4C 70 E6		XPT1	JMP	SSC	;set status and complete operation, return
 10132
 10133 				;	Compute and check handler entry point.
 10134
 10135 E629 20 95 E6		XPT2	JSR	CEP	;compute handler entry point
 10136 E62C B0 F8			BCS	XPT1	;if error
 10137
 10138 				;	Check buffer length.
 10139
 10140 E62E A5 28			LDA	ICBLLZ	;buffer length
 10141 E630 05 29			ORA	ICBLLZ+1
 10142 E632 D0 06			BNE	XPT3	;if buffer length non-zero
 10143
 10144 				;	Put byte.
 10145
 10146 E634 A5 2F			LDA	CIOCHR	;data
 10147 E636 E6 28			INC	ICBLLZ	;set buffer length to 1
 10148 E638 D0 06			BNE	XPT4	;transfer one byte
 10149
 10150 				;	Transfer data from buffer to handler.
 10151
 10152 E63A A0 00		XPT3	LDY	#0
 10153 E63C B1 24			LDA	(ICBALZ),Y	;byte from buffer
 10154 E63E 85 2F			STA	CIOCHR		;data
 10155
 10156 E640 20 EA E6		XPT4	JSR	EHC		;execute handler command
 10157 E643 08				PHP			;save status
 10158 E644 20 D1 E6			JSR	IBP		;increment buffer pointer
 10159 E647 20 BB E6			JSR	DBL		;decrement buffer length
 10160 E64A 28				PLP			;status
 10161 E64B 30 1D			BMI	XPT6		;if error
 10162
 10163 				;	Check command.
 10164
 10165 E64D A5 22			LDA	ICCOMZ	;command
 10166 E64F 29 02			AND	#$02
 10167 E651 D0 06			BNE	XPT5	;if PUT RECORD command
 10168
 10169 				;	Check for EOL.
 10170
 10171 E653 A5 2F			LDA	CIOCHR	;data
 10172 E655 C9 9B			CMP	#EOL
 10173 E657 F0 11			BEQ	XPT6	;if EOL, clean up
 10174
 10175 				;	Check for buffer empty.
 10176
 10177 E659 A5 28		XPT5	LDA	ICBLLZ		;buffer length
 10178 E65B 05 29			ORA	ICBLLZ+1
 10179 E65D D0 DB			BNE	XPT3		;if buffer not empty, continue
 10180
 10181 				;	Check command.
 10182
 10183 E65F A5 22			LDA	ICCOMZ	;command
 10184 E661 29 02			AND	#$02
 10185 E663 D0 05			BNE	XPT6	;if PUT CHARACTER command
 10186
 10187 				;	Write EOL.
 10188
 10189 E665 A9 9B			LDA	#EOL
 10190 E667 20 EA E6			JSR	EHC	;execute handler command
 10191
 10192 				;	Clean up.
 10193
 10194 E66A 20 D8 E6		XPT6	JSR	SFL	;set final buffer length
 10195 E66D 4C 72 E6			JMP	CCO	;complete CIO operation, return
 10196 				;	;SPACE	4,10
 10197 				;	SSC - Set Status and Complete Operation
 10198 				*
 10199 				*	ENTRY	JSR	SSC
 10200 				*
 10201 				*	MODS
 10202 				*		Original Author Unknown
 10203 				*		1. Bring closer to Coding Standard (object unchanged).
 10204 				*		   R. K. Nordin	11/01/83
 10205
 10206
 10207 = E670			SSC	=	*	;entry
 10208 E670 84 23			STY	ICSTAZ	;status
 10209 				;	JMP	CCO	;complete CIO operation, return
 10210 					;SPACE	4,10
 10211 				;	CCO - Complete CIO Operation
 10212 				*
 10213 				*	ENTRY	JSR	CCO
 10214 				*
 10215 				*	MODS
 10216 				*		Original Author Unknown
 10217 				*		1. Bring closer to Coding Standard (object unchanged).
 10218 				*		   R. K. Nordin	11/01/83
 10219
 10220
 10221 = E672			CCO	=	*		;entry
 10222
 10223 				;	Initialize.
 10224
 10225 E672 A4 2E			LDY	ICIDNO		;IOCB index
 10226
 10227 				;	Restore buffer pointer.
 10228
 10229 E674 B9 44 03			LDA	ICBAL,Y
 10230 E677 85 24			STA	ICBALZ		;restore buffer pointer
 10231 E679 B9 45 03			LDA	ICBAH,Y
 10232 E67C 85 25			STA	ICBAHZ
 10233
 10234 				;	Move part of zero page IOCB to IOCB.
 10235
 10236 E67E A2 00			LDX	#0		;first byte of zero page IOCB
 10237 E680 8E E9 02			STX	HNDLOD
 10238
 10239 E683 B5 20		CCO1	LDA	IOCBAS,X	;byte of zero page IOCB
 10240 E685 99 40 03			STA	IOCB,Y		;byte of IOCB
 10241 E688 E8				INX
 10242 E689 C8				INY
 10243 E68A E0 0C			CPX	#ICSPRZ-IOCBAS	;offset to first undesired byte
 10244 E68C 90 F5			BCC	CCO1		;if not done
 10245
 10246 				;	Restore A, X and Y.
 10247
 10248 E68E A5 2F			LDA	CIOCHR		;data
 10249 E690 A6 2E			LDX	ICIDNO		;IOCB index
 10250 E692 A4 23			LDY	ICSTAZ		;status
 10251 E694 60				RTS			;return
 10252 					;SPACE	4,10
 10253 				;	CEP - Compute Handler Entry Point
 10254 				*
 10255 				*	ENTRY	JSR	CEP
 10256 				*
 10257 				*	MODS
 10258 				*		Original Author Unknown
 10259 				*		1. Bring closer to Coding Standard (object unchanged).
 10260 				*		   R. K. Nordin	11/01/83
 10261
 10262
 10263 = E695			CEP	=	*		;entry
 10264
 10265 				;	Check handler ID validity.
 10266
 10267 E695 A4 20			LDY	ICHIDZ		;handler ID
 10268 E697 C0 22			CPY	#MAXDEV+1	;first invalid ID
 10269 E699 90 04			BCC	CEP1		;if handler ID within range
 10270
 10271 				;	Process error.
 10272
 10273 E69B A0 85			LDY	#NOTOPN		;IOCB not open error
 10274 E69D B0 1B			BCS	CEP2		;return
 10275
 10276 				;	Compute entry point.
 10277
 10278 E69F B9 1B 03		CEP1	LDA	HATABS+1,Y	;low address
 10279 E6A2 85 2C			STA	ICSPRZ
 10280 E6A4 B9 1C 03			LDA	HATABS+2,Y	;high address
 10281 E6A7 85 2D			STA	ICSPRZ+1
 10282 E6A9 A4 17			LDY	ICCOMT		;command
 10283 E6AB B9 2A E7			LDA	TCVO-3,Y	;vector offset for command
 10284 E6AE A8				TAY
 10285 E6AF B1 2C			LDA	(ICSPRZ),Y	;low vector address
 10286 E6B1 AA				TAX			;low vector address
 10287 E6B2 C8				INY
 10288 E6B3 B1 2C			LDA	(ICSPRZ),Y	;high vector address
 10289 E6B5 85 2D			STA	ICSPRZ+1	;set high address
 10290 E6B7 86 2C			STX	ICSPRZ		;set low address
 10291 E6B9 18				CLC			;indicate success
 10292
 10293 				;	Exit.
 10294
 10295 E6BA 60			CEP2	RTS			;return
 10296 					;SPACE	4,10
 10297 				;	DBL - Decrement Buffer Length
 10298 				*
 10299 				*	ENTRY	JSR	DBL
 10300 				*
 10301 				*	EXIT
 10302 				*		Z set if buffer length = 0
 10303 				*
 10304 				*	MODS
 10305 				*		Original Author Unknown
 10306 				*		1. Bring closer to Coding Standard (object unchanged).
 10307 				*		   R. K. Nordin	11/01/83
 10308
 10309
 10310 = E6BB			DBL	=	*		;entry
 10311 E6BB A5 28			LDA	ICBLLZ		;low buffer length
 10312 E6BD D0 02			BNE	DBL1		;if low buffer length non-zero
 10313
 10314 E6BF C6 29			DEC	ICBLLZ+1	;decrement high buffer length
 10315
 10316 E6C1 C6 28		DBL1	DEC	ICBLLZ		;decrement low buffer length
 10317 E6C3 A5 28			LDA	ICBLLZ
 10318 E6C5 05 29			ORA	ICBLLZ+1	;indicate buffer length status
 10319 E6C7 60				RTS			;return
 10320 					;SPACE	4,10
 10321 				;	DBP - Decrement Buffer Pointer
 10322 				*
 10323 				*	ENTRY	JSR	DBP
 10324 				*
 10325 				*	MODS
 10326 				*		Original Author Unknown
 10327 				*		1. Bring closer to Coding Standard (object unchanged).
 10328 				*		   R. K. Nordin	11/01/83
 10329
 10330
 10331 = E6C8			DBP	=	*		;entry
 10332 E6C8 A5 24			LDA	ICBALZ		;low buffer address
 10333 E6CA D0 02			BNE	DBP1		;if low buffer address non-zero
 10334
 10335 E6CC C6 25			DEC	ICBALZ+1	;decrement high buffer address
 10336
 10337 E6CE C6 24		DBP1	DEC	ICBALZ		;decrement low buffer address
 10338 E6D0 60				RTS			;return
 10339 					;SPACE	4,10
 10340 				;	IBP - Increment Buffer Pointer
 10341 				*
 10342 				*	ENTRY	JSR	IBP
 10343 				*
 10344 				*	MODS
 10345 				*		Original Author Unknown
 10346 				*		1. Bring closer to Coding Standard (object unchanged).
 10347 				*		   R. K. Nordin	11/01/83
 10348
 10349
 10350 = E6D1			IBP	=	*		;entry
 10351 E6D1 E6 24			INC	ICBALZ		;increment low buffer address
 10352 E6D3 D0 02			BNE	IBP1		;if low buffer address non-zero
 10353
 10354 E6D5 E6 25			INC	ICBALZ+1	;increment high buffer address
 10355
 10356 E6D7 60			IBP1	RTS			;return
 10357 					;SPACE	4,10
 10358 				;	SFL - Set Final Buffer Length
 10359 				*
 10360 				*	ENTRY	JSR	SFL
 10361 				*
 10362 				*	MODS
 10363 				*		Original Author Unknown
 10364 				*		1. Bring closer to Coding Standard (object unchanged).
 10365 				*		   R. K. Nordin	11/01/83
 10366
 10367
 10368 = E6D8			SFL	=	*		;entry
 10369 E6D8 A6 2E			LDX	ICIDNO		;IOCB index
 10370 E6DA 38				SEC
 10371 E6DB BD 48 03			LDA	ICBLL,X		;initial length
 10372 E6DE E5 28			SBC	ICBLLZ		;subtract byte count
 10373 E6E0 85 28			STA	ICBLLZ		;update length
 10374 E6E2 BD 49 03			LDA	ICBLH,X
 10375 E6E5 E5 29			SBC	ICBLLZ+1
 10376 E6E7 85 29			STA	ICBLHZ
 10377 E6E9 60				RTS			;return
 10378 					;SPACE	4,10
 10379 				;	EHC - Execute Handler Command
 10380 				*
 10381 				*	ENTRY	JSR	EHC
 10382 				*
 10383 				*	MODS
 10384 				*		Original Author Unknown
 10385 				*		1. Bring closer to Coding Standard (object unchanged).
 10386 				*		   R. K. Nordin	11/01/83
 10387
 10388
 10389 = E6EA			EHC	=	*		;entry
 10390 E6EA A0 92			LDY	#FNCNOT		;assume function not defined error
 10391 E6EC 20 F4 E6			JSR	IDH		;invoke device handler
 10392 E6EF 84 23			STY	ICSTAZ		;status
 10393 E6F1 C0 00			CPY	#0		;set N accordingly
 10394 E6F3 60				RTS			;return
 10395 					;SPACE	4,10
 10396 				;	IDH - Invoke Device Handler
 10397 				*
 10398 				*	ENTRY	JSR	IDH
 10399 				*
 10400 				*	MODS
 10401 				*		Original Author Unknown
 10402 				*		1. Bring closer to Coding Standard (object unchanged).
 10403 				*		   R. K. Nordin	11/01/83
 10404
 10405
 10406 = E6F4			IDH	=	*		;entry
 10407 E6F4 AA				TAX			;save A
 10408 E6F5 A5 2D			LDA	ICSPRZ+1	;high vector
 10409 E6F7 48				PHA			;put high vector on stack
 10410 E6F8 A5 2C			LDA	ICSPRZ		;low vector
 10411 E6FA 48				PHA			;put low vector on stack
 10412 E6FB 8A				TXA			;restore A
 10413 E6FC A6 2E			LDX	ICIDNO		;IOCB index
 10414 E6FE 60				RTS			;invoke handler (address on stack)
 10415 					;SPACE	4,10
 10416 				;	SHT - Search Handler Table
 10417 				*
 10418 				*	ENTRY	JSR	SHT
 10419 				*
 10420 				*	MODS
 10421 				*		Original Author Unknown
 10422 				*		1. Bring closer to Coding Standard (object unchanged).
 10423 				*		   R. K. Nordin	11/01/83
 10424
 10425
 10426 = E6FF			SHT	=	*	;entry
 10427
 10428 				;	Set device number.
 10429
 10430 E6FF 38				SEC
 10431 E700 A0 01			LDY	#1
 10432 E702 B1 24			LDA	(ICBALZ),Y	;device number
 10433 E704 E9 31			SBC	#'1'
 10434 E706 30 04			BMI	SHT1		;if number less than  "1"
 10435
 10436 E708 C9 09			CMP	#'9'-'1'+1
 10437 E70A 90 02			BCC	SHT2		;if number in range "1" to "9"
 10438
 10439 E70C A9 00		SHT1	LDA	#0		;substitute device number "1"
 10440
 10441 E70E 85 21		SHT2	STA	ICDNOZ		;device number (0 through 8)
 10442 E710 E6 21			INC	ICDNOZ		;adjust number to range 1 t:
 10443
 10444 				;	Find device handler.
 10445
 10446 E712 A0 00			LDY	#0		;offset to device code
 10447 E714 B1 24			LDA	(ICBALZ),Y	;device code
 10448 				;	JMP	FDH		;find device handler, return
 10449 					;SPACE	4,10
 10450 				;	FDH - Find Device Handler
 10451 				*
 10452 				*	ENTRY	JSR	FDH
 10453 				*
 10454 				*	MODS
 10455 				*		Original Author Unknown
 10456 				*		1. Bring closer to Coding Standard (object unchanged).
 10457 				*		   R. K. Nordin	11/01/83
 10458
 10459
 10460 = E716			FDH	=	*		;entry
 10461
 10462 				;	Check device code.
 10463
 10464 E716 F0 0C			BEQ	FDH2		;if device code null
 10465
 10466 				;	Search handler table for device.
 10467
 10468 E718 A0 21			LDY	#MAXDEV		;offset to last possible entry
 10469
 10470 E71A D9 1A 03		FDH1	CMP	HATABS,Y	;device code from table
 10471 E71D F0 09			BEQ	FDH3		;if device found
 10472
 10473 E71F 88				DEY
 10474 E720 88				DEY
 10475 E721 88				DEY
 10476 E722 10 F6			BPL	FDH1		;if not done
 10477
 10478 				;	Process device not found.
 10479
 10480 E724 A0 82		FDH2	LDY	#NONDEV		;nonexistent device error
 10481 E726 38				SEC			;indicate error
 10482 E727 60				RTS			;return
 10483
 10484 				;	Set handler ID.
 10485
 10486 E728 98			FDH3	TYA			;offset to device code in table
 10487 E729 85 20			STA	ICHIDZ		;set handler ID
 10488 E72B 18				CLC			;indicate no error
 10489 E72C 60				RTS			;return
 10490 					;SPACE	4,10
 10491 				;	TCVO - Table of Command Vector Offsets
 10492 				*
 10493 				*	Entry n is the vector offset for command n+3.
 10494
 10495
 10496 E72D 00			TCVO	.byte	0	;3 - open
 10497 E72E 04				.byte	4	;4
 10498 E72F 04				.byte	4	;5 - get record
 10499 E730 04				.byte	4	;6
 10500 E731 04				.byte	4	;7 - get byte(s)
 10501 E732 06				.byte	6	;8
 10502 E733 06				.byte	6	;9 - put record
 10503 E734 06				.byte	6	;10
 10504 E735 06				.byte	6	;11 - put byte(s)
 10505 E736 02				.byte	2	;12 - close
 10506 E737 08				.byte	8	;13 - status
 10507 E738 0A				.byte	10	;14 - special
 10508 				;	;SUBTTL	'Peripheral Handler Loading Facility, Part 3'
 10509 					;SPACE	4,10
 10510 				;	PHR - Perform Peripheral Handler Loading Initializa:
 10511 				*
 10512 				*	* Performs Power-up Polling, with Handler loading a:
 10513 				*	and Initialization;
 10514 				*	* Performs System Reset Re-initialization of all ha:
 10515 				*
 10516 				*	Input Parameters:
 10517 				*	WARMST (used to distinguish Cold and Warm Start).
 10518 				*
 10519 				*	Output Parameters:
 10520 				*	None.
 10521 				*
 10522 				*	Modified:
 10523 				*	Registers are not saved;
 10524 				*	All kinds of side effects when any handler is loade:
 10525 				*	(potentially MEMLO, DVSTAT thru DVSTAT+3, the DCB,
 10526 				*	CHLINK, ZCHAIN, TEMP1, TEMP2, TEMP3.    This list m:
 10527 				*	not be complete.).
 10528 				*
 10529 				*	ENTRY	JSR	PHR
 10530 				*
 10531 				*	MODS
 10532 				*		R. S. Scheiman	04/01/82
 10533 				*		1. Bring closer to Coding Standard (object unchanged).
 10534 				*		   R. K. Nordin	11/01/83
 10535
 10536
 10537 = E739			PHR	=	*	;entry
 10538
 10539 				;	Check for coldstart.
 10540
 10541 E739 A5 08			LDA	WARMST		;warmstart flag
 10542 E73B F0 25			BEQ	PHR2		;if coldstart
 10543
 10544 				;	Process warmstart.
 10545
 10546 E73D A9 E9			LDA	#<[CHLINK-18]
 10547 E73F 85 4A			STA	ZCHAIN
 10548 E741 A9 03			LDA	#>[CHLINK-18]
 10549 E743 85 4B			STA	ZCHAIN+1
 10550
 10551 				;	Check next link.
 10552
 10553 E745 A0 12		PHR1	LDY	#18		;offset to link
 10554 E747 18				CLC
 10555 E748 B1 4A			LDA	(ZCHAIN),y	;low link
 10556 E74A AA				TAX
 10557 E74B C8				INY
 10558 E74C 71 4A			ADC	(ZCHAIN),Y	;high link
 10559 E74E F0 26			BEQ	PHR4		;if forward link null
 10560
 10561 				;	Re-initialize peripheral handler.
 10562
 10563 E750 B1 4A			LDA	(ZCHAIN),Y	;high link
 10564 E752 85 4B			STA	ZCHAIN+1
 10565 E754 86 4A			STX	ZCHAIN
 10566 E756 20 56 CB			JSR	CLT		;checksum linkage table
 10567 E759 D0 1B			BNE	PHR4		;if checksum bad
 10568
 10569 E75B 20 94 E8			JSR	PHW		;re-initialize peripheral h:
 10570 E75E B0 16			BCS	PHR4		;if error
 10571
 10572 				;	Continue with next handler.
 10573
 10574 E760 90 E3			BCC	PHR1		;continue with next handler
 10575
 10576 				;	Process coldstart.
 10577
 10578 E762 A9 00		PHR2	LDA	#0
 10579 E764 8D FB 03			STA	CHLINK		;clear chain link
 10580 E767 8D FC 03			STA	CHLINK+1
 10581 E76A A9 4F			LDA	#$4F		;send POLL RESET poll
 10582 E76C D0 2D			BNE	PHR7
 10583
 10584 				;	Perform type 3 poll.
 10585
 10586 E76E A9 00		PHR3	LDA	#0
 10587 E770 A8				TAY
 10588 E771 20 BE E7			JSR	PHP
 10589 E774 10 01			BPL	PHR5		;if poll answered
 10590
 10591 				;	Exit.
 10592
 10593 E776 60			PHR4	RTS			;return
 10594
 10595 				;	Process answered poll.
 10596
 10597 E777 18			PHR5	CLC
 10598 E778 AD E7 02			LDA	MEMLO
 10599 E77B 6D EA 02			ADC	DVSTAT
 10600 E77E 8D 12 03			STA	TEMP1
 10601 E781 AD E8 02			LDA	MEMLO+1
 10602 E784 6D EB 02			ADC	DVSTAT+1
 10603 E787 8D 13 03			STA	TEMP1+1		;(TEMP2 := MEMLO + handler :
 10604 E78A 38				SEC
 10605 E78B AD E5 02			LDA	MEMTOP
 10606 E78E ED 12 03			SBC	TEMP1
 10607 E791 AD E6 02			LDA	MEMTOP+1
 10608 E794 ED 13 03			SBC	TEMP1+1		;(subtract MEMTOP)
 10609 E797 B0 09			BCS	PHR8		;if room to load
 10610
 10611 				;	Prepare for another poll.
 10612
 10613 E799 A9 4E		PHR6	LDA	#$4E		;following any load or init:
 10614 								;prepare for another Type 3:
 10615 								;sending a "special" load c:
 10616 								;serial port.
 10617
 10618 				;	Poll.
 10619
 10620 E79B A8			PHR7	TAY			;Send either "special" load:
 10621 E79C 20 BE E7			JSR	PHP
 10622 E79F 4C 6E E7			JMP	PHR3		;go poll again
 10623
 10624 				;	Load peripheral handler.
 10625
 10626 E7A2 AD EC 02		PHR8	LDA	DVSTAT+2	;call the loader
 10627 E7A5 AE E7 02			LDX	MEMLO
 10628 E7A8 8E EC 02			STX	DVSTAT+2	;(Parameter = load address)
 10629 E7AB AE E8 02			LDX	MEMLO+1
 10630 E7AE 8E ED 02			STX	DVSTAT+3
 10631 E7B1 20 DE E7			JSR	LPH		;load peripheral handler
 10632 E7B4 30 E3			BMI	PHR6		;if load error, poll again
 10633
 10634 E7B6 38				SEC			;Call for initialize new ha:
 10635 E7B7 20 9E E8			JSR	PHC		;(Parameter = add size to M:
 10636 E7BA B0 DD			BCS	PHR6		;if init error, poll again
 10637
 10638 E7BC 90 B0			BCC	PHR3		;poll again normally
 10639 					;SPACE	4,10
 10640 				;	PHP - Perform Poll
 10641 				*
 10642 				*	Polling subroutine calls SIO for Type 3 or 4 Poll.
 10643 				*
 10644 				*	Input Parameters:
 10645 				*	A	Value for AUX1
 10646 				*	Y	Value for AUX2
 10647 				*
 10648 				*	Output Parameters:
 10649 				*	Y	SIO status from poll
 10650 				*	DVSTAT: Device minimum size (low), if poll answered
 10651 				*	DVSTAT+1: Device minimum size (high), if poll answe:
 10652 				*	DVSTAT+2: Device address for loading, if poll answe:
 10653 				*	DVSTAT+3: Device version number, if poll answered
 10654 				*
 10655 				*	Modified:
 10656 				*	The registers are not saved;
 10657 				*
 10658 				*	Subroutines called:
 10659 				*	SIO (performs poll and returns to PHP's caller).
 10660 				*
 10661 				*	ENTRY	JSR	PHP
 10662 				*
 10663 				*	MODS
 10664 				*		R. S. Scheiman	04/01/82
 10665 				*		1. Bring closer to Coding Standard (object unchanged).
 10666 				*		   R. K. Nordin	11/01/83
 10667
 10668
 10669 = E7BE			PHP	=	*		;entry
 10670
 10671 				;	Initialize.
 10672
 10673 E7BE 48				PHA			;save parameter
 10674
 10675 				;	Set up DCB.
 10676
 10677 E7BF A2 09			LDX	#PHPAL-1	;offset to last byte of DCB:
 10678 E7C1 BD D4 E7		PHP1	LDA	PHPA,X		;byte of DCB data
 10679 E7C4 9D 00 03			STA	DCB,X		;byte of DCB
 10680 E7C7 CA				DEX
 10681 E7C8 10 F7			BPL	PHP1		;if not done
 10682
 10683 				;	Set parameters in DBC auxiliary bytes.
 10684
 10685 E7CA 8C 0B 03			STY	DAUX2
 10686 E7CD 68				PLA
 10687 E7CE 8D 0A 03			STA	DAUX1
 10688
 10689 				;	Perform SIO.
 10690
 10691 E7D1 4C 59 E4			JMP	SIOV		;vector to SIO, return
 10692
 10693
 10694 				;	DCB Poll Request Data
 10695
 10696 E7D4 4F			PHPA	.byte	$4F	;device bus ID
 10697 E7D5 01				.byte	1	;unit number
 10698 E7D6 40				.byte	'@'	;type 3 or 4 poll command
 10699 E7D7 40				.byte	$40	;I/O direction
 10700 E7D8 EA 02			.word	DVSTAT	;buffer
 10701 E7DA 1E				.byte	30	;timeout
 10702 E7DB 00				.byte	0
 10703 E7DC 04 00			.word	4	;buffer length
 10704
 10705 = 000A			PHPAL	=	*-PHPA	;length
 10706 					;SPACE	4,10
 10707 				;	LPH - Load Peripheral Handler
 10708 				*
 10709 				*	This subroutine calls the relocating loader to load
 10710 				*	a handler from a peripheral.
 10711 				*
 10712 				*	Input Parameters:
 10713 				*	A	Peripheral serial address for load;
 10714 				*	DVSTAT+2: Load address (low)
 10715 				*	DVSTAT+3: Load address (high)
 10716 				*
 10717 				*	Output Parameters:
 10718 				*	From the relocating loader.
 10719 				*
 10720 				*	Modified:
 10721 				*	TEMP1, TEMP2, TEMP3,
 10722 				*	DVSTAT+3, DVSTAT+3 (forced even),
 10723 				*	Relocating loader variables and parameters,
 10724 				*	Registers not saved;
 10725 				*
 10726 				*	Subroutines called:
 10727 				*	RLR (relocating loader).
 10728 				*
 10729 				*	ENTRY	JSR	LPH
 10730 				*
 10731 				*	MODS
 10732 				*		R. S. Scheiman	04/01/82
 10733 				*		1. Bring closer to Coding Standard (object unchanged).
 10734 				*		   R. K. Nordin	11/01/83
 10735
 10736
 10737 = E7DE			LPH	=	*	;entry
 10738
 10739 				;	Initialize.
 10740
 10741 E7DE 8D 13 03			STA	TEMP2	;save peripheral address
 10742 E7E1 A2 00			LDX	#0
 10743 E7E3 8E 12 03			STX	TEMP1	;set starting block number
 10744 E7E6 CA				DEX
 10745 E7E7 8E 15 03			STX	TEMP3	;set starting byte number
 10746
 10747 				; Ensure load address even.
 10748
 10749 E7EA AD EC 02			LDA	DVSTAT+2	;low load address
 10750 E7ED 6A				ROR
 10751 E7EE 90 08			BCC	LPH1		;if even
 10752
 10753 E7F0 EE EC 02			INC	DVSTAT+2	;increment low load address
 10754 E7F3 D0 03			BNE	LPH1		;if no carry
 10755
 10756 E7F5 EE ED 02			INC	DVSTAT+3	;increment high load address
 10757
 10758 				;	Set up relocating loader parameters.
 10759
 10760 E7F8 AD EC 02		LPH1	LDA	DVSTAT+2	;load address
 10761 E7FB 8D D1 02			STA	LOADAD
 10762 E7FE AD ED 02			LDA	DVSTAT+3
 10763 E801 8D D2 02			STA	LOADAD+1
 10764 E804 A9 16			LDA	#<PHG	;get-byte routine address
 10765 E806 8D CF 02			STA	GBYTEA
 10766 E809 A9 E8			LDA	#>PHG
 10767 E80B 8D D0 02			STA	GBYTEA+1
 10768 E80E A9 80			LDA	#$80		;loader page zero load addr:
 10769 E810 8D D3 02			STA	ZLOADA
 10770
 10771 				;	Relocate routine.
 10772
 10773 E813 4C 45 C7			JMP	RLR		;relocate routine, return
 10774 					;SPACE	4,10
 10775 				;	PHG - Perform Peripheral Handler GET-BYTE
 10776 				*
 10777 				*	Get a byte subroutine for relocating loader passes
 10778 				*	bytes from peripheral to relocating loader via
 10779 				*	cassette buffer. Calls GNL each time new
 10780 				*	buffer is needed.
 10781 				*
 10782 				*	Input Parameters:
 10783 				*	TEMP1: Next block number;
 10784 				*	TEMP2: Peripheral address (for GNL);
 10785 				*	TEMP3: Next byte number (index to CASBUF).
 10786 				*
 10787 				*	Output Parameters (for relocating loader):
 10788 				*	Carry bit indicates error;
 10789 				*	A	Next byte, if no error.
 10790 				*
 10791 				*	Modified:
 10792 				*	Cassette buffer CASBUF;
 10793 				*	TEMP3;
 10794 				*	X, Y not saved.
 10795 				*
 10796 				*	Subroutines called:
 10797 				*	GNL, which calls SIO to get load records.
 10798 				*
 10799 				*	ENTRY	JSR	PHG
 10800 				*
 10801 				*	MODS
 10802 				*		R. S. Scheiman	04/01/82
 10803 				*		1. Bring closer to Coding Standard (object unchanged).
 10804 				*		   R. K. Nordin	11/01/83
 10805
 10806 = E816			PHG	=	*		;entry
 10807
 10808 				;	Check for another byte in buffer.
 10809
 10810 E816 AE 15 03			LDX	TEMP3
 10811 E819 E8				INX
 10812 E81A 8E 15 03			STX	TEMP3
 10813 E81D F0 08			BEQ	PHG2		;if empty, load next block
 10814
 10815 				;	Retrieve next byte.
 10816
 10817 E81F AE 15 03		PHG1	LDX	TEMP3
 10818 E822 BD 7D 03			LDA	CASBUF-$80,X	;byte
 10819 E825 18				CLC			;indicate no error
 10820 E826 60				RTS			;return
 10821
 10822 				;	Load next block and retrieve next byte.
 10823
 10824 E827 A9 80		PHG2	LDA	#-128	;offset to first byte
 10825 E829 8D 15 03			STA	TEMP3
 10826 E82C 20 33 E8			JSR	GNL	;get next load block
 10827 E82F 10 EE			BPL	PHG1	;if no error, retrieve next byte
 10828
 10829 				;	Process error.
 10830
 10831 E831 38				SEC		;indicate error
 10832 E832 60				RTS		;return
 10833 					;SPACE	4,10
 10834 				;	GNL - Get Next Load Block
 10835 				*
 10836 				*	Subroutine to get a load block from the peripheral.
 10837 				*
 10838 				*	Input Parameters:
 10839 				*	TEMP1: Block number.
 10840 				*
 10841 				*	Output Parameters (for relocating loader):
 10842 				*	Negative bit is set by SIO if I/O error occurs.
 10843 				*
 10844 				*	Modified:
 10845 				*	TEMP1;
 10846 				*	the DCB (SIO);
 10847 				*	Registers not saved.
 10848 				*
 10849 				*	Subroutines called:
 10850 				*	SIO.
 10851 				*
 10852 				*	ENTRY	JSR	GNL
 10853 				*
 10854 				*	MODS
 10855 				*		R. S. Scheiman	04/01/82
 10856 				*		1. Bring closer to Coding Standard (object unchanged).
 10857 				*		   R. K. Nordin	11/01/83
 10858
 10859 = E833			GNL	=	*		;entry
 10860
 10861 				;	Set up DCB.
 10862 E833 A2 0B			LDX	#GNLAL-1	;offset to last DCB data by:
 10863
 10864 E835 BD 51 E8		GNL1	LDA	GNLA,X		;byte of DCB data
 10865 E838 9D 00 03			STA	DCB,X		;byte of DCB
 10866 E83B CA				DEX
 10867 E83C 10 F7			BPL	GNL1		;if not done
 10868
 10869 				;	Set DCB parameters
 10870
 10871 E83E AE 12 03			LDX	TEMP1		;block number
 10872 E841 8E 0A 03			STX	DAUX1		;auxiliary 1
 10873 E844 E8				INX
 10874 E845 8E 12 03			STX	TEMP1		;next block number
 10875 E848 AD 13 03			LDA	TEMP2		;device address
 10876 E84B 8D 00 03			STA	DDEVIC		;device bus ID
 10877
 10878 				;	Perform SIO.
 10879
 10880 E84E 4C 59 E4			JMP	SIOV		;vector to SIO, return.
 10881
 10882
 10883 				;	DCB Data
 10884
 10885 E851 00			GNLA	.byte	$00	;dummy device bus ID
 10886 E852 01				.byte	1	;dummy unit number
 10887 E853 26				.byte	'&'	;load command
 10888 E854 40				.byte	$40	;I/O direction
 10889 E855 FD 03			.word	CASBUF	;buffer
 10890 E857 1E				.byte	30	;timeout
 10891 E858 00				.byte	0
 10892 E859 80 00			.word	128	;buffer length
 10893 E85B 00				.byte	0	;auxiliary 1
 10894 E85C 00				.byte	0	;auxiliary 2
 10895
 10896 = 000C			GNLAL	=	*-GNLA	;length
 10897 					;SPACE	4,10
 10898 				;	SHC - Search Handler Chain
 10899 				*
 10900 				*	Forward chain search searches for pointer to handle:
 10901 				*	table whose address matches caller's parameter. If :
 10902 				*	parameter is zero, this routine looks for the point:
 10903 				*	the final linkage table since this table's forward :
 10904 				*	is zero (null.
 10905 				*
 10906 				*	Input Parameters:
 10907 				*	A	Linkage table address to match (High)
 10908 				*	Y	Linkage table address to match (Low)
 10909 				*
 10910 				*	Output Parameters:
 10911 				*	ZCHAIN points to linkage whose forward pointe:
 10912 				*		contains the match (if match is found);
 10913 				*		if the match is found just following the li:
 10914 				*		chain base CHLINK, then ZCHAIN points to CH:
 10915 				*		minus 18;
 10916 				*	If match successful, A (High) and X (Low) contain
 10917 				*		matched address (equiv. to A and Y parms.);
 10918 				*	Carry bit is set to indicate no match or checksum v:
 10919 				*		along the chain. [Note: the linkage table p:
 10920 				*		to by ZCHAIN upon return is not checksum ch:
 10921 				*
 10922 				*	Modified:
 10923 				*	TEMP1, TEMP2, ZCHAIN;
 10924 				*	The registers are not saved.
 10925 				*
 10926 				*	Subroutines called:
 10927 				*	CLT.
 10928 				*
 10929 				*	ENTRY	JSR	SHC
 10930 				*
 10931 				*	MODS
 10932 				*		R. S. Scheiman	04/01/82
 10933 				*		1. Bring closer to Coding Standard (object unchanged).
 10934 				*		   R. K. Nordin	11/01/83
 10935
 10936
 10937 = E85D			SHC	=	*	;entry
 10938
 10939 				;	Initialize.
 10940
 10941 E85D 8C 12 03			STY	TEMP1
 10942 E860 8D 13 03			STA	TEMP1+1
 10943 E863 A9 E9			LDA	#<[CHLINK-18]
 10944 E865 85 4A			STA	ZCHAIN		;start ZCHAIN at proper off:
 10945 E867 A9 03			LDA	#>[CHLINK-18]
 10946 E869 85 4B			STA	ZCHAIN+1
 10947
 10948 				;	Check for match.
 10949
 10950 E86B A0 12		SHC1	LDY	#18
 10951 E86D B1 4A			LDA	(ZCHAIN),Y
 10952 E86F AA				TAX			;low chain pointer
 10953 E870 C8				INY
 10954 E871 B1 4A			LDA	(ZCHAIN),Y	;high chain pointer
 10955 E873 CD 13 03			CMP	TEMP2		;check for match with param:
 10956 E876 D0 07			BNE	SHC2		;if no match
 10957
 10958 E878 EC 12 03			CPX	TEMP1
 10959 E87B D0 02			BNE	SHC2		;if no match
 10960
 10961 				;	Exit.
 10962
 10963 E87D 18				CLC		;indicate match
 10964 E87E 60				RTS		;return
 10965
 10966 				;	Check for end of chain.
 10967
 10968 E87F C9 00		SHC2	CMP	#0	;end of chain indicator
 10969 E881 D0 06			BNE	SHC4	;if not end of chain
 10970
 10971 E883 E0 00			CPX	#0
 10972 E885 D0 02			BNE	SHC4	;if not end of chain
 10973
 10974 				;	Process end of chain or checksum error.
 10975
 10976 E887 38			SHC3	SEC		;return error (checksum or end)
 10977 E888 60				RTS		;return
 10978
 10979 				;	Set link to new linkage table.
 10980
 10981 E889 86 4A		SHC4	STX	ZCHAIN	;link to new linkage table
 10982 E88B 85 4B			STA	ZCHAIN+1
 10983
 10984 E88D 20 56 CB			JSR	CLT	;checksum linkage table
 10985 E890 D0 F5			BNE	SHC3	;if error
 10986
 10987 				;	Continue searching chain.
 10988
 10989 E892 F0 D7			BEQ	SHC1	;continue searching chain
 10990 					;SPACE	4,10
 10991 				;	PHW - Perform Peripheral Handler Warmstart Initiali:
 10992 				*
 10993 				*	PHC is the main entry. This performs full initializ:
 10994 				*		including adding the new linkage table into:
 10995 				*		table chain;
 10996 				*	PHW does all initialization except adding to the li:
 10997 				*		table chain (intended for warm start reinit:
 10998 				*	PHI is the full initialization entry for calling
 10999 				*		init from outside the OS.
 11000 				*
 11001 				*	The code does the following:
 11002 				*	1)	Links new handler to end of chain;
 11003 				*	2)	Calls handler init subroutine in handler;
 11004 				*	3)	If 2 failed, unlinks handler from chain,
 11005 				*		and returns with carry;
 11006 				*	4)	Else, conditionally zeroes handler size ent:
 11007 				*		handler linkage table (per parameter);
 11008 				*	5)	Adds handler size entry (possibly zeroed) t:
 11009 				*	6)	If handler size entry is nonzero, MEMLO is :
 11010 				*		forced even;
 11011 				*	7)	Calculates and enters linkage table checksu:
 11012 				*	8)	Returns with carry clear.
 11013 				*
 11014 				*	PHC is called by PHR when loading handlers at cold
 11015 				*		initialization;and by PHL when loading a ha:
 11016 				*		application request under CIO;
 11017 				*	PHW is called by PHR to reinitialize a handler duri:
 11018 				*		warm-start;
 11019 				*	PHI is vectored by OS vector at $E49E and is intend:
 11020 				*		for use by system-level applications which :
 11021 				*		handlers (ie., AUTORUN.SYS handler loader, :
 11022 				*
 11023 				*	Input Parameters:
 11024 				*	PHC:
 11025 				*		DVSTAT, DVSTAT+1 contain handler size (for
 11026 				*		handler init, not used by this routine);
 11027 				*		DVSTAT+2, DVSTAT+3 contain handler linkage :
 11028 				*		address.
 11029 				*	PHW:
 11030 				*		DVSTAT+2, DVSTAT+3 same;
 11031 				*		DVSTAT, DVSTAT+1 undefined.
 11032 				*	PHI:
 11033 				*		A and Y contain handler linkage table addre:
 11034 				*		they are copied into DVSTAT+3 and DVSTAT+2;
 11035 				*		DVSTAT, DVSTAT+1 may or may not be signific:
 11036 				*		any concern about these are up to the progr:
 11037 				*		of the peripheral handler init routine and :
 11038 				*		is making use of the non-OS-caller entry PH:
 11039 				*
 11040 				*	For PHI and PHC, the Carry bit specifies whether
 11041 				*		the handler size entry of the linkage table:
 11042 				*		be zeroed prior to adding to MEMLO: Carry s:
 11043 				*		do NOT zero this entry.
 11044 				*
 11045 				*	Output Parameters:
 11046 				*	Carry indicates error (initialization failed);
 11047 				*	The registers are not saved.
 11048 				*
 11049 				*	Modified:
 11050 				*	DVSTAT+2, DVSTAT+3 are modified by PHI;
 11051 				*	ZCHAIN, TEMP1, TEMP2;
 11052 				*	MEMLO, MEMLO+1 conditionally incremented by handler:
 11053 				*
 11054 				*	Subroutines called:
 11055 				*	SHC (to find end of linkage table chain);
 11056 				*	PHU (to unlink handler if init. error);
 11057 				*	CLT (to insert linkage table checksum);
 11058 				*	loaded handler's INIT entry.
 11059 				*
 11060 				*	ENTRY	JSR	PHW
 11061 				*
 11062 				*	MODS
 11063 				*		R. S. Scheiman	04/01/82
 11064 				*		1. Bring closer to Coding Standard (object unchanged).
 11065 				*		   R. K. Nordin	11/01/83
 11066
 11067
 11068 = E894			PHW	=	*	;entry
 11069 E894 38				SEC		;indicate not zeroing handler size
 11070 E895 08				PHP
 11071 E896 B0 28			BCS	PHQ	;initialize handler and update MEML:
 11072 					;SPACE	4,10
 11073 				;	PHI - Perform Peripheral Handler Initialization wit:
 11074 				*
 11075 				*	ENTRY	JSR	PHI
 11076 				*
 11077 				*	MODS
 11078 				*		R. S. Scheiman	04/01/82
 11079 				*		1. Bring closer to Coding Standard (object unchanged).
 11080 				*		   R. K. Nordin	11/01/83
 11081
 11082
 11083 = E898			PHI	=	*		;entry
 11084 E898 8D ED 02			STA	DVSTAT+3
 11085 E89B 8C EC 02			STY	DVSTAT+2
 11086 				;	JMP	PHC		;perform coldstart initiali:
 11087 					;SPACE	4,10
 11088 				;	PHC - Perform Peripheral Handler Coldstart Initiali:
 11089 				*
 11090 				*	ENTRY	JSR	PHC
 11091 				*
 11092 				*	MODS
 11093 				*		R. S. Scheiman	04/01/82
 11094 				*		1. Bring closer to Coding Standard (object unchanged).
 11095 				*		   R. K. Nordin	11/01/83
 11096
 11097 = E89E			PHC	=	*	;entry
 11098
 11099 				;	Initialize.
 11100
 11101 E89E 08				PHP
 11102
 11103 				;	Search for end of chain.
 11104
 11105 E89F A9 00			LDA	#0	;indicate searching for end of chai:
 11106 E8A1 A8				TAY
 11107 E8A2 20 5D E8			JSR	SHC	;search handler chain
 11108 E8A5 B0 27			BCS	PHQ1	;if error, exit
 11109
 11110 				;	Enter at end of chain.
 11111
 11112 E8A7 A0 12			LDY	#18		;offset
 11113 E8A9 AD EC 02			LDA	DVSTAT+2
 11114 E8AC 91 4A			STA	(ZCHAIN),Y	;low link
 11115 E8AE AA				TAX
 11116 E8AF C8				INY
 11117 E8B0 AD ED 02			LDA	DVSTAT+3
 11118 E8B3 91 4A			STA	(ZCHAIN),Y	;high link
 11119 E8B5 86 4A			STX	ZCHAIN		;link to new table
 11120 E8B7 85 4B			STA	ZCHAIN+1
 11121 E8B9 A9 00			LDA	#0		;indicate end of chain
 11122 E8BB 91 4A			STA	(ZCHAIN),Y	;low link
 11123 E8BD 88				DEY
 11124 E8BE 91 4A			STA	(ZCHAIN),Y	;high link
 11125
 11126 				;	Initialize handler.
 11127
 11128 				;	JMP	PHQ		;initialize handler, return
 11129 					;SPACE	4,10
 11130 				;	PHQ - Initialize Handler and Update MEMLO
 11131 				*
 11132 				*	ENTRY	JSR	PHQ
 11133 				*
 11134 				*	MODS
 11135 				*		R. S. Scheiman	04/01/82
 11136 				*		1. Bring closer to Coding Standard (object unchanged).
 11137 				*		   R. K. Nordin	11/01/83
 11138
 11139
 11140 = E8C0			PHQ	=	*		;entry
 11141
 11142 				;	Initialize handler.
 11143
 11144 E8C0 20 00 E9			JSR	PHX		;initialize handler
 11145 E8C3 90 0C			BCC	PHQ2		;if no error
 11146
 11147 				;	Process error.
 11148
 11149 E8C5 AD ED 02			LDA	DVSTAT+3
 11150 E8C8 AC EC 02			LDY	DVSTAT+2
 11151 E8CB 20 15 E9			JSR	PHU		;unlink handler
 11152
 11153 				;	Exit, indicating error.
 11154
 11155 E8CE 28			PHQ1	PLP			;fix stack
 11156 E8CF 38				SEC			;indicate error
 11157 E8D0 60				RTS			;return
 11158
 11159 				;	Check for zeroing handler size.
 11160
 11161 E8D1 28			PHQ2	PLP
 11162 E8D2 B0 09			BCS	PHQ3		;if not zero
 11163
 11164 				;	Zero handler size.
 11165
 11166 E8D4 A9 00			LDA	#0
 11167 E8D6 A0 10			LDY	#16		;offset
 11168 E8D8 91 4A			STA	(ZCHAIN),Y	;zero size
 11169 E8DA C8				INY
 11170 E8DB 91 4A			STA	(ZCHAIN),Y
 11171
 11172 				; Increase MEMLO by size.
 11173
 11174 E8DD 18			PHQ3	CLC
 11175 E8DE A0 10			LDY	#16		;offset to size
 11176 E8E0 AD E7 02			LDA	MEMLO
 11177 E8E3 71 4A			ADC	(ZCHAIN),Y	;add low size
 11178 E8E5 8D E7 02			STA	MEMLO		;new low MEMLO
 11179 E8E8 C8				INY
 11180 E8E9 AD E8 02			LDA	MEMLO+1
 11181 E8EC 71 4A			ADC	(ZCHAIN),Y	;add high size
 11182 E8EE 8D E8 02			STA	MEMLO+1		;new high MEMLO
 11183
 11184 				;	Pu checksum in linkage table.
 11185
 11186 E8F1 A0 0F			LDY	#15		;offset to checksum
 11187 E8F3 A9 00			LDA	#0
 11188 E8F5 91 4A			STA	(ZCHAIN),Y	;clear checksum
 11189 E8F7 20 56 CB			JSR	CLT		;checksum linkage table
 11190 E8FA A0 0F			LDY	#15		;offset to checksum
 11191 E8FC 91 4A			STA	(ZCHAIN),Y	;checksum
 11192
 11193 				;	Exit.
 11194
 11195 E8FE 18				CLC			;indicate success
 11196 E8FF 60				RTS			;return
 11197 					;SPACE	4,10
 11198 				;	PHX - Initialize Handler
 11199 				*
 11200 				*	ENTRY	JSR	PHX
 11201 				*
 11202 				*	MODS
 11203 				*		R. S. Scheiman	04/01/82
 11204 				*		1. Bring closer to Coding Standard (object unchanged).
 11205 				*		   R. K. Nordin	11/01/83
 11206
 11207
 11208 = E900			PHX	=	*		;entry
 11209 E900 18				CLC
 11210 E901 A5 4A			LDA	ZCHAIN
 11211 E903 69 0C			ADC	#12
 11212 E905 8D 12 03			STA	TEMP1		;low handler initialization:
 11213 E908 A5 4B			LDA	ZCHAIN+1
 11214 E90A 69 00			ADC	#0
 11215 E90C 8D 13 03			STA	TEMP1+1		;high handler initializatio:
 11216 E90F 6C 12 03			JMP	(TEMP1)		;initialize handler, return
 11217 				;	;SUBTTL	'$E912 Patch'
 11218 					;SPACE	4,10
 11219 E912				ORG	$E912
 11220 					;SPACE	4,10
 11221 				;	E912 - $E912 Patch
 11222 				*
 11223 				*	For compatibilty with OS Revision B, set VBLANK parameters.
 11224
 11225
 11226 E912 4C 72 C2			JMP	SVP	;set VBLANK parameters, return
 11227 				;	;SUBTTL	'Peripheral Handler Loading Facility, Part 4'
 11228 					;SPACE	4,10
 11229 				;	PHU - Perform Peripheral Handler Unlinking
 11230 				*
 11231 				*	Handler entry unlinking routine. This routine is ca:
 11232 				*	by the OS handler initialization to unlink a handle:
 11233 				*	initialization fails, or by the handler itself if i:
 11234 				*	the handler unload feature.     This routine is ent:
 11235 				*	OS vector at $E49B.
 11236 				*
 11237 				*	Input Parameters:
 11238 				*	A	Address of linkage table to unlink (High);
 11239 				*	Y	Address of linkage table to unlink (Low).
 11240 				*	COLDST: Tested to see if PHU is called during cold :
 11241 				*		if so, chain entry is unlinked even if at M:
 11242 				*
 11243 				*	Output Parameters:
 11244 				*	Carry is set to indicate error;in this case,
 11245 				*		no unlinking has occurred.
 11246 				*
 11247 				*	Modified:
 11248 				*	TEMP1, TEMP2;
 11249 				*	ZCHAIN,ZCHAIN+1;
 11250 				*	The forward chain pointer in the precedessor of the:
 11251 				*	table being removed is modified to point to the suc:
 11252 				*	of the removed table if the removal is successful--
 11253 				*	this forward chain pointer may be CHLINK, CHLINK+1.
 11254 				*
 11255 				*	The registers are not saved.
 11256 				*
 11257 				*	Subroutines called:
 11258 				*	SHC, CLT.
 11259 				*
 11260 				*	ENTRY	JSR	PHU
 11261 				*
 11262 				*	MODS
 11263 				*		R. S. Scheiman	04/01/82
 11264 				*		1. Bring closer to Coding Standard (object unchanged).
 11265 				*		   R. K. Nordin	11/01/83
 11266
 11267
 11268 = E915			PHU	=	*		;entry
 11269
 11270 				;	Search handler chain.
 11271
 11272 E915 20 5D E8			JSR	SHC		;search handler chain
 11273 E918 B0 3B			BCS	PHU3		;if error
 11274
 11275 				;	Perform unlinking.
 11276
 11277 E91A A8				TAY			;(save return parameter)
 11278 E91B A5 4A			LDA	ZCHAIN		;save ZCHAIN (points to pre:
 11279 E91D 48				PHA
 11280 E91E A5 4B			LDA	ZCHAIN+1
 11281 E920 48				PHA
 11282 E921 86 4A			STX	ZCHAIN		;make ZCHAIN point to linka:
 11283 E923 84 4B			STY	ZCHAIN+1	;to be removed
 11284 E925 AD 44 02			LDA	COLDST		;coldstart flag
 11285 E928 D0 0F			BNE	PHU1		;if coldstart, unconditional:
 11286
 11287 E92A A0 10			LDY	#16		;check if loaded at MEMLO..:
 11288 E92C 18				CLC			;by checking if size is non:
 11289 E92D B1 4A			LDA	(ZCHAIN),Y
 11290 E92F C8				INY
 11291 E930 71 4A			ADC	(ZCHAIN),Y
 11292 E932 D0 1F			BNE	PHU2		;if handler size non-zero
 11293
 11294 E934 20 56 CB			JSR	CLT		;checksum linkage table
 11295 E937 D0 1A			BNE	PHU2		;if checksum nonzero, bad c:
 11296
 11297 E939 A0 12		PHU1	LDY	#18		;take link from table being:
 11298 E93B B1 4A			LDA	(ZCHAIN),Y
 11299 E93D AA				TAX
 11300 E93E C8				INY
 11301 E93F B1 4A			LDA	(ZCHAIN),Y
 11302 E941 A8				TAY
 11303 E942 68				PLA		;Make ZCHAIN point to the predecess:
 11304 E943 85 4B			STA	ZCHAIN+1
 11305 E945 68				PLA
 11306 E946 85 4A			STA	ZCHAIN
 11307 E948 98				TYA		;And put forward link from table be:
 11308 E949 A0 13			LDY	#19	;removed into its predecessors link:
 11309 E94B 91 4A			STA	(ZCHAIN),Y
 11310 E94D 88				DEY
 11311 E94E 8A				TXA
 11312 E94F 91 4A			STA	(ZCHAIN),Y
 11313 E951 18				CLC		;indicate success
 11314 E952 60				RTS		;return
 11315
 11316 				;	Clean stack and process error.
 11317
 11318 E953 68			PHU2	PLA		;Error return--restore stack
 11319 E954 68				PLA
 11320
 11321 				;	Process error.
 11322
 11323 E955 38			PHU3	SEC		;indicate error
 11324 E956 60				RTS		;return
 11325 				;	;SUBTTL	'$E959 Patch'
 11326 					;SPACE	4,10
 11327 E957				ORG	$E959
 11328 					;SPACE	4,10
 11329 				;	E959 - $E959 Patch
 11330 				*
 11331 				*	For compatibilty with OS Revision B, perform PIO.
 11332
 11333
 11334 E959 4C 33 C9			JMP	PIO	;perform PIO, return
 11335 				;	;SUBTTL	'Serial Input/Output'
 11336 					;SPACE	4,10
 11337 				;	ISIO - Initialize SIO
 11338 				*
 11339 				*	ENTRY	JSR	ISIO
 11340 				*
 11341 				*	MODS
 11342 				*		Original Author Unknown
 11343 				*		1. Bring closer to Coding Standard (object unchanged).
 11344 				*		   R. K. Nordin	11/01/83
 11345
 11346
 11347 = E95C			ISIO	=	*	;entry
 11348
 11349 E95C A9 3C			LDA	#MOTRST
 11350 E95E 8D 02 D3			STA	PACTL	;turn off motor
 11351
 11352 E961 A9 3C			LDA	#NCOMHI
 11353 E963 8D 03 D3			STA	PBCTL	;raise NOT COMMAND line
 11354
 11355 E966 A9 03			LDA	#$03	;POKEY out of initialize mode
 11356 E968 8D 32 02			STA	SSKCTL	;SKCTL shadow
 11357 E96B 85 41			STA	SOUNDR	;select noisy I/O
 11358 E96D 8D 0F D2			STA	SKCTL
 11359
 11360 E970 60				RTS		;return
 11361 					;SPACE	4,10
 11362 				;	SIO - Serial Input/Output
 11363 				*
 11364 				*	ENTRY	JSR	SIO
 11365 				*
 11366 				*	MODS
 11367 				*		Original Author Unknown
 11368 				*		1. Bring closer to Coding Standard (object unchanged).
 11369 				*		   R. K. Nordin	11/01/83
 11370
 11371
 11372 = E971			SIO	=	*	;entry
 11373
 11374 				;	Initialize.
 11375
 11376 E971 BA				TSX
 11377 E972 8E 18 03			STX	STACKP	;save stack pointer
 11378 E975 A9 01			LDA	#1	;critical section indicator
 11379 E977 85 42			STA	CRITIC	;indicate critical section
 11380
 11381 				;	Check device ID.
 11382
 11383 E979 AD 00 03			LDA	DDEVIC	;device ID
 11384 E97C C9 60			CMP	#CASET
 11385 E97E D0 03			BNE	SIO1	;if not cassette
 11386
 11387 				;	Process cassette.
 11388
 11389 E980 4C 9D EB			JMP	PCI	;process cassette I/O, return
 11390
 11391 				;	Process intelligent device.
 11392
 11393 E983 A9 00		SIO1	LDA	#0
 11394 E985 8D 0F 03			STA	CASFLG	;indicate not cassette
 11395
 11396 E988 A9 01			LDA	#DRETRI
 11397 E98A 8D BD 02			STA	DRETRY	;set device retry count
 11398
 11399 E98D A9 0D		SIO2	LDA	#CRETRI
 11400 E98F 8D 9C 02			STA	CRETRY	;set command frame retry count
 11401
 11402 				;	Send command frame.
 11403
 11404 E992 A9 28		SIO3	LDA	#<B19200
 11405 E994 8D 04 D2			STA	AUDF3		;set baud rate to 19200
 11406 E997 A9 00			LDA	#>B19200
 11407 E999 8D 06 D2			STA	AUDF4
 11408
 11409 				;	Set up command buffer.
 11410
 11411 E99C 18				CLC
 11412 E99D AD 00 03			LDA	DDEVIC		;device ID
 11413 E9A0 6D 01 03			ADC	DUNIT		;add unit number
 11414 E9A3 69 FF			ADC	#$FF		;subtract 1
 11415 E9A5 8D 3A 02			STA	CDEVIC		;device bus ID
 11416 E9A8 AD 02 03			LDA	DCOMND		;command
 11417 E9AB 8D 3B 02			STA	CCOMND
 11418 E9AE AD 0A 03			LDA	DAUX1		;auxiliary information 1
 11419 E9B1 8D 3C 02			STA	CAUX1
 11420 E9B4 AD 0B 03			LDA	DAUX2		;auxiliary information 2
 11421 E9B7 8D 3D 02			STA	CAUX2
 11422
 11423 				;	Set buffer pointer to command frame buffer.
 11424
 11425 E9BA 18				CLC
 11426 E9BB A9 3A			LDA	#<CDEVIC	;low buffer address
 11427 E9BD 85 32			STA	BUFRLO		;low buffer address
 11428 E9BF 69 04			ADC	#4
 11429 E9C1 85 34			STA	BFENLO		;low buffer end address
 11430 E9C3 A9 02			LDA	#>CDEVIC	;high buffer address
 11431 E9C5 85 33			STA	BUFRHI		;high buffer address
 11432 E9C7 85 35			STA	BFENHI		;high buffer end address
 11433
 11434 				;	Send command frame to device.
 11435
 11436 E9C9 A9 34			LDA	#NCOMLO
 11437 E9CB 8D 03 D3			STA	PBCTL		;lower NOT COMMAND line
 11438 E9CE 20 AF EC			JSR	SID		;send command frame
 11439 E9D1 AD 3F 02			LDA	ERRFLG		;error flag
 11440 E9D4 D0 03			BNE	SIO4		;if error received
 11441
 11442 E9D6 98				TYA			;status
 11443 E9D7 D0 08			BNE	SIO5		;if ACK received
 11444
 11445 				;	Process NAK or timeout.
 11446
 11447 E9D9 CE 9C 02		SIO4	DEC	CRETRY	;decrement command frame retry count
 11448 E9DC 10 B4			BPL	SIO3	;if retries not exhausted
 11449
 11450 				;	Process command frame retries exhausted.
 11451
 11452 E9DE 4C 22 EA			JMP	SIO10	;process error
 11453
 11454 				;	Process ACK.
 11455
 11456 E9E1 AD 03 03		SIO5	LDA	DSTATS
 11457 E9E4 10 0D			BPL	SIO6	;if no data to send
 11458
 11459 				;	Send data frame to device.
 11460
 11461 E9E6 A9 0D			LDA	#CRETRI
 11462 E9E8 8D 9C 02			STA	CRETRY	;set command frame retry count
 11463 E9EB 20 87 EB			JSR	SBP	;set buffer pointers
 11464 E9EE 20 AF EC			JSR	SID	;send data frame
 11465 E9F1 F0 2F			BEQ	SIO10	;if error
 11466
 11467 				;	Wait for complete.
 11468
 11469 E9F3 20 9A EC		SIO6	JSR	GTO	;set device timeout
 11470 E9F6 A9 00			LDA	#0
 11471 E9F8 8D 3F 02			STA	ERRFLG	;clear error flag
 11472 E9FB 20 C0 EC			JSR	STW	;set timer and wait
 11473 E9FE F0 12			BEQ	SIO8	;if timeout
 11474
 11475 				;	Process no timeout.
 11476
 11477 EA00 2C 03 03			BIT	DSTATS
 11478 EA03 70 07			BVS	SIO7	;if more data follows
 11479
 11480 EA05 AD 3F 02			LDA	ERRFLG	;error flag
 11481 EA08 D0 18			BNE	SIO10	;if error
 11482
 11483 				;	Process no error.
 11484
 11485 EA0A F0 1E			BEQ	CSO	;complete SIO operation
 11486
 11487 				;	Receive data frame from device.
 11488
 11489 EA0C 20 87 EB		SIO7	JSR	SBP	;set buffer pointers
 11490 EA0F 20 FD EA			JSR	REC	;receive
 11491
 11492 				;	Check error flag.
 11493
 11494 EA12 AD 3F 02		SIO8	LDA	ERRFLG	;error flag
 11495 EA15 F0 05			BEQ	SIO9	;if no error preceded data
 11496
 11497 				;	Process error.
 11498
 11499 EA17 AD 19 03			LDA	TSTAT	;temporary status
 11500 EA1A 85 30			STA	STATUS	;status
 11501
 11502 				;	Check status.
 11503
 11504 EA1C A5 30		SIO9	LDA	STATUS	;status
 11505 EA1E C9 01			CMP	#SUCCES
 11506 EA20 F0 08			BEQ	CSO	;if successful, complete operation, return
 11507
 11508 				;	Process error.
 11509
 11510 EA22 CE BD 02		SIO10	DEC	DRETRY	;decrement device retry count
 11511 EA25 30 03			BMI	CSO	;if retries exhausted, complete, return
 11512
 11513 				;	Retry.
 11514
 11515 EA27 4C 8D E9			JMP	SIO2	;retry
 11516 					;SPACE	4,10
 11517 				;	CSO - Complete SIO Operation
 11518 				*
 11519 				*	ENTRY	JSR	CSO
 11520 				*
 11521 				*	MODS
 11522 				*		Original Author Unknown
 11523 				*		1. Bring closer to Coding Standard (object unchanged).
 11524 				*		   R. K. Nordin	11/01/83
 11525
 11526
 11527 = EA2A			CSO	=	*	;entry
 11528 EA2A 20 84 EC			JSR	DSR	;disable SEND and RECEIVE
 11529 EA2D A9 00			LDA	#0	;not critical section indicator
 11530 EA2F 85 42			STA	CRITIC	;critical section flag
 11531 EA31 A4 30			LDY	STATUS	;status
 11532 EA33 8C 03 03			STY	DSTATS	;status
 11533 EA36 60				RTS		;return
 11534 					;SPACE	4,10
 11535 				;	WCA - Wait for Completion or ACK
 11536 				*
 11537 				*	ENTRY	JSR	WCA
 11538 				*
 11539 				*	EXIT
 11540 				*		Y = 0, if failure
 11541 				*		  = $FF, if success
 11542 				*
 11543 				*	NOTES
 11544 				*		Problem: WCA does not handle NAK correctly;:
 11545 				*		just before WCA3 should be removed.
 11546 				*
 11547 				*	MODS
 11548 				*		Original Author Unknown
 11549 				*		1. Bring closer to Coding Standard (object unchanged).
 11550 				*		   R. K. Nordin	11/01/83
 11551
 11552
 11553 = EA37			WCA	=	*		;entry
 11554
 11555 				;	Initialize.
 11556
 11557 EA37 A9 00			LDA	#0
 11558 EA39 8D 3F 02			STA	ERRFLG		;clear error flag
 11559
 11560 				;	Set buffer pointer.
 11561
 11562 EA3C 18				CLC
 11563 EA3D A9 3E			LDA	#<TEMP	;low temporary address
 11564 EA3F 85 32			STA	BUFRLO		;low buffer address
 11565 EA41 69 01			ADC	#1
 11566 EA43 85 34			STA	BFENLO		;low buffer end address
 11567 EA45 A9 02			LDA	#>TEMP	;high temporary address
 11568 EA47 85 33			STA	BUFRHI		;high buffer address
 11569 EA49 85 35			STA	BFENHI		;high buffer end address
 11570 EA4B A9 FF			LDA	#$FF
 11571 EA4D 85 3C			STA	NOCKSM		;indicate no checksum follows
 11572 EA4F 20 FD EA			JSR	REC		;receive
 11573 EA52 A0 FF			LDY	#$FF		;assume success
 11574 EA54 A5 30			LDA	STATUS		;status
 11575 EA56 C9 01			CMP	#SUCCES
 11576 EA58 D0 19			BNE	WCA2		;if failure
 11577
 11578 EA5A AD 3E 02			LDA	TEMP		;byte received
 11579 EA5D C9 41			CMP	#ACK
 11580 EA5F F0 21			BEQ	WCA4		;if ACK, exit
 11581
 11582 EA61 C9 43			CMP	#COMPLT
 11583 EA63 F0 1D			BEQ	WCA4		;if complete, exit
 11584
 11585 EA65 C9 45			CMP	#ERROR
 11586 EA67 D0 06			BNE	WCA1		;if device did not send back
 11587
 11588 				;	Process unrecognized response.
 11589
 11590 EA69 A9 90			LDA	#DERROR
 11591 EA6B 85 30			STA	STATUS		;indicate device error
 11592 EA6D D0 04			BNE	WCA2		;check for timeout
 11593
 11594 				;	Process nothing sent back.
 11595
 11596 EA6F A9 8B		WCA1	LDA	#DNACK
 11597 EA71 85 30			STA	STATUS		;indicate NAK
 11598
 11599 				;	Check for timeout.
 11600
 11601 EA73 A5 30		WCA2	LDA	STATUS		;status
 11602 EA75 C9 8A			CMP	#TIMOUT
 11603 EA77 F0 07			BEQ	WCA3		;if timeout
 11604
 11605 				;	Process other error.
 11606
 11607 EA79 A9 FF			LDA	#$FF		;error indicator
 11608 EA7B 8D 3F 02			STA	ERRFLG		;indicate error
 11609 EA7E D0 02			BNE	WCA4		;exit
 11610
 11611 				;	Indicate failure.
 11612
 11613 EA80 A0 00		WCA3	LDY	#0		;failure indicator
 11614
 11615 				;	Exit.
 11616
 11617 EA82 A5 30		WCA4	LDA	STATUS		;status
 11618 EA84 8D 19 03			STA	TSTAT		;temporary status
 11619 EA87 60				RTS			;return
 11620 					;SPACE	4,10
 11621 				;	SEN - Send
 11622 				*
 11623 				*	SEN sends a buffer over the serial bus.
 11624 				*
 11625 				*	ENTRY	JSR	SEN
 11626 				*
 11627 				*	NOTES
 11628 				*		Problem: an interrupt may occur before CHKS:
 11629 				*		initialized, causing an incorrect checksum :
 11630 				*		STA CHKSUM should precede STA SEROUT.
 11631 				*
 11632 				*	MODS
 11633 				*		Original Author Unknown
 11634 				*		1. Bring closer to Coding Standard (object unchanged).
 11635 				*		   R. K. Nordin	11/01/83
 11636
 11637
 11638 = EA88			SEN	=	*		;entry
 11639
 11640 				;	Initialize.
 11641
 11642 EA88 A9 01			LDA	#SUCCES		;assume success
 11643 EA8A 85 30			STA	STATUS		;status
 11644 EA8C 20 17 EC			JSR	ESS		;enable SIO SEND
 11645 EA8F A0 00			LDY	#0
 11646 EA91 84 31			STY	CHKSUM		;clear checksum
 11647 EA93 84 3B			STY	CHKSNT		;clear checksum sent flag
 11648 EA95 84 3A			STY	XMTDON		;clear transmit-frame done flag
 11649
 11650 				;	Initiate TRANSMIT.
 11651
 11652 EA97 B1 32			LDA	(BUFRLO),Y	;first byte from buffer
 11653 EA99 8D 0D D2			STA	SEROUT		;serial output register
 11654 EA9C 85 31			STA	CHKSUM		;checksum
 11655
 11656 				;	Check BREAK key.
 11657
 11658 EA9E A5 11		SEN1	LDA	BRKKEY
 11659 EAA0 D0 03			BNE	SEN2		;if BREAK key not pressed
 11660
 11661 				;	Process BREAK key.
 11662
 11663 EAA2 4C C7 ED			JMP	PBK		;process BREAK key, return
 11664
 11665 				;	Process BREAK key not pressed.
 11666
 11667 EAA5 A5 3A		SEN2	LDA	XMTDON		;transmit-frame done flag
 11668 EAA7 F0 F5			BEQ	SEN1		;if transmit-frame not done
 11669
 11670 				;	Exit.
 11671
 11672 EAA9 20 84 EC			JSR	DSR		;disable SEND and RECEIVE
 11673 EAAC 60				RTS			;return
 11674 					;SPACE	4,10
 11675 				;	ORIR - Process Serial Output Ready IRQ
 11676 				*
 11677 				*	ENTRY	JMP	ORIR
 11678 				*
 11679 				*	EXIT
 11680 				*		Exits via RTI
 11681 				*
 11682 				*	MODS
 11683 				*		Original Author Unknown
 11684 				*		1. Bring closer to Coding Standard (object unchanged).
 11685 				*		   R. K. Nordin	11/01/83
 11686
 11687
 11688 = EAAD			ORIR	=	*	;entry
 11689
 11690 				;	Initialize.
 11691
 11692 EAAD 98				TYA
 11693 EAAE 48				PHA		;save Y
 11694 EAAF E6 32			INC	BUFRLO	;increment low buffer pointer
 11695 EAB1 D0 02			BNE	ORI1	;if low buffer pointer non-zero
 11696
 11697 EAB3 E6 33			INC	BUFRHI	;increment high buffer pointer
 11698
 11699 				;	Check end of buffer.
 11700
 11701 EAB5 A5 32		ORI1	LDA	BUFRLO	;buffer address
 11702 EAB7 C5 34			CMP	BFENLO	;buffer end address
 11703 EAB9 A5 33			LDA	BUFRHI
 11704 EABB E5 35			SBC	BFENHI
 11705 EABD 90 1C			BCC	ORI4	;if not past end of buffer
 11706
 11707 				;	Process end of buffer.
 11708
 11709 EABF A5 3B			LDA	CHKSNT	;checksum sent flag
 11710 EAC1 D0 0B			BNE	ORI2	;if checksum already sent
 11711
 11712 				;	Send checksum.
 11713
 11714 EAC3 A5 31			LDA	CHKSUM	;checksum
 11715 EAC5 8D 0D D2			STA	SEROUT	;serial output register
 11716 EAC8 A9 FF			LDA	#$FF
 11717 EACA 85 3B			STA	CHKSNT	;indicate checksum sent
 11718 EACC D0 09			BNE	ORI3
 11719
 11720 				;	Enable TRANSMIT done interrupt.
 11721
 11722 EACE A5 10		ORI2	LDA	POKMSK
 11723 EAD0 09 08			ORA	#$08
 11724 EAD2 85 10			STA	POKMSK
 11725 EAD4 8D 0E D2			STA	IRQEN
 11726
 11727 				;	Exit.
 11728
 11729 EAD7 68			ORI3	PLA
 11730 EAD8 A8				TAY		;restore Y
 11731 EAD9 68				PLA		;restore A
 11732 EADA 40				RTI		;return
 11733
 11734 				;	Transmit next byte from buffer.
 11735
 11736 EADB A0 00		ORI4	LDY	#0
 11737 EADD B1 32			LDA	(BUFRLO),Y	;byte from buffer
 11738 EADF 8D 0D D2			STA	SEROUT		;serial output register
 11739 EAE2 18				CLC
 11740 EAE3 65 31			ADC	CHKSUM		;add byte to checksum
 11741 EAE5 69 00			ADC	#0
 11742 EAE7 85 31			STA	CHKSUM		;update checksum
 11743 EAE9 4C D7 EA			JMP	ORI3		;exit
 11744 					;SPACE	4,10
 11745 				;	OCIR - Process Serial Output Complete IRQ
 11746 				*
 11747 				*	ENTRY	JMP	OCIR
 11748 				*
 11749 				*	EXIT
 11750 				*		Exits via RTI
 11751 				*
 11752 				*	MODS
 11753 				*		Original Author Unknown
 11754 				*		1. Bring closer to Coding Standard (object unchanged).
 11755 				*		   R. K. Nordin	11/01/83
 11756
 11757
 11758 = EAEC			OCIR	=	*	;entry
 11759
 11760 				;	Check checksum sent.
 11761
 11762 EAEC A5 3B			LDA	CHKSNT	;checksum sent flag
 11763 EAEE F0 0B			BEQ	OCI1	;if checksum not yet sent
 11764
 11765 				;	Process checksum sent.
 11766
 11767 EAF0 85 3A			STA	XMTDON	;indicate transmit-frame done
 11768
 11769 				;	Disable TRANSMIT done interrupt.
 11770
 11771 EAF2 A5 10			LDA	POKMSK
 11772 EAF4 29 F7			AND	#$F7
 11773 EAF6 85 10			STA	POKMSK
 11774 EAF8 8D 0E D2			STA	IRQEN
 11775
 11776 				;	Exit.
 11777
 11778 EAFB 68			OCI1	PLA		;restore A
 11779 EAFC 40				RTI		;return
 11780 					;SPACE	4,10
 11781 				;	REC - Receive
 11782 				*
 11783 				*	ENTRY	JSR	REC
 11784 				*
 11785 				*	MODS
 11786 				*		Original Author Unknown
 11787 				*		1. Bring closer to Coding Standard (object unchanged).
 11788 				*		   R. K. Nordin	11/01/83
 11789
 11790
 11791 = EAFD			REC	=	*	;entry
 11792
 11793 				;	Initialize.
 11794
 11795 EAFD A9 00			LDA	#0
 11796 EAFF AC 0F 03			LDY	CASFLG
 11797 EB02 D0 02			BNE	REC1	;if cassette
 11798
 11799 EB04 85 31			STA	CHKSUM	;initialize checksum
 11800
 11801 EB06 85 38		REC1	STA	BUFRFL	;clear buffer full flag
 11802 EB08 85 39			STA	RECVDN	;clear receive-frame done flag
 11803 EB0A A9 01			LDA	#SUCCES	;assume success
 11804 EB0C 85 30			STA	STATUS	;status
 11805 EB0E 20 40 EC			JSR	ESR	;enable SIO RECEIVE
 11806 EB11 A9 3C			LDA	#NCOMHI
 11807 EB13 8D 03 D3			STA	PBCTL
 11808
 11809 				;	Check BREAK key.
 11810
 11811 EB16 A5 11		REC2	LDA	BRKKEY
 11812 EB18 D0 03			BNE	REC3	;if BREAK key not pressed
 11813
 11814 				;	Process BREAK key.
 11815
 11816 EB1A 4C C7 ED			JMP	PBK	;process BREAK key, return
 11817
 11818 				;	Process BREAK key not pressed.
 11819
 11820 EB1D AD 17 03		REC3	LDA	TIMFLG	;timeout flag
 11821 EB20 F0 05			BEQ	ITO	;if timeout, indicate timeout
 11822
 11823 				;	Process no timeout.
 11824
 11825 EB22 A5 39			LDA	RECVDN	;receive-frame done flag
 11826 EB24 F0 F0			BEQ	REC2	;if receive-frame done, continue
 11827
 11828 				;	Exit.
 11829
 11830 EB26 60				RTS		;return
 11831 					;SPACE	4,10
 11832 				;	ITO - Indicate Timeout
 11833 				*
 11834 				*	ENTRY	JSR	ITO
 11835 				*
 11836 				*	MODS
 11837 				*		Original Author Unknown
 11838 				*		1. Bring closer to Coding Standard (object unchanged).
 11839 				*		   R. K. Nordin	11/01/83
 11840
 11841
 11842 = EB27			ITO	=	*	;entry
 11843 EB27 A9 8A			LDA	#TIMOUT	;timeout indicator
 11844 EB29 85 30			STA	STATUS	;indicate timeout
 11845 EB2B 60				RTS		;return
 11846 					;SPACE	4,10
 11847 				;	IRIR - Process Serial Input Ready IRQ
 11848 				*
 11849 				*	ENTRY	JMP	IRIR
 11850 				*
 11851 				*	EXIT
 11852 				*		Exits via RTI
 11853 				*
 11854 				*	MODS
 11855 				*		Original Author Unknown
 11856 				*		1. Bring closer to Coding Standard (object unchanged).
 11857 				*		   R. K. Nordin	11/01/83
 11858
 11859
 11860 = EB2C			IRIR	=	*	;entry
 11861
 11862 				;	Initialize.
 11863
 11864 EB2C 98				TYA
 11865 EB2D 48				PHA		;save Y
 11866 EB2E AD 0F D2			LDA	SKSTAT
 11867 EB31 8D 0A D2			STA	SKRES	;reset status register
 11868
 11869 				;	Check for frame error.
 11870
 11871 EB34 30 04			BMI	IRI1	;if no frame error
 11872
 11873 				;	Process frame error.
 11874
 11875 EB36 A0 8C			LDY	#FRMERR	;frame error
 11876 EB38 84 30			STY	STATUS	;indicate frame error
 11877
 11878 				;	Check for overrun error.
 11879
 11880 EB3A 29 20		IRI1	AND	#$20
 11881 EB3C D0 04			BNE	IRI2	;if no overrun error
 11882
 11883 				;	Process overrun error.
 11884
 11885 EB3E A0 8E			LDY	#OVRRUN	;overrun error
 11886 EB40 84 30			STY	STATUS	;indicate overrun error
 11887
 11888 				;	Check for buffer full.
 11889
 11890 EB42 A5 38		IRI2	LDA	BUFRFL
 11891 EB44 F0 13			BEQ	IRI5	;if buffer not yet full
 11892
 11893 				;	Process buffer full.
 11894
 11895 EB46 AD 0D D2			LDA	SERIN	;checksum from device
 11896 EB49 C5 31			CMP	CHKSUM	;computed checksum
 11897 EB4B F0 04			BEQ	IRI3	;if checksums match
 11898
 11899 				;	Process checksum error.
 11900
 11901 EB4D A0 8F			LDY	#CHKERR	;checksum error
 11902 EB4F 84 30			STY	STATUS	;indicate checksum error
 11903
 11904 				;	Indicate receive-frame done.
 11905
 11906 EB51 A9 FF		IRI3	LDA	#$FF	;receive-frame done indicator
 11907 EB53 85 39			STA	RECVDN	;indicate receive-frame done
 11908
 11909 				;	Exit.
 11910
 11911 EB55 68			IRI4	PLA
 11912 EB56 A8				TAY		;restore Y
 11913 EB57 68				PLA		;restore A
 11914 EB58 40				RTI		;return
 11915
 11916 				;	Process buffer not full.
 11917
 11918 EB59 AD 0D D2		IRI5	LDA	SERIN		;serial input register
 11919 EB5C A0 00			LDY	#0
 11920 EB5E 91 32			STA	(BUFRLO),Y	;byte of buffer
 11921 EB60 18				CLC
 11922 EB61 65 31			ADC	CHKSUM		;add byte to checksum
 11923 EB63 69 00			ADC	#0
 11924 EB65 85 31			STA	CHKSUM		;update checksum
 11925 EB67 E6 32			INC	BUFRLO		;increment low buffer pointer
 11926 EB69 D0 02			BNE	IRI6		;if low buffer pointer non-zero
 11927
 11928 EB6B E6 33			INC	BUFRHI		;increment high buffer pointer
 11929
 11930 				;	Check end of buffer.
 11931
 11932 EB6D A5 32		IRI6	LDA	BUFRLO		;buffer address
 11933 EB6F C5 34			CMP	BFENLO		;buffer end address
 11934 EB71 A5 33			LDA	BUFRHI
 11935 EB73 E5 35			SBC	BFENHI
 11936 EB75 90 DE			BCC	IRI4		;if not past end of buffer
 11937
 11938 				;	Process end of buffer.
 11939
 11940 EB77 A5 3C			LDA	NOCKSM		;no checksum follows flag
 11941 EB79 F0 06			BEQ	IRI7		;if checksum will follow
 11942
 11943 				;	Process no checksum will follow.
 11944
 11945 EB7B A9 00			LDA	#0
 11946 EB7D 85 3C			STA	NOCKSM		;clear no checksum follows flag
 11947 EB7F F0 D0			BEQ	IRI3		;indicate receive-frame done
 11948
 11949 				;	Process checksum will follow.
 11950
 11951 EB81 A9 FF		IRI7	LDA	#$FF
 11952 EB83 85 38			STA	BUFRFL		;indicate buffer full
 11953 EB85 D0 CE			BNE	IRI4		;exit
 11954 					;SPACE	4,10
 11955 				;	SBP - Set Buffer Pointers
 11956 				*
 11957 				*	ENTRY	JSR	SBP
 11958 				*
 11959 				*	MODS
 11960 				*		Original Author Unknown
 11961 				*		1. Bring closer to Coding Standard (object unchanged).
 11962 				*		   R. K. Nordin	11/01/83
 11963
 11964
 11965 = EB87			SBP	=	*	;entry
 11966 EB87 18				CLC
 11967 EB88 AD 04 03			LDA	DBUFLO
 11968 EB8B 85 32			STA	BUFRLO	;low buffer address
 11969 EB8D 6D 08 03			ADC	DBYTLO
 11970 EB90 85 34			STA	BFENLO	;low buffer end address
 11971 EB92 AD 05 03			LDA	DBUFHI
 11972 EB95 85 33			STA	BUFRHI	;high buffer address
 11973 EB97 6D 09 03			ADC	DBYTHI
 11974 EB9A 85 35			STA	BFENHI	;high buffer end address
 11975 EB9C 60				RTS		;return
 11976 				;	;SPACE	4,10
 11977 				;	PCI - Process Cassette I/O
 11978 				*
 11979 				*	ENTRY	JSR	PCI
 11980 				*
 11981 				*	MODS
 11982 				*		Original Author Unknown
 11983 				*		1. Bring closer to Coding Standard (object unchanged).
 11984 				*		   R. K. Nordin	11/01/83
 11985
 11986
 11987 = EB9D			PCI	=	*	;entry
 11988
 11989 				;	Check command type.
 11990
 11991 EB9D AD 03 03			LDA	DSTATS		;command type
 11992 EBA0 10 32			BPL	PCI3		;if READ
 11993
 11994 				;	Write a record.
 11995
 11996 EBA2 A9 CC			LDA	#<B00600
 11997 EBA4 8D 04 D2			STA	AUDF3		;set 600 baud
 11998 EBA7 A9 05			LDA	#>B00600
 11999 EBA9 8D 06 D2			STA	AUDF4
 12000 EBAC 20 17 EC			JSR	ESS		;enable SIO SEND
 12001 EBAF A6 62			LDX	PALNTS		;PAL/NTSC offset
 12002 EBB1 BC 15 EE			LDY	WSIRGX,X	;low short WRITE IRG time
 12003 EBB4 AD 0B 03			LDA	DAUX2		;IRG type
 12004 EBB7 30 03			BMI	PCI1		;if short IRG is desired
 12005
 12006 EBB9 BC 11 EE			LDY	WIRGLX,X	;low long WRITE IRG time
 12007
 12008 EBBC A2 00		PCI1	LDX	#WIRGHI		;high IRG time
 12009 EBBE 20 E2 ED			JSR	SSV		;set SIO VBLANK parameters
 12010 EBC1 A9 34			LDA	#MOTRGO
 12011 EBC3 8D 02 D3			STA	PACTL		;turn on motor
 12012
 12013 EBC6 AD 17 03		PCI2	LDA	TIMFLG		;timeout flag
 12014 EBC9 D0 FB			BNE	PCI2		;if no timeout
 12015
 12016 EBCB 20 87 EB			JSR	SBP		;set buffer pointers
 12017 EBCE 20 88 EA			JSR	SEN		;send
 12018 EBD1 4C 04 EC			JMP	PCI6		;exit
 12019
 12020 				;	Read a record.
 12021
 12022 EBD4 A9 FF		PCI3	LDA	#$FF		;cassette I/O indicator
 12023 EBD6 8D 0F 03			STA	CASFLG		;cassette I/O flag
 12024
 12025 EBD9 A6 62			LDX	PALNTS		;PAL/NTSC offset
 12026 EBDB BC 17 EE			LDY	RSIRGX,X	;low short READ IRG time
 12027 EBDE AD 0B 03			LDA	DAUX2		;IRG type
 12028 EBE1 30 03			BMI	PCI4		;if short IRG desired
 12029
 12030 EBE3 BC 13 EE			LDY	RIRGLX,X	;low long READ IRG time
 12031
 12032 EBE6 A2 00		PCI4	LDX	#RIRGHI		;high READ IRG time
 12033 EBE8 20 E2 ED			JSR	SSV		;set SIO VBLANK parameters
 12034 EBEB A9 34			LDA	#MOTRGO
 12035 EBED 8D 02 D3			STA	PACTL		;turn on motor
 12036
 12037 EBF0 AD 17 03		PCI5	LDA	TIMFLG		;timeout flag
 12038 EBF3 D0 FB			BNE	PCI5		;if no timeout
 12039
 12040 EBF5 20 87 EB			JSR	SBP		;set buffer pointers
 12041 EBF8 20 9A EC			JSR	GTO		;get device timeout
 12042 EBFB 20 E2 ED			JSR	SSV		;set SIO VBLANK parameters
 12043 EBFE 20 3D ED			JSR	SBR		;set initial baud rate
 12044 EC01 20 FD EA			JSR	REC		;receive
 12045
 12046 				;	Exit.
 12047
 12048 EC04 AD 0B 03		PCI6	LDA	DAUX2		;IRG type
 12049 EC07 30 05			BMI	PCI7		;if doing short IRG
 12050
 12051 EC09 A9 3C			LDA	#MOTRST
 12052 EC0B 8D 02 D3			STA	PACTL		;turn off motor
 12053
 12054 EC0E 4C 2A EA		PCI7	JMP	CSO		;complete SIO operation, return
 12055 					;SPACE	4,10
 12056 				;	PTE - Process Timer Expiration
 12057 				*
 12058 				*	ENTRY	JSR	PTE
 12059 				*
 12060 				*	MODS
 12061 				*		Original Author Unknown
 12062 				*		1. Bring closer to Coding Standard (object unchanged).
 12063 				*		   R. K. Nordin	11/01/83
 12064
 12065
 12066 = EC11			PTE	=	*	;entry
 12067 EC11 A9 00			LDA	#0	;timeout indicator
 12068 EC13 8D 17 03			STA	TIMFLG	;timeout flag
 12069 EC16 60				RTS		;return
 12070 					;SPACE	4,10
 12071 				;	ESS - Enable SIO SEND
 12072 				*
 12073 				*	ENTRY	JSR	ESS
 12074 				*
 12075 				*	MODS
 12076 				*		Original Author Unknown
 12077 				*		1. Bring closer to Coding Standard (object unchanged).
 12078 				*		   R. K. Nordin	11/01/83
 12079
 12080
 12081 = EC17			ESS	=	*	;entry
 12082
 12083 				;	Initialize.
 12084
 12085 EC17 A9 07			LDA	#$07	;mask off previous serail bus control bits
 12086 EC19 2D 32 02			AND	SSKCTL
 12087 EC1C 09 20			ORA	#$20	;set SEND mode
 12088
 12089 				;	Check device type.
 12090
 12091 EC1E AC 00 03			LDY	DDEVIC
 12092 EC21 C0 60			CPY	#CASET
 12093 EC23 D0 0C			BNE	ESS1	;if not cassette
 12094
 12095 				;	Process cassette.
 12096
 12097 EC25 09 08			ORA	#$08	;set FSK output
 12098 EC27 A0 07			LDY	#LOTONE	;set FSK tone frequencies
 12099 EC29 8C 02 D2			STY	AUDF2
 12100 EC2C A0 05			LDY	#HITONE
 12101 EC2E 8C 00 D2			STY	AUDF1
 12102
 12103 				;	Set serial bus control.
 12104
 12105 EC31 8D 32 02		ESS1	STA	SSKCTL	;SKCTL shadow
 12106 EC34 8D 0F D2			STA	SKCTL
 12107 EC37 A9 C7			LDA	#$C7	;mask off previous serial bus interrupt bits
 12108 EC39 25 10			AND	POKMSK	;and with POKEY IRQ enable
 12109 EC3B 09 10			ORA	#$10	;enable output data needed interrupt
 12110 EC3D 4C 56 EC			JMP	SSR	;set for SEND, return
 12111 					;SPACE	4,10
 12112 				;	ESR - Enable SIO RECEIVE
 12113 				*
 12114 				*	ENTRY	JSR	ESR
 12115 				*
 12116 				*	MODS
 12117 				*		Original Author Unknown
 12118 				*		1. Bring closer to Coding Standard (object unchanged).
 12119 				*		   R. K. Nordin	11/01/83
 12120
 12121
 12122 = EC40			ESR	=	*	;entry
 12123 EC40 A9 07			LDA	#$07	;mask off previous serial bus control bits
 12124 EC42 2D 32 02			AND	SSKCTL
 12125 EC45 09 10			ORA	#$10	;set receive mode asynchronous
 12126 EC47 8D 32 02			STA	SSKCTL	;SKCTL shadow
 12127 EC4A 8D 0F D2			STA	SKCTL
 12128 EC4D 8D 0A D2			STA	SKRES
 12129 EC50 A9 C7			LDA	#$C7	;mask off previous serial bus interrupt bits
 12130 EC52 25 10			AND	POKMSK	;and with POKEY IRQ enable
 12131 EC54 09 20			ORA	#$20	;enable RECEIVE interrupt
 12132 				;	JMP	SSR	;set for RECEIVE, return
 12133 					;SPACE	4,10
 12134 				;	SSR - Set for SEND or RECEIVE
 12135 				*
 12136 				*	ENTRY	JSR	SSR
 12137 				*
 12138 				*	MODS
 12139 				*		Original Author Unknown
 12140 				*		1. Bring closer to Coding Standard (object unchanged).
 12141 				*		   R. K. Nordin	11/01/83
 12142
 12143
 12144 = EC56			SSR	=	*	;entry
 12145
 12146 				;	Initialize.
 12147
 12148 EC56 85 10			STA	POKMSK	;update POKEY IRQ enable
 12149 EC58 8D 0E D2			STA	IRQEN	;IRQ enable
 12150 EC5B A9 28			LDA	#$28	;clock ch. 3 with 1.79 MHz, ch. 4 with ch. 3
 12151 EC5D 8D 08 D2			STA	AUDCTL	;set audio control
 12152
 12153 				;	Set voice controls.
 12154
 12155 EC60 A2 06			LDX	#6	;offset to last voice control
 12156 EC62 A9 A8			LDA	#$A8	;pure tone, half volume
 12157 EC64 A4 41			LDY	SOUNDR	;noisy I/O flag
 12158 EC66 D0 02			BNE	SSR1	;if noisy I/O desired
 12159
 12160 EC68 A9 A0			LDA	#$A0	;pure tone, no volume
 12161
 12162 EC6A 9D 01 D2		SSR1	STA	AUDC1,X	;set tone and volume
 12163 EC6D CA				DEX
 12164 EC6E CA				DEX
 12165 EC6F 10 F9			BPL	SSR1	;if not done
 12166
 12167 				;	Turn off certain voices.
 12168
 12169 EC71 A9 A0			LDA	#$A0	;pure tone, no volume
 12170 EC73 8D 05 D2			STA	AUDC3	;turn off sound on voice 3
 12171 EC76 AC 00 03			LDY	DDEVIC	;device bus ID
 12172 EC79 C0 60			CPY	#CASET	;cassette device ID
 12173 EC7B F0 06			BEQ	SSR2	;if cassette device
 12174
 12175 EC7D 8D 01 D2			STA	AUDC1	;turn off sound on voice 1
 12176 EC80 8D 03 D2			STA	AUDC2	;turn off sound on voice 2
 12177
 12178 EC83 60			SSR2	RTS		;return
 12179 					;SPACE	4,10
 12180 				;	DSR - Disable SEND and RECEIVE
 12181 				*
 12182 				*	ENTRY	JSR	DSR
 12183 				*
 12184 				*	NOTES
 12185 				*		Problem: NOP may not be necessary.
 12186 				*
 12187 				*	MODS
 12188 				*		Original Author Unknown
 12189 				*		1. Bring closer to Coding Standard (object unchanged).
 12190 				*		   R. K. Nordin	11/01/83
 12191
 12192
 12193 = EC84			DSR	=	*	;entry
 12194
 12195 				;	Disable serial bus interrupts.
 12196
 12197 EC84 EA				NOP
 12198 EC85 A9 C7			LDA	#$C7	;mask to clear serial bus interrupts
 12199 EC87 25 10			AND	POKMSK	;and with POKEY IRQ enable
 12200 EC89 85 10			STA	POKMSK	;update POKEY IRQ enable
 12201 EC8B 8D 0E D2			STA	IRQEN	;IRQ enable
 12202
 12203 				;	Turn off audio volume.
 12204
 12205 EC8E A2 06			LDX	#6	;offset to last voice control
 12206 EC90 A9 00			LDA	#$00	;no volume
 12207
 12208 EC92 9D 01 D2		DSR1	STA	AUDC1,X	;turn off voice
 12209 EC95 CA				DEX
 12210 EC96 CA				DEX
 12211 EC97 10 F9			BPL	DSR1	;if not done
 12212
 12213 EC99 60				RTS		;return
 12214 					;SPACE	4,10
 12215 				;	GTO - Get Device Timeout
 12216 				*
 12217 				*	ENTRY	JSR	GTO
 12218 				*
 12219 				*	MODS
 12220 				*		Original Author Unknown
 12221 				*		1. Bring closer to Coding Standard (object unchanged).
 12222 				*		   R. K. Nordin	11/01/83
 12223
 12224
 12225 = EC9A			GTO	=	*	;entry
 12226 EC9A AD 06 03			LDA	DTIMLO	;device timeout
 12227 EC9D 6A				ROR
 12228 EC9E 6A				ROR
 12229 EC9F A8				TAY		;rotated timeout
 12230 ECA0 29 3F			AND	#$3F	;lower 6 bits
 12231 ECA2 AA				TAX		;high timeout
 12232 ECA3 98				TYA		;rotated timeout
 12233 ECA4 6A				ROR
 12234 ECA5 29 C0			AND	#$C0	;upper 2 bits
 12235 ECA7 A8				TAY		;low timeout
 12236 ECA8 60				RTS		;return
 12237 					;SPACE	4,10
 12238 				;	TSIH - Table of SIO Interrupt Handlers
 12239 				*
 12240 				*	NOTES
 12241 				*		Problem: not used.
 12242
 12243
 12244 ECA9 2C EB		TSIH	.word	IRIR	;serial input ready IRQ
 12245 ECAB AD EA			.word	ORIR	;serial output ready IRQ
 12246 ECAD EC EA			.word	OCIR	;serial output complete IRQ
 12247 					;SPACE	4,10
 12248 				;	SID - Send to Intelligent Device
 12249 				*
 12250 				*	ENTRY	JSR	SID
 12251 				*
 12252 				*	NOTES
 12253 				*		Problem: bytes wasted by outer delay loop.
 12254 				*
 12255 				*	MODS
 12256 				*		Original Author Unknown
 12257 				*		1. Bring closer to Coding Standard (object unchanged).
 12258 				*		   R. K. Nordin	11/01/83
 12259
 12260
 12261 = ECAF			SID	=	*	;entry
 12262
 12263 				;	Delay.
 12264
 12265 ECAF A2 01			LDX	#1
 12266
 12267 ECB1 A0 FF		SID1	LDY	#255
 12268
 12269 ECB3 88			SID2	DEY
 12270 ECB4 D0 FD			BNE	SID2		;if inner loop not done
 12271
 12272 ECB6 CA				DEX
 12273 ECB7 D0 F8			BNE	SID1		;if outer loop not done
 12274
 12275 				;	Send data frame.
 12276
 12277 ECB9 20 88 EA			JSR	SEN		;send
 12278
 12279 				;	Set timer and wait.
 12280
 12281 ECBC A0 02			LDY	#<CTIM	;frame acknowledge timeout
 12282 ECBE A2 00			LDX	#>CTIM
 12283 				;	JMP	STW		;set timer and wait, return
 12284 					;SPACE	4,10
 12285 				;	STW - Set Timer and Wait
 12286 				*
 12287 				*	ENTRY	JSR	STW
 12288 				*
 12289 				*	MODS
 12290 				*		Original Author Unknown
 12291 				*		1. Bring closer to Coding Standard (object unchanged).
 12292 				*		   R. K. Nordin	11/01/83
 12293
 12294
 12295 = ECC0			STW	=	*	;entry
 12296 ECC0 20 E2 ED			JSR	SSV	;set SIO VBLANK parameters
 12297 ECC3 20 37 EA			JSR	WCA	;wait for completion or ACK
 12298 ECC6 98				TYA		;wait termination status
 12299 ECC7 60				RTS		;return
 12300 					;SPACE	4,10
 12301 				;	CBR - Compute Baud Rate
 12302 				*
 12303 				*	CBR computes value for POKEY frequency for the baud rate as
 12304 				*	measured by an interval of the VCOUNT timer.
 12305 				*
 12306 				*	ENTRY	JSR	CBR
 12307 				*
 12308 				*	MODS
 12309 				*		Original Author Unknown
 12310 				*		1. Bring closer to Coding Standard (object unchanged).
 12311 				*		   R. K. Nordin	11/01/83
 12312
 12313
 12314 = ECC8			CBR	=	*		;entry
 12315 ECC8 8D 10 03			STA	TIMER2		;save final timer value
 12316 ECCB 8C 11 03			STY	TIMER2+1
 12317 ECCE 20 2E ED			JSR	AVV		;adjust VCOUNT value
 12318 ECD1 8D 10 03			STA	TIMER2		;save adjusted timer 2 value
 12319 ECD4 AD 0C 03			LDA	TIMER1
 12320 ECD7 20 2E ED			JSR	AVV		;adjust VCOUNT value
 12321 ECDA 8D 0C 03			STA	TIMER1		;save adjusted timer 1 value
 12322 ECDD AD 10 03			LDA	TIMER2
 12323 ECE0 38				SEC
 12324 ECE1 ED 0C 03			SBC	TIMER1
 12325 ECE4 8D 12 03			STA	TEMP1		;save difference
 12326 ECE7 AD 11 03			LDA	TIMER2+1
 12327 ECEA 38				SEC
 12328 ECEB ED 0D 03			SBC	TIMER1+1
 12329 ECEE A8				TAY			;difference
 12330 ECEF A6 62			LDX	PALNTS
 12331 ECF1 A9 00			LDA	#0
 12332 ECF3 38				SEC
 12333 ECF4 FD 19 EE			SBC	CONS1X,X
 12334
 12335 ECF7 18			CBR1	CLC
 12336 ECF8 7D 19 EE			ADC	CONS1X,X	;accumulate product
 12337 ECFB 88				DEY
 12338 ECFC 10 F9			BPL	CBR1		;if not done
 12339
 12340 ECFE 18				CLC
 12341 ECFF 6D 12 03			ADC	TEMP1		;add to get total VCOUNT difference
 12342 ED02 A8				TAY			;total VCOUNT difference
 12343 ED03 4A				LSR
 12344 ED04 4A				LSR
 12345 ED05 4A				LSR
 12346 ED06 0A				ASL		;interval divided by 4
 12347 ED07 38				SEC
 12348 ED08 E9 16			SBC	#22		;adjust offset
 12349 ED0A AA				TAX			;offset
 12350 ED0B 98				TYA			;total VCOUNT difference
 12351 ED0C 29 07			AND	#7		;extract lower 3 bits of interval
 12352 ED0E A8				TAY			;lower 3 bits of interval
 12353 ED0F A9 F5			LDA	#-11
 12354
 12355 ED11 18			CBR2	CLC
 12356 ED12 69 0B			ADC	#11		;accumulate interpolation constant
 12357 ED14 88				DEY
 12358 ED15 10 FA			BPL	CBR2		;if done
 12359
 12360 ED17 A0 00			LDY	#0		;assume no addition correction
 12361 ED19 38				SEC
 12362 ED1A E9 07			SBC	#7		;adjust interpolation constant
 12363 ED1C 10 01			BPL	CBR3
 12364
 12365 ED1E 88				DEY			;indicate addition correction
 12366
 12367 ED1F 18			CBR3	CLC
 12368 ED20 7D F9 ED			ADC	TPFV,X		;add constant to table value
 12369 ED23 8D EE 02			STA	CBAUDL		;low POKEY frequency value
 12370 ED26 98				TYA
 12371 ED27 7D FA ED			ADC	TPFV+1,X
 12372 ED2A 8D EF 02			STA	CBAUDH		;high POKEY frequency value
 12373 ED2D 60				RTS			;return
 12374 					;SPACE	4,10
 12375 				;	AVV - Adjust VCOUNT Value
 12376 				*
 12377 				*	ENTRY	JSR	AVV
 12378 				*
 12379 				*	MODS
 12380 				*		Original Author Unknown
 12381 				*		1. Bring closer to Coding Standard (object unchanged).
 12382 				*		   R. K. Nordin	11/01/83
 12383
 12384
 12385 = ED2E			AVV	=	*	;entry
 12386 ED2E C9 7C			CMP	#$7C
 12387 ED30 30 04			BMI	AVV1	;if >= $7C
 12388
 12389 ED32 38				SEC
 12390 ED33 E9 7C			SBC	#$7C
 12391 ED35 60				RTS		;return
 12392
 12393 ED36 18			AVV1	CLC
 12394 ED37 A6 62			LDX	PALNTS
 12395 ED39 7D 1B EE			ADC	CONS2X,X
 12396 ED3C 60				RTS		;return
 12397 					;SPACE	4,10
 12398 				;	SBR - Set Initial Baud Rate
 12399 				*
 12400 				*	INITIAL BAUD RATE MEASUREMENT -- USED TO SET THE
 12401 				*	BAUD RATE AT THE START OF A RECORD.
 12402 				*
 12403 				*	IT IS ASSUMED THAT THE FIRST TWO BYTES OF EVERY
 12404 				*	RECORD ARE $AA.
 12405 				*
 12406 				*	ENTRY	JSR	SBR
 12407 				*
 12408 				*	NOTES
 12409 				*		Problem: bytes wasted by branch around branch (SBR3).
 12410 				*
 12411 				*	MODS
 12412 				*		Original Author Unknown
 12413 				*		1. Bring closer to Coding Standard (object unchanged).
 12414 				*		   R. K. Nordin	11/01/83
 12415
 12416
 12417 = ED3D			SBR	=	*		;entry
 12418
 12419 ED3D A5 11		SBR1	LDA	BRKKEY
 12420 ED3F D0 03			BNE	SBR2		;if BREAK key not pressed
 12421
 12422 ED41 4C C7 ED			JMP	PBK		;process BREAK key, return
 12423
 12424 ED44 78			SBR2	SEI
 12425 ED45 AD 17 03			LDA	TIMFLG		;timeout flag
 12426 ED48 D0 02			BNE	SBR3		;if no timeout
 12427
 12428 ED4A F0 25			BEQ	SBR5		;process timeout
 12429
 12430 ED4C AD 0F D2		SBR3	LDA	SKSTAT
 12431 ED4F 29 10			AND	#$10		;extract start bit
 12432 ED51 D0 EA			BNE	SBR1		;if start bit
 12433
 12434 ED53 8D 16 03			STA	SAVIO		;save serial data in
 12435 ED56 AE 0B D4			LDX	VCOUNT		;vertical line counter
 12436 ED59 A4 14			LDY	RTCLOK+2	;low byte of VBLANK clock
 12437 ED5B 8E 0C 03			STX	TIMER1
 12438 ED5E 8C 0D 03			STY	TIMER1+1	;save initial timer value
 12439 ED61 A2 01			LDX	#1
 12440 ED63 8E 15 03			STX	TEMP3		;set mode flag
 12441 ED66 A0 0A			LDY	#10		;10 bits
 12442
 12443 ED68 A5 11		SBR4	LDA	BRKKEY
 12444 ED6A F0 5B			BEQ	PBK		;if BREAK key pressed, process, return
 12445
 12446 ED6C AD 17 03			LDA	TIMFLG		;timeout flag
 12447 ED6F D0 04			BNE	SBR6		;if no timeout
 12448
 12449 ED71 58			SBR5	CLI
 12450 ED72 4C 27 EB			JMP	ITO		;indicate timeout, return
 12451
 12452 ED75 AD 0F D2		SBR6	LDA	SKSTAT
 12453 ED78 29 10			AND	#$10		;extract
 12454 ED7A CD 16 03			CMP	SAVIO		;previous serial data in
 12455 ED7D F0 E9			BEQ	SBR4		;if data in not changed
 12456
 12457 ED7F 8D 16 03			STA	SAVIO		;save serial data in
 12458 ED82 88				DEY			;decrement bit counter
 12459 ED83 D0 E3			BNE	SBR4		;if not done
 12460
 12461 ED85 CE 15 03			DEC	TEMP3		;decrement mode
 12462 ED88 30 0C			BMI	SBR7		;if done with both modes
 12463
 12464 ED8A AD 0B D4			LDA	VCOUNT
 12465 ED8D A4 14			LDY	RTCLOK+2
 12466 ED8F 20 C8 EC			JSR	CBR		;compute baud rate
 12467 ED92 A0 09			LDY	#9		;9 bits
 12468 ED94 D0 D2			BNE	SBR4		;set bit counter
 12469
 12470 ED96 AD EE 02		SBR7	LDA	CBAUDL
 12471 ED99 8D 04 D2			STA	AUDF3
 12472 ED9C AD EF 02			LDA	CBAUDH
 12473 ED9F 8D 06 D2			STA	AUDF4		;set POKEY baud rate
 12474 EDA2 A9 00			LDA	#0
 12475 EDA4 8D 0F D2			STA	SKSTAT
 12476 EDA7 AD 32 02			LDA	SSKCTL
 12477 EDAA 8D 0F D2			STA	SKSTAT		;initialize POKEY serial port
 12478 EDAD A9 55			LDA	#$55
 12479 EDAF 91 32			STA	(BUFRLO),Y	;first byte of buffer
 12480 EDB1 C8				INY
 12481 EDB2 91 32			STA	(BUFRLO),Y	;second byte of buffer
 12482 EDB4 A9 AA			LDA	#$AA		;checksum
 12483 EDB6 85 31			STA	CHKSUM		;checksum
 12484 EDB8 18				CLC
 12485 EDB9 A5 32			LDA	BUFRLO
 12486 EDBB 69 02			ADC	#2		;add 2
 12487 EDBD 85 32			STA	BUFRLO		;update low buffer pointer
 12488 EDBF A5 33			LDA	BUFRHI
 12489 EDC1 69 00			ADC	#0
 12490 EDC3 85 33			STA	BUFRHI		;update high buffer pointer
 12491 EDC5 58				CLI
 12492 EDC6 60				RTS			;return
 12493 					;SPACE	4,10
 12494 				;	PBK - Process BREAK Key
 12495 				*
 12496 				*	ENTRY	JSR	PBK
 12497 				*
 12498 				*	MODS
 12499 				*		Original Author Unknown
 12500 				*		1. Bring closer to Coding Standard (object unchanged).
 12501 				*		   R. K. Nordin	11/01/83
 12502
 12503
 12504 = EDC7			PBK	=	*	;entry
 12505 EDC7 20 84 EC			JSR	DSR	;disable SEND and RECEIVE
 12506 EDCA A9 3C			LDA	#MOTRST
 12507 EDCC 8D 02 D3			STA	PACTL	;turn off motor
 12508 EDCF A9 3C			LDA	#NCOMHI
 12509 EDD1 8D 03 D3			STA	PBCTL	;raise NOT COMMAND line
 12510 EDD4 A9 80			LDA	#BRKABT	;BREAK abort error
 12511 EDD6 85 30			STA	STATUS	;status
 12512 EDD8 AE 18 03			LDX	STACKP	;saved stack pointer
 12513 EDDB 9A				TXS		;restore stack pointer
 12514 EDDC C6 11			DEC	BRKKEY	;indicate BREAK
 12515 EDDE 58				CLI
 12516 EDDF 4C 2A EA			JMP	CSO	;complete SIO operation, return to caller of SIO
 12517 					;SPACE	4,10
 12518 				;	SSV - Set SIO VBLANK Parameters
 12519 				*
 12520 				*	ENTRY	JSR	SSV
 12521 				*
 12522 				*	MODS
 12523 				*		Original Author Unknown	??/??/??
 12524 				*		1. Bring closer to Coding Standard (object unchanged).
 12525 				*		   R. K. Nordin	11/01/83
 12526
 12527
 12528 = EDE2			SSV	=	*		;entry
 12529 EDE2 A9 11			LDA	#<PTE	;timer expiration routine address
 12530 EDE4 8D 26 02			STA	CDTMA1
 12531 EDE7 A9 EC			LDA	#>PTE
 12532 EDE9 8D 27 02			STA	CDTMA1+1
 12533 EDEC A9 01			LDA	#1		;timer 1
 12534 EDEE 78				SEI
 12535 EDEF 20 5C E4			JSR	SETVBV		;set VBLANK parameters
 12536 EDF2 A9 01			LDA	#1		;no timeout indicator
 12537 EDF4 8D 17 03			STA	TIMFLG		;timeout flag
 12538 EDF7 58				CLI
 12539 EDF8 60				RTS			;return
 12540 					;SPACE	4,10
 12541 				;	TPFV - Table of POKEY Frequency Values
 12542 				*
 12543 				*	TPFV translates VCOUNT interval timer measurements to POKEY
 12544 				*	frequency register values.
 12545 				*
 12546 				*	Table entries are AUDF+7.
 12547 				*
 12548 				*	Frequency-out is Frequency-in divided by 2*(AUDF+M), where
 12549 				*	Frequency-in = 1.78979 Mhz and M = 7.
 12550 				*
 12551 				*	AUDF+7=(11.365167)*T-out, where T-out is the number of counts
 12552 				*	(127 used cd soulution???) of VCOUNT for one character
 12553 				*	time (10 bit times).
 12554
 12555
 12556 				;	.word	636	;baud rate 1407, VCOUNT interval 56
 12557 				;	.word	727	;baud rate 1231, VCOUNT interval 64
 12558 				;	.word	818	;baud rate 1094, VCOUNT interval 72
 12559 				;	.word	909	;baud rate 985, VCOUNT interval 80
 12560
 12561 EDF9 E8 03		TPFV	.word	1000	;baud rate 895, VCOUNT interval 88
 12562 EDFB 43 04			.word	1091	;baud rate 820, VCOUNT interval 96
 12563 EDFD 9E 04			.word	1182	;baud rate 757, VCOUNT interval 104
 12564 EDFF F9 04			.word	1273	;baud rate 703, VCOUNT interval 112
 12565 EE01 54 05			.word	1364	;baud rate 656, VCOUNT interval 120
 12566 EE03 AF 05			.word	1455	;baud rate 615, VCOUNT interval 128
 12567 EE05 0A 06			.word	1546	;baud rate 579, VCOUNT interval 136
 12568 EE07 65 06			.word	1637	;baud rate 547, VCOUNT interval 144
 12569 EE09 C0 06			.word	1728	;baud rate 518, VCOUNT interval 152
 12570 EE0B 1A 07			.word	1818	;baud rate 492, VCOUNT interval 160
 12571 EE0D 75 07			.word	1909	;baud rate 469, VCOUNT interval 168
 12572 EE0F D0 07			.word	2000	;baud rate 447, VCOUNT interval 176
 12573
 12574 				;	.word	2091	;baud rate 428, VCOUNT interval 184
 12575 				;	.word	2182	;baud rate 410, VCOUNT interval 192
 12576 				;	.word	2273	;baud rate 394, VCOUNT interval 200
 12577 				;	.word	2364	;baud rate 379, VCOUNT interval 208
 12578 				;	.word	2455	;baud rate 365, VCOUNT interval 216
 12579 				;	.word	2546	;baud rate 352, VCOUNT interval 224
 12580 				;	.word	2637	;baud rate 339, VCOUNT interval 232
 12581 				;	.word	2728	;baud rate 328, VCOUNT interval 240
 12582 				;	.word	2819	;baud rate 318, VCOUNT interval 248
 12583 					;SPACE	4,10
 12584 				;	NTSC/PAL Constant Tables
 12585
 12586
 12587 EE11 B4			WIRGLX	.byte	.lo(WIRGLN)	;NTSC .lo(long write IRG
 12588 EE12 96				.byte	.lo(WIRGLP)	;PAL .lo(long write IRG
 12589
 12590 EE13 78			RIRGLX	.byte	.lo(RIRGLN)	;NTSC .lo(long read IRG
 12591 EE14 64				.byte	.lo(RIRGLP)	;PAL .lo(long read IRG
 12592
 12593 EE15 0F			WSIRGX	.byte	.lo(WSIRGN)	;NTSC .lo(short write IRG
 12594 EE16 0D				.byte	.lo(WSIRGP)	;PAL .lo(short write IRG
 12595
 12596 EE17 0A			RSIRGX	.byte	.lo(RSIRGN)	;NTSC .lo(short read IRG
 12597 EE18 08				.byte	.lo(RSIRGP)	;PAL .lo(short read IRG
 12598
 12599 EE19 83			CONS1X	.byte	131		;NTSC
 12600 EE1A 9C				.byte	156		;PAL
 12601
 12602 EE1B 07			CONS2X	.byte	7		;NTSC
 12603 EE1C 20				.byte	32		;PAL
 12604 				;	;SUBTTL	'Keyboard, Editor and Screen Handler, Part 1'
 12605 					;SPACE	4,10
 12606 				;	TSMA - Table of Screen Memory Allocation
 12607 				*
 12608 				*	Entry n is the number of $40-byte blocks to allocate for
 12609 				*	graphics mode n.
 12610 				*
 12611 				*	NOTES
 12612 				*		Problem: For readability, this, and other t:
 12613 				*		this area, could be moved closer to the oth:
 12614 				*		the Keyboard, Editor and Screen Handler (ju:
 12615 				*		the EF6B patch).
 12616
 12617
 12618 EE1D 18			TSMA	.byte	24	;0
 12619 EE1E 10				.byte	16	;1
 12620 EE1F 0A				.byte	10	;2
 12621 EE20 0A				.byte	10	;3
 12622 EE21 10				.byte	16	;4
 12623 EE22 1C				.byte	28	;5
 12624 EE23 34				.byte	52	;6
 12625 EE24 64				.byte	100	;7
 12626 EE25 C4				.byte	196	;8
 12627 EE26 C4				.byte	196	;9
 12628 EE27 C4				.byte	196	;10
 12629 EE28 C4				.byte	196	;11
 12630 EE29 1C				.byte	28	;12
 12631 EE2A 10				.byte	16	;13
 12632 EE2B 64				.byte	100	;14
 12633 EE2C C4				.byte	196	;15
 12634 					;SPACE	4,10
 12635 				;	TDLE - Table of Display List Entry Counts
 12636 				*
 12637 				*	Each entry is 2 bytes.
 12638
 12639
 12640 EE2D 17 17		TDLE	.byte	23,23	;0
 12641 EE2F 0B 17			.byte	11,23	;1
 12642 EE31 2F 2F			.byte	47,47	;2
 12643 EE33 5F 5F			.byte	95,95	;3
 12644 EE35 61 61			.byte	97,97	;4
 12645 EE37 61 61			.byte	97,97	;5
 12646 EE39 17 0B			.byte	23,11	;6
 12647 EE3B BF 61			.byte	191,97	;7
 12648 EE3D 13 13			.byte	19,19	;8
 12649 EE3F 09 13			.byte	9,19	;9
 12650 EE41 27 27			.byte	39,39	;10
 12651 EE43 4F 4F			.byte	79,79	;11
 12652 EE45 41 41			.byte	65,65	;12
 12653 EE47 41 41			.byte	65,65	;13
 12654 EE49 13 09			.byte	19,9	;14
 12655 EE4B 9F 41			.byte	159,65	;15
 12656 					;SPACE	4,10
 12657 				;	TAGM - Table of ANTIC Graphics Modes
 12658 				*
 12659 				*	Entry n is the ANTIC graphics mode corresponding to internal
 12660 				*	graphics mode n.
 12661
 12662
 12663 EE4D 02			TAGM	.byte	$02	;internal 0 - 40x2x8 characters
 12664 EE4E 06				.byte	$06	;internal 1 - 20x5x8 characters
 12665 EE4F 07				.byte	$07	;internal 2 - 20x5x16 characters
 12666 EE50 08				.byte	$08	;internal 3 - 40x4x8 graphics
 12667 EE51 09				.byte	$09	;internal 4 - 80x2x4 graphics
 12668 EE52 0A				.byte	$0A	;internal 5 - 80x4x4 graphics
 12669 EE53 0B				.byte	$0B	;internal 6 - 160x2x2 graphics
 12670 EE54 0D				.byte	$0D	;internal 7 - 160x4x2 graphics
 12671 EE55 0F				.byte	$0F	;internal 8 - 320x2x1 graphics
 12672 EE56 0F				.byte	$0F	;internal 9 - 320x2x1 GTIA "lum" mode
 12673 EE57 0F				.byte	$0F	;internal 10 - 320x2x1 GTIA "color/lum" mode
 12674 EE58 0F				.byte	$0F	;internal 11 - 320x2x1 GTIA "color" mode
 12675 EE59 04				.byte	$04	;internal 12 - 40x5x8 characters
 12676 EE5A 05				.byte	$05	;internal 13 - 40x5x16 characters
 12677 EE5B 0C				.byte	$0C	;internal 14 - 160x2x1 graphics
 12678 EE5C 0E				.byte	$0E	;internal 15 - 160x4x1 graphics
 12679 					;SPACE	4,10
 12680 				;	TDLV - Table of Display List Vulnerability
 12681 				*
 12682 				*	Entry n is non-zero if the display list for mode n cannot
 12683 				*	cross a page boundary.
 12684
 12685
 12686 EE5D 00			TDLV	.byte	0	;0
 12687 EE5E 00				.byte	0	;1
 12688 EE5F 00				.byte	0	;2
 12689 EE60 00				.byte	0	;3
 12690 EE61 00				.byte	0	;4
 12691 EE62 00				.byte	0	;5
 12692 EE63 00				.byte	0	;6
 12693 EE64 01				.byte	1	;7
 12694 EE65 01				.byte	1	;8
 12695 EE66 01				.byte	1	;9
 12696 EE67 01				.byte	1	;10
 12697 EE68 01				.byte	1	;11
 12698 EE69 00				.byte	0	;12
 12699 EE6A 00				.byte	0	;13
 12700 EE6B 01				.byte	1	;14
 12701 EE6C 01				.byte	1	;15
 12702 					;SPACE	4,10
 12703 				;	TLSC - Table of Left Shift Counts
 12704 				*
 12705 				*	Entry n is the NUMBER OF LEFT SHIFTS NEEDED TO MULTIPLY
 12706 				*	COLCRS BY # BYTES/ROW ((ROWCRS*5)/(2;TLSC)) for mode n.
 12707
 12708
 12709 EE6D 03			TLSC	.byte	3	;0
 12710 EE6E 02				.byte	2	;1
 12711 EE6F 02				.byte	2	;2
 12712 EE70 01				.byte	1	;3
 12713 EE71 01				.byte	1	;4
 12714 EE72 02				.byte	2	;5
 12715 EE73 02				.byte	2	;6
 12716 EE74 03				.byte	3	;7
 12717 EE75 03				.byte	3	;8
 12718 EE76 03				.byte	3	;9
 12719 EE77 03				.byte	3	;10
 12720 EE78 03				.byte	3	;11
 12721 EE79 03				.byte	3	;12
 12722 EE7A 03				.byte	3	;13
 12723 EE7B 02				.byte	2	;14
 12724 EE7C 03				.byte	3	;15
 12725 					;SPACE	4,10
 12726 				;	TMCC - Table of Mode Column Counts
 12727 				*
 12728 				*	Entry n is the low column count for mode n.
 12729
 12730
 12731 EE7D 28			TMCC	.byte	.lo (40)		;0
 12732 EE7E 14				.byte	.lo (20)		;1
 12733 EE7F 14				.byte	.lo (20)		;2
 12734 EE80 28				.byte	.lo (40)		;3
 12735 EE81 50				.byte	.lo (80)		;4
 12736 EE82 50				.byte	.lo (80)		;5
 12737 EE83 A0				.byte	.lo (160)		;6
 12738 EE84 A0				.byte	.lo (160)		;7
 12739 EE85 40				.byte	.lo (320)		;8
 12740 EE86 50				.byte	.lo (80)		;9
 12741 EE87 50				.byte	.lo (80)		;10
 12742 EE88 50				.byte	.lo (80)		;11
 12743 EE89 28				.byte	.lo (40)		;12
 12744 EE8A 28				.byte	.lo (40)		;13
 12745 EE8B A0				.byte	.lo (160)		;14
 12746 EE8C A0				.byte	.lo (160)		;15
 12747 					;SPACE	4,10
 12748 				;	TMRC - Table of Mode Row Counts
 12749 				*
 12750 				*	Entry n is the row count for mode n.
 12751
 12752
 12753 EE8D 18			TMRC	.byte	24	;0
 12754 EE8E 18				.byte	24	;1
 12755 EE8F 0C				.byte	12	;2
 12756 EE90 18				.byte	24	;3
 12757 EE91 30				.byte	48	;4
 12758 EE92 30				.byte	48	;5
 12759 EE93 60				.byte	96	;6
 12760 EE94 60				.byte	96	;7
 12761 EE95 C0				.byte	192	;8
 12762 EE96 C0				.byte	192	;9
 12763 EE97 C0				.byte	192	;10
 12764 EE98 C0				.byte	192	;11
 12765 EE99 18				.byte	24	;12
 12766 EE9A 0C				.byte	12	;13
 12767 EE9B C0				.byte	192	;14
 12768 EE9C C0				.byte	192	;15
 12769 					;SPACE	4,10
 12770 				;	TRSC - Table of Right Shift Counts
 12771 				*
 12772 				*	Entry n is HOW MANY RIGHT SHIFTS FOR HCRSR FOR PARTIAL
 12773 				*	BYTE MODES for mode n.
 12774
 12775
 12776 EE9D 00			TRSC	.byte	0	;0
 12777 EE9E 00				.byte	0	;1
 12778 EE9F 00				.byte	0	;2
 12779 EEA0 02				.byte	2	;3
 12780 EEA1 03				.byte	3	;4
 12781 EEA2 02				.byte	2	;5
 12782 EEA3 03				.byte	3	;6
 12783 EEA4 02				.byte	2	;7
 12784 EEA5 03				.byte	3	;8
 12785 EEA6 01				.byte	1	;9
 12786 EEA7 01				.byte	1	;10
 12787 EEA8 01				.byte	1	;11
 12788 EEA9 00				.byte	0	;12
 12789 EEAA 00				.byte	0	;13
 12790 EEAB 03				.byte	3	;14
 12791 EEAC 02				.byte	2	;15
 12792 					;SPACE	4,10
 12793 				;	TDSM - Table of Display Masks
 12794 				*
 12795 				*	NOTES
 12796 				*		Includes TBTM - Table of Bit Masks.
 12797
 12798
 12799 EEAD FF			TDSM	.byte	$FF	;1
 12800 EEAE F0				.byte	$F0	;2
 12801 EEAF 0F				.byte	$0F	;3
 12802 EEB0 C0				.byte	$C0	;4
 12803 EEB1 30				.byte	$30	;5
 12804 EEB2 0C				.byte	$0C	;6
 12805 EEB3 03				.byte	$03	;7
 12806
 12807 EEB4 80			TBTM	.byte	$80	;8 (0)
 12808 EEB5 40				.byte	$40	;9 (1)
 12809 EEB6 20				.byte	$20	;10 (2)
 12810 EEB7 10				.byte	$10	;11 (3)
 12811 EEB8 08				.byte	$08	;12 (4)
 12812 EEB9 04				.byte	$04	;13 (5)
 12813 EEBA 02				.byte	$02	;14 (6)
 12814 EEBB 01				.byte	$01	;15 (7)
 12815 				;	;SUBTTL	'Peripheral Handler Loading Facility, Part 5'
 12816 					;SPACE	4,10
 12817 				;	PHE - Perform Peripheral Handler Entry
 12818 				*
 12819 				*	PHE attempts to enter a peripheral handler in the handler table.
 12820 				*
 12821 				*	ENTRY	JSR	PHE
 12822 				*		X = device code
 12823 				*		A = high linkage table address
 12824 				*		Y = low linkage table address
 12825 				*
 12826 				*	EXIT
 12827 				*		Success:
 12828 				*		C clear
 12829 				*		Handler table entry made
 12830 				*
 12831 				*		Failure due to entry previously made:
 12832 				*		C set
 12833 				*		N clear
 12834 				*		X = offset to second byte of duplicate entry
 12835 				*		A, Y unchanged
 12836 				*
 12837 				*		Failure due to handler table full:
 12838 				*		C set
 12839 				*		N set
 12840 				*
 12841 				*	CHANGES
 12842 				*		A X Y
 12843 				*
 12844 				*	CALLS
 12845 				*		-none-
 12846 				*
 12847 				*	MODS
 12848 				*		R. S. Scheiman	04/01/82
 12849 				*		1. Bring closer to Coding Standard (object unchanged).
 12850 				*		   R. K. Nordin	11/01/83
 12851
 12852
 12853 = EEBC			PHE	=	*	;entry
 12854
 12855 				;	Initialize.
 12856
 12857 EEBC 48				PHA		;save high linkage table address
 12858 EEBD 98				TYA
 12859 EEBE 48				PHA		;save low linkage table address
 12860
 12861 				;	Search for device code in handler table.
 12862
 12863 EEBF 8A				TXA			;device code
 12864 EEC0 A2 00			LDX	#0		;offset to first entry of table
 12865
 12866 EEC2 DD 1A 03		PHE1	CMP	HATABS,X	;device code from table
 12867 EEC5 F0 1E			BEQ	PHE3		;if device code found
 12868
 12869 EEC7 E8				INX
 12870 EEC8 E8				INX
 12871 EEC9 E8				INX
 12872 EECA E0 22			CPX	#MAXDEV+1	;offset+1 of last possible entry
 12873 EECC 30 F4			BMI	PHE1		;if not done
 12874
 12875 				;	Search for empty entry in handler table.
 12876
 12877 EECE A2 00			LDX	#0		;offset to first entry of table
 12878 EED0 A8				TAY			;save device code
 12879 EED1 A9 00			LDA	#0
 12880
 12881 EED3 DD 1A 03		PHE2	CMP	HATABS,X	;device code from table
 12882 EED6 F0 13			BEQ	PHE4		;if empty entry found
 12883
 12884 EED8 E8				INX
 12885 EED9 E8				INX
 12886 EEDA E8				INX
 12887 EEDB E0 22			CPX	#MAXDEV+1	;offset+1 of last possible entry
 12888 EEDD 30 F4			BMI	PHE2		;if not done
 12889
 12890 				;	Return table full condition.
 12891
 12892 EEDF 68				PLA		;clean stack
 12893 EEE0 68				PLA
 12894 EEE1 A0 FF			LDY	#$FF	;indicate table full (set N)
 12895 EEE3 38				SEC		;indicate failure
 12896 EEE4 60				RTS		;return
 12897
 12898 				;	Return device code found condition.
 12899
 12900 EEE5 68			PHE3	PLA		;saved Y
 12901 EEE6 A8				TAY		;restore Y
 12902 EEE7 68				PLA		;restore A
 12903 EEE8 E8				INX		;indicate device code found (clear N)
 12904 EEE9 38				SEC		;indicate failure
 12905 EEEA 60				RTS		;return
 12906
 12907 				;	Enter handler in table.
 12908
 12909 EEEB 98			PHE4	TYA			;device code
 12910 EEEC 9D 1A 03			STA	HATABS,X	;enter device code
 12911 EEEF 68				PLA			;saved low linkage table address
 12912 EEF0 9D 1B 03			STA	HATABS+1,X	;low address
 12913 EEF3 68				PLA			;saved high linkage table address
 12914 EEF4 9D 1C 03			STA	HATABS+2,X	;high address
 12915
 12916 				;	Return success condition.
 12917
 12918 EEF7 18				CLC		;indicate success
 12919 EEF8 60				RTS		;return
 12920 					;SPACE	4,10
 12921 				;	PHO - Perform Peripheral Handler Poll at OPEN
 12922 				*
 12923 				*	Subroutine to perform Type 4 Poll at OPEN time, and
 12924 				*	"provisionally" open IOCB if peripheral answers.
 12925 				*
 12926 				*	Input parameters:
 12927 				*	ICIDNO identifies calling IOCB;
 12928 				*	From zero-page IOCB:
 12929 				*		ICBALZ,ICBAHZ (buffer pointer)
 12930 				*		ICDNOZ (device number from caller's filespe:
 12931 				*	From caller's buffer: device name (in filespec.)
 12932 				*
 12933 				*	Output parameters:
 12934 				*	"No device" error returned if Poll not answered.
 12935 				*	If poll is answered, the calling IOCB is "Provision:
 12936 				*		opened (and successful status is returned)-:
 12937 				*		ICHIDZ set to mark provisional open
 12938 				*		ICPTLZ,ICPTHZ points to PTL (special PUT-BY:
 12939 				*		ICSPR in calling IOCB set to device name (f:
 12940 				*		ICSPR+1 in calling IOCB set to device seria:
 12941 				*
 12942 				*	Modified:
 12943 				*	Registers not saved.
 12944 				*
 12945 				*	Subroutines called:
 12946 				*	PHP performs poll.
 12947 				*
 12948 				*	ENTRY	JSR	PHO
 12949 				*
 12950 				*	NOTES
 12951 				*		Problem: in the CRASS65 version, ICIDNO was:
 12952 				*		zero-page.
 12953 				*
 12954 				*	MODS
 12955 				*		R. S. Scheiman	04/01/82
 12956 				*		1. Bring closer to Coding Standard (object unchanged).
 12957 				*		   R. K. Nordin	11/01/83
 12958
 12959
 12960 = EEF9			PHO	=	*		;entry
 12961 EEF9 A0 00			LDY	#0		;Call for Type 4 Poll with
 12962 EEFB B1 24			LDA	(ICBALZ),Y	;device name from user
 12963 EEFD A4 21			LDY	ICDNOZ		;OPEN
 12964 EEFF 20 BE E7			JSR	PHP
 12965 EF02 10 03			BPL	PHO1		;if poll answered
 12966
 12967 EF04 A0 82			LDY	#NONDEV		;Return "no device" error
 12968 EF06 60				RTS			;return
 12969
 12970 EF07 A9 7F		PHO1	LDA	#$7F		;"Provisionally" OPEN the I:
 12971 EF09 85 20			STA	ICHIDZ		;(Mark "provisional")
 12972 EF0B A9 25			LDA	#<[PTL-1]
 12973 EF0D 85 26			STA	ICPTLZ		;(Special put byte routine :
 12974 EF0F A9 EF			LDA	#>[PTL-1]
 12975 EF11 85 27			STA	ICPTHZ
 12976 EF13 AD EC 02			LDA	DVSTAT+2	;(Peripheral address for lo:
 12977 EF16 AE 2E 00			LDX.w	ICIDNO
 12978 				;!!!	VFD	8\$AE,8\low ICIDNO,8\high ICIDNO
 12979 EF19 9D 4D 03			STA	ICSPR+1,X
 12980 EF1C A0 00			LDY	#0
 12981 EF1E B1 24			LDA	(ICBALZ),Y	;(Device name from user)
 12982 EF20 9D 4C 03			STA	ICSPR,X
 12983 EF23 A0 01			LDY	#SUCCES		;indicate success
 12984 EF25 60				RTS			;return
 12985 					;SPACE	4,10
 12986 				;	PTL - Perform PUT-BYTE for Provisionally Open IOCB
 12987 				*
 12988 				*	Put byte entry for provisionally opened IOCB's.
 12989 				*	This routine performs load, relocation, initializat:
 12990 				*	and finishes OPEN, then calls handler's put byte en:
 12991 				*
 12992 				*	Input parameters:
 12993 				*	A	Byte to output;
 12994 				*	X	IOCB index (IOCB number times 16);
 12995 				*	Y	"Function not supported" error code $92.
 12996 				*	AUX1 and AUX2 in zero-page IOCB are copied from the:
 12997 				*		IOCB prior to the call to PTL.
 12998 				*
 12999 				*	Output parameters:
 13000 				*	Various errors may be returned if loading fails (ei:
 13001 				*		did not allow loading by setting HNDLOD fla:
 13002 				*		was a loading error or calling error);
 13003 				*	If no loading error, this routine returns nothing--:
 13004 				*		returned is returned by the loaded PUT-BYTE:
 13005 				*		is called by this routine after the handler:
 13006 				*		initialized, and opened.
 13007 				*
 13008 				*	Modified:
 13009 				*	ICIDNO (a CIO variable);
 13010 				*	all of the zero-page IOCB is copied fromt he callin:
 13011 				*	normal CIO open-operation variables are affected;
 13012 				*	after opening, the zero-page IOCB is copied to the :
 13013 				*	Registers not saved if error return;if handler is l:
 13014 				*		and opened properly, the caller's A and X r:
 13015 				*		passed to the loaded handler's PUT-BYTE rou:
 13016 				*		Y is passed to that routine as $92)--then r:
 13017 				*		on return is up to handler PUT-BYTE since i:
 13018 				*		directly to caller.
 13019 				*
 13020 				*	Subroutines called:
 13021 				*	PHL (does loading, initializing and opening--calls :
 13022 				*	loaded handler's INIT, OPEN, and PUT-BYTE entries a:
 13023 				*	The PUT-BYTE entry returns directly to the PTL call:
 13024 				*
 13025 				*	ENTRY	JSR	PTL
 13026 				*
 13027 				*	NOTES
 13028 				*		Problem: in the CRASS65 version, ICIDNO was:
 13029 				*		zero-page.
 13030 				*
 13031 				*	MODS
 13032 				*		R. S. Scheiman	04/01/82
 13033 				*		1. Bring closer to Coding Standard (object unchanged).
 13034 				*		   R. K. Nordin	11/01/83
 13035
 13036
 13037 = EF26			PTL	=	*	;entry
 13038 EF26 48				PHA		;save byte to output
 13039 EF27 8A				TXA		;IOCB index
 13040 EF28 48				PHA		;save IOCB index
 13041 EF29 29 0F			AND	#$0F	;IOCB index modulo 16
 13042 EF2B D0 10			BNE	PTL2	;if IOCB not dividable by 16, error
 13043
 13044 EF2D E0 80			CPX	#MAXIOC
 13045 EF2F 10 0C			BPL	PTL2	;if IOCB index invalid
 13046
 13047 EF31 AD E9 02			LDA	HNDLOD
 13048 EF34 D0 0B			BNE	PTL3	;if user wants loading
 13049
 13050 EF36 A0 82			LDY	#NONDEV	;indicate nonexistent device error
 13051
 13052 				;	Return error.
 13053
 13054 EF38 68			PTL1	PLA		;clean stack
 13055 EF39 68				PLA
 13056 EF3A C0 00			CPY	#0	;indicate failure (set N)
 13057 EF3C 60				RTS		;return
 13058
 13059 EF3D A0 86		PTL2	LDY	#BADIOC	;indicate bad IOCB number error
 13060 EF3F 30 F7			BMI	PTL1	;return error
 13061
 13062 				;	Simulate beginning of CIO, since CIO bypassed.
 13063
 13064 EF41			PTL3
 13065 EF41 8E 2E 00			STX.w	ICIDNO	;IOCB index
 13066 				;!!!	VFD	8\$8E,8\low ICIDNO,8\high ICIDNO
 13067 EF44 A0 00			LDY	#0	;offset to first byte of page zero :
 13068
 13069 				;	Copy IOCB to page zero IOCB.
 13070
 13071 EF46 BD 40 03		PTL4	LDA	IOCB,X	;byte of IOCB
 13072 EF49 99 20 00			STA	ZIOCB,Y	;byte of page zero IOCB
 13073 EF4C E8				INX
 13074 EF4D C8				INY
 13075 EF4E C0 0C			CPY	#12
 13076 EF50 30 F4			BMI	PTL4	;if not done
 13077
 13078 EF52 20 29 CA			JSR	PHL	;load and initialize peripheral han:
 13079 EF55 30 E1			BMI	PTL1	;if error
 13080
 13081 EF57 68				PLA		;Re-do the put byte call,
 13082 EF58 AA				TAX		;this time calling real handler
 13083 EF59 68				PLA
 13084 EF5A A8				TAY
 13085 EF5B A5 27			LDA	ICPTHZ
 13086 EF5D 48				PHA		;(Put byte entry address minus one)
 13087 EF5E A5 26			LDA	ICPTLZ
 13088 EF60 48				PHA
 13089 EF61 98				TYA
 13090 EF62 A0 92			LDY	#FNCNOT
 13091 EF64 60				RTS		;invoke handler (address on stack)
 13092 				;	;SUBTTL	'$EF6B Patch'
 13093 					;SPACE	4,10
 13094 EF65				ORG	$EF6B
 13095 					;SPACE	4,10
 13096 				;	EF6B - $EF6B Patch
 13097 				*
 13098 				*	For compatibility with OS Revision B, initiate cass:
 13099
 13100
 13101 EF6B 4C 05 FD			JMP	ICR	;initiate cassette READ, return
 13102 				;	;SUBTTL	'Keyboard, Editor and Screen Handler, Part 2'
 13103 					;SPACE	4,10
 13104 				;	SIN - Initialize Screen
 13105 				*
 13106 				*	ENTRY	JSR	SIN
 13107 				*
 13108 				*	MODS
 13109 				*		Original Author Unknown
 13110 				*		1. Bring closer to Coding Standard (object unchanged).
 13111 				*		   R. K. Nordin	11/01/83
 13112
 13113
 13114 = EF6E			SIN	=	*		;entry
 13115
 13116 EF6E A9 FF			LDA	#$FF		;clear code indicator
 13117 EF70 8D FC 02			STA	CH		;key code
 13118
 13119 EF73 AD E4 02			LDA	RAMSIZ		;size of RAM
 13120 EF76 85 6A			STA	RAMTOP		;RAM size
 13121
 13122 EF78 A9 40			LDA	#$40		;CAPS lock indicator
 13123 EF7A 8D BE 02			STA	SHFLOK		;shift/control lock flags
 13124
 13125 EF7D A9 51			LDA	#<TCKD	;table of character key def:
 13126 EF7F 85 79			STA	KEYDEF		;key definition table addre:
 13127 EF81 A9 FB			LDA	#>TCKD
 13128 EF83 85 7A			STA	KEYDEF+1
 13129
 13130 EF85 A9 11			LDA	#<TFKD	;table of function key defi:
 13131 EF87 85 60			STA	FKDEF		;function key definition ta:
 13132 EF89 A9 FC			LDA	#>TFKD
 13133 EF8B 85 61			STA	FKDEF+1
 13134
 13135 EF8D 60				RTS			;return
 13136 					;SPACE	4,10
 13137 				;	SOP - Perform Screen OPEN
 13138 				*
 13139 				*	ENTRY	JSR	SOP
 13140 				*
 13141 				*	MODS
 13142 				*		Original Author Unknown
 13143 				*		1. Bring closer to Coding Standard (object unchanged).
 13144 				*		   R. K. Nordin	11/01/83
 13145
 13146
 13147 = EF8E			SOP	=	*	;entry
 13148
 13149 				;	Check mode.
 13150
 13151 EF8E A5 2B			LDA	ICAX2Z
 13152 EF90 29 0F			AND	#$0F
 13153 EF92 D0 08			BNE	COC	;if not mode 0, complete OPEN comma:
 13154
 13155 				;	Process mode 0.
 13156
 13157 				;	JMP	EOP	;perform editor OPEN, return
 13158 					;SPACE	4,10
 13159 				;	EOP - Perform Editor OPEN
 13160 				*
 13161 				*	ENTRY	JSR	EOP
 13162 				*
 13163 				*	MODS
 13164 				*		Original Author Unknown
 13165 				*		1. Bring closer to Coding Standard (object unchanged).
 13166 				*		   R. K. Nordin	11/01/83
 13167
 13168
 13169 = EF94			EOP	=	*	;entry
 13170 EF94 A5 2A			LDA	ICAX1Z
 13171 EF96 29 0F			AND	#$0F
 13172 EF98 85 2A			STA	ICAX1Z
 13173 EF9A A9 00			LDA	#0
 13174 				;	JMP	COC	;complete OPEN command, return
 13175 					;SPACE	4,10
 13176 				;	COC - Complete OPEN Command
 13177 				*
 13178 				*	ENTRY	JSR	COC
 13179 				*		A = mode
 13180 				*
 13181 				*	MODS
 13182 				*		Original Author Unknown
 13183 				*		1. Bring closer to Coding Standard (object unchanged).
 13184 				*		   R. K. Nordin	11/01/83
 13185
 13186
 13187 = EF9C			COC	=	*	;entry
 13188
 13189 				;	Check mode.
 13190
 13191 EF9C 85 57			STA	DINDEX	;save mode
 13192 EF9E C9 10			CMP	#16
 13193 EFA0 90 05			BCC	COC1	;if mode within range
 13194
 13195 				;	Process invalid mode
 13196
 13197 EFA2 A9 91			LDA	#BADMOD
 13198 EFA4 4C 54 F1			JMP	COC17
 13199
 13200 				;	Initialize for OPEN.
 13201
 13202 EFA7 A9 E0		COC1	LDA	#>DCSORG	;high domestic character se:
 13203 EFA9 8D F4 02			STA	CHBAS		;character set base
 13204 EFAC A9 CC			LDA	#>ICSORG	;high international charact:
 13205 EFAE 8D 6B 02			STA	CHSALT		;alternate character set ba:
 13206 EFB1 A9 02			LDA	#2
 13207 EFB3 8D F3 02			STA	CHACT
 13208 EFB6 8D 2F 02			STA	SDMCTL		;turn off DMA
 13209 EFB9 A9 01			LDA	#SUCCES
 13210 EFBB 85 4C			STA	DSTAT		;clear status
 13211 EFBD A9 C0			LDA	#$C0		;enable IRQ
 13212 EFBF 05 10			ORA	POKMSK
 13213 EFC1 85 10			STA	POKMSK
 13214 EFC3 8D 0E D2			STA	IRQEN
 13215
 13216 				;	Set DLI status.
 13217
 13218 EFC6 A9 40			LDA	#$40		;disable DLI
 13219 EFC8 8D 0E D4			STA	NMIEN
 13220 EFCB 2C 6E 02			BIT	FINE
 13221 EFCE 10 0C			BPL	COC2		;if not fine scrolling (VBL:
 13222
 13223 EFD0 A9 C4			LDA	#<FDL
 13224 EFD2 8D 00 02			STA	VDSLST		;DLI vector
 13225 EFD5 A9 FC			LDA	#>FDL
 13226 EFD7 8D 01 02			STA	VDSLST+1
 13227 EFDA A9 C0			LDA	#$C0
 13228
 13229 EFDC 8D 0E D4		COC2	STA	NMIEN
 13230
 13231 				;	Clear control.
 13232
 13233 EFDF A9 00			LDA	#0
 13234 EFE1 8D 93 02			STA	TINDEX		;clear text index (must alw:
 13235 EFE4 85 64			STA	ADRESS
 13236 EFE6 85 7B			STA	SWPFLG
 13237 EFE8 8D F0 02			STA	CRSINH
 13238
 13239 				;	Set initial tab stops.
 13240
 13241 EFEB A0 0E			LDY	#14		;offset to last byte of bit:
 13242 EFED A9 01			LDA	#$01		;tab stop every 8 character:
 13243
 13244 EFEF 99 A3 02		COC3	STA	TABMAP,Y	;set tab stop
 13245 EFF2 88				DEY
 13246 EFF3 10 FA			BPL	COC3		;if not done
 13247
 13248 				;	Load initialize color register shadows.
 13249
 13250 EFF5 A2 04			LDX	#4		;offset to last color regis:
 13251
 13252 EFF7 BD 08 FB		COC4	LDA	TDSC,X		;default screen color
 13253 EFFA 9D C4 02			STA	COLOR0,X	;set color register shadow
 13254 EFFD CA				DEX
 13255 EFFE 10 F7			BPL	COC4		;if not done
 13256
 13257 				;	Set up.
 13258
 13259 F000 A4 6A			LDY	RAMTOP		;(high) RAM size
 13260 F002 88				DEY			;decrement (high) RAM size
 13261 F003 8C 95 02			STY	TXTMSC+1
 13262 F006 A9 60			LDA	#<[$0000-160]	;low RAM size = 160
 13263 F008 8D 94 02			STA	TXTMSC
 13264 F00B A6 57			LDX	DINDEX		;mode
 13265 F00D BD 4D EE			LDA	TAGM,X		;convert to ANTIC code
 13266 F010 85 51			STA	HOLD1		;ANTIC code
 13267 F012 A5 6A			LDA	RAMTOP		;(high) RAM size
 13268 F014 85 65			STA	ADRESS+1
 13269
 13270 				;	Allocate memory.
 13271
 13272 F016 BC 1D EE			LDY	TSMA,X		;number of 40-byte blocks t:
 13273
 13274 F019 A9 28		COC5	LDA	#40		;40 bytes
 13275 F01B 20 7A F5			JSR	DBS		;perform double byte subtra:
 13276 F01E 88				DEY
 13277 F01F D0 F8			BNE	COC5		;if not done
 13278
 13279 				;	Clear GTIA modes.
 13280
 13281 F021 AD 6F 02			LDA	GPRIOR
 13282 F024 29 3F			AND	#$3F		;clear GTIA modes
 13283 F026 85 67			STA	OPNTMP+1
 13284 F028 A8				TAY
 13285
 13286 				;	Determine mode.
 13287
 13288 F029 E0 08			CPX	#8
 13289 F02B 90 1F			BCC	COC7		;if mode < 8
 13290
 13291 F02D E0 0F			CPX	#15
 13292 F02F F0 0D			BEQ	COC6		;if mode 15
 13293
 13294 F031 E0 0C			CPX	#12
 13295 F033 B0 17			BCS	COC7		;if mode >= 12
 13296
 13297 				;	Process mode 9, 10 and 11.
 13298
 13299 F035 8A				TXA			;mode
 13300 F036 6A				ROR
 13301 F037 6A				ROR
 13302 F038 6A				ROR
 13303 F039 29 C0			AND	#$C0		;extract 2 low bits (in 2 h:
 13304 F03B 05 67			ORA	OPNTMP+1
 13305 F03D A8				TAY
 13306
 13307 				;	Establish line boundary at X000.
 13308
 13309 F03E A9 10		COC6	LDA	#16		;subtract 16 for page bound:
 13310 F040 20 7A F5			JSR	DBS		;perform double byte subtra:
 13311
 13312 				;	Check for mode 11.
 13313
 13314 F043 E0 0B			CPX	#11
 13315 F045 D0 05			BNE	COC7		;if mode 11
 13316
 13317 				;	Set GTIA luminance.
 13318
 13319 F047 A9 06			LDA	#6		;GTIA luminance value
 13320 F049 8D C8 02			STA	COLOR4		;background color
 13321
 13322 				;	Set new priority.
 13323
 13324 F04C 8C 6F 02		COC7	STY	GPRIOR		;new priority
 13325
 13326 				;	Set memory scan counter.
 13327
 13328 F04F A5 64			LDA	ADRESS		;memory scan counter
 13329 F051 85 58			STA	SAVMSC		;save memory scan counter
 13330 F053 A5 65			LDA	ADRESS+1
 13331 F055 85 59			STA	SAVMSC+1
 13332
 13333 				;	Wait for VBLANK.
 13334
 13335 F057 AD 0B D4		COC8	LDA	VCOUNT
 13336 F05A C9 7A			CMP	#$7A
 13337 F05C D0 F9			BNE	COC8		;if VBLANK has not occured
 13338
 13339 				;	Put display list under RAM.
 13340
 13341 F05E 20 78 F5			JSR	DSD		;perform double byte single:
 13342 F061 BD 5D EE			LDA	TDLV,X		;display list vulnerability
 13343 F064 F0 06			BEQ	COC9		;if not vulnerable
 13344
 13345 F066 A9 FF			LDA	#$FF
 13346 F068 85 64			STA	ADRESS
 13347 F06A C6 65			DEC	ADRESS+1	;drop down 1 page
 13348
 13349 F06C 20 65 F5		COC9	JSR	DDD		;perform double byte double:
 13350 F06F A5 64			LDA	ADRESS		;end of display list
 13351 F071 85 68			STA	SAVADR		;save address
 13352 F073 A5 65			LDA	ADRESS+1
 13353 F075 85 69			STA	SAVADR+1
 13354
 13355 				;	Set up.
 13356
 13357 F077 A9 41			LDA	#$41		;ANTIC wait for VBLANK and :
 13358 F079 20 70 F5			JSR	SDI		;store data indirect
 13359 F07C 86 66			STX	OPNTMP
 13360 F07E A9 18			LDA	#24
 13361 F080 8D BF 02			STA	BOTSCR	;screen bottom
 13362
 13363 				;	Check for modes 9 ,10 and 11.
 13364
 13365 F083 A5 57			LDA	DINDEX		;mode
 13366 F085 C9 0C			CMP	#12
 13367 F087 B0 04			BCS	COC10		;if mode >= 12, mixed mode :
 13368
 13369 F089 C9 09			CMP	#9
 13370 F08B B0 39			BCS	COC12		;if mode >= 9, mixed mode n:
 13371
 13372 				;	Check for mixed mode.
 13373
 13374 F08D A5 2A		COC10	LDA	ICAX1Z
 13375 F08F 29 10			AND	#MXDMOD
 13376 F091 F0 33			BEQ	COC12		;if not mixed mode
 13377
 13378 				;	Process mixed mode.
 13379
 13380 F093 A9 04			LDA	#4
 13381 F095 8D BF 02			STA	BOTSCR	;screen bottom
 13382 F098 A2 02			LDX	#2
 13383 F09A AD 6E 02			LDA	FINE
 13384 F09D F0 03			BEQ	COC11		;if not fine scrolling
 13385
 13386 F09F 20 A0 F5			JSR	SSE		;set scrolling display list:
 13387
 13388 F0A2 A9 02		COC11	LDA	#$02
 13389 F0A4 20 69 F5			JSR	SDF		;store data indirect for fi:
 13390 F0A7 CA				DEX
 13391 F0A8 10 F8			BPL	COC11		;if not done
 13392
 13393 				;	Reload MSC for text.
 13394
 13395 F0AA A4 6A			LDY	RAMTOP		;(high) RAM size
 13396 F0AC 88				DEY			;decrement (high) RAM size
 13397 F0AD 98				TYA
 13398 F0AE 20 70 F5			JSR	SDI		;store data indirect
 13399 F0B1 A9 60			LDA	#<[$0000-160]	;low RAM size = 160
 13400 F0B3 20 70 F5			JSR	SDI		;store data indirect
 13401 F0B6 A9 42			LDA	#$42		;fine scrolling
 13402 F0B8 20 69 F5			JSR	SDF		;store data indirect
 13403 F0BB 18				CLC
 13404 F0BC A9 10			LDA	#MXDMOD
 13405 F0BE 65 66			ADC	OPNTMP
 13406 F0C0 A8				TAY
 13407 F0C1 BE 2D EE			LDX	TDLE,Y
 13408 F0C4 D0 15			BNE	COC13
 13409
 13410 				;	Check mode.
 13411
 13412 F0C6 A4 66		COC12	LDY	OPNTMP
 13413 F0C8 BE 2D EE			LDX	TDLE,Y		;number of display list ent:
 13414 F0CB A5 57			LDA	DINDEX		;mode
 13415 F0CD D0 0C			BNE	COC13		;if not mode 0
 13416
 13417 				;	Check for fine scrolling.
 13418
 13419 F0CF AD 6E 02			LDA	FINE		;fine scrolling flag
 13420 F0D2 F0 07			BEQ	COC13		;if not fine scrolling
 13421
 13422 				;	Process fine scrolling.
 13423
 13424 F0D4 20 A0 F5			JSR	SSE		;set scrolling display list:
 13425 F0D7 A9 22			LDA	#$22
 13426 F0D9 85 51			STA	HOLD1
 13427
 13428 				;	Continue.
 13429
 13430 F0DB A5 51		COC13	LDA	HOLD1
 13431 F0DD 20 70 F5			JSR	SDI		;store data indirect
 13432 F0E0 CA				DEX
 13433 F0E1 D0 F8			BNE	COC13		;if not done
 13434
 13435 				;	Determine mode.
 13436
 13437 F0E3 A5 57			LDA	DINDEX		;mode
 13438 F0E5 C9 08			CMP	#8
 13439 F0E7 90 26			BCC	COC16		;if mode < 8
 13440
 13441 F0E9 C9 0F			CMP	#15
 13442 F0EB F0 04			BEQ	COC14		;if mode 15
 13443
 13444 F0ED C9 0C			CMP	#12
 13445 F0EF B0 1E			BCS	COC16		;if mode >= 12
 13446
 13447 				;	Process modes 8, 9, 10, 11 and 15.
 13448
 13449 F0F1 A2 5D		COC14	LDX	#93		;remaining number of DLE's
 13450 F0F3 A5 6A			LDA	RAMTOP		;(high) RAM size
 13451 F0F5 38				SEC
 13452 F0F6 E9 10			SBC	#>$1000	;subtract 4K
 13453 F0F8 20 70 F5			JSR	SDI		;store data indirect
 13454 F0FB A9 00			LDA	#<$0000
 13455 F0FD 20 70 F5			JSR	SDI		;store data indirect
 13456 F100 A5 51			LDA	HOLD1		;ANTIC MSC code
 13457 F102 09 40			ORA	#$40
 13458 F104 20 70 F5			JSR	SDI		;store data indirect
 13459
 13460 F107 A5 51		COC15	LDA	HOLD1		;remaining DLE's
 13461 F109 20 70 F5			JSR	SDI		;store data indirect
 13462 F10C CA				DEX
 13463 F10D D0 F8			BNE	COC15		;if DLE's remain
 13464
 13465 				;	Complete display list with LMS.
 13466
 13467 F10F A5 59		COC16	LDA	SAVMSC+1	;high saved memory scan cou:
 13468 F111 20 70 F5			JSR	SDI		;store data indirect
 13469 F114 A5 58			LDA	SAVMSC		;low saved memory scan coun:
 13470 F116 20 70 F5			JSR	SDI		;store data indirect
 13471 F119 A5 51			LDA	HOLD1
 13472 F11B 09 40			ORA	#$40
 13473 F11D 20 70 F5			JSR	SDI		;store data indirect
 13474 F120 A9 70			LDA	#$70		;8 blank lines
 13475 F122 20 70 F5			JSR	SDI		;store data indirect
 13476 F125 A9 70			LDA	#$70		;8 blank lines
 13477 F127 20 70 F5			JSR	SDI		;store data indirect
 13478 F12A A5 64			LDA	ADRESS		;display list address
 13479 F12C 8D 30 02			STA	SDLSTL		;save display list address
 13480 F12F A5 65			LDA	ADRESS+1
 13481 F131 8D 31 02			STA	SDLSTL+1
 13482 F134 A9 70			LDA	#$70		;8 blank lines
 13483 F136 20 70 F5			JSR	SDI		;store data indirect
 13484 F139 A5 64			LDA	ADRESS		;display list address
 13485 F13B 8D E5 02			STA	MEMTOP		;update top of memory
 13486 F13E A5 65			LDA	ADRESS+1
 13487 F140 8D E6 02			STA	MEMTOP+1
 13488 F143 A0 01			LDY	#1		;offset
 13489 F145 AD 30 02			LDA	SDLSTL		;saved display list address
 13490 F148 91 68			STA	(SAVADR),Y
 13491 F14A C8				INY
 13492 F14B AD 31 02			LDA	SDLSTL+1
 13493 F14E 91 68			STA	(SAVADR),Y
 13494
 13495 				;	Check status.
 13496
 13497 F150 A5 4C			LDA	DSTAT		;status
 13498 F152 10 10			BPL	COC18		;if no error
 13499
 13500 				;	Process error.
 13501
 13502 F154 8D EC 03		COC17	STA	DERRF		;screen OPEN error flag
 13503 F157 20 94 EF			JSR	EOP		;perform editor OPEN
 13504 F15A AD EC 03			LDA	DERRF		;restore status
 13505 F15D A0 00			LDY	#0		;no screen OPEN error indic:
 13506 F15F 8C EC 03			STY	DERRF		;screen OPEN error flag
 13507 F162 A8				TAY			;status
 13508 F163 60				RTS			;return
 13509
 13510 				;	Check clear inhibit.
 13511
 13512 F164 A5 2A		COC18	LDA	ICAX1Z
 13513 F166 29 20			AND	#$20		;extract clear inhibit bit
 13514 F168 D0 0B			BNE	COC19		;if clear inhibited
 13515
 13516 				;	Clear screen.
 13517
 13518 F16A 20 20 F4			JSR	CSC		;clear screen
 13519 F16D 8D 90 02			STA	TXTROW		;set cursor at top row
 13520 F170 A5 52			LDA	LMARGN		;left margin
 13521 F172 8D 91 02			STA	TXTCOL		;set cursor at left margin
 13522
 13523 				;	Exit.
 13524
 13525 F175 A9 22		COC19	LDA	#$22		;turn on DMA control
 13526 F177 0D 2F 02			ORA	SDMCTL
 13527 F17A 8D 2F 02			STA	SDMCTL
 13528 F17D 4C 0B F2			JMP	SEC		;set exit conditions, retur:
 13529 					;SPACE	4,10
 13530 				;	SGB - Perform Screen GET-BYTE
 13531 				*
 13532 				*	ENTRY	JSR	SGB
 13533 				*
 13534 				*	MODS
 13535 				*		Original Author Unknown
 13536 				*		1. Bring closer to Coding Standard (object unchanged).
 13537 				*		   R. K. Nordin	11/01/83
 13538
 13539
 13540 = F180			SGB	=	*	;entry
 13541 F180 20 CA F6			JSR	CCR	;check cursor range
 13542 F183 20 8F F1			JSR	GDC	;get data under cursor
 13543 F186 20 6A F7			JSR	CIA	;convert internal character to ATAS:
 13544 F189 20 0A F6			JSR	SZA	;set zero data and advance cursor
 13545 F18C 4C 1E F2			JMP	SST	;perform screen STATUS, return
 13546 					;SPACE	4,10
 13547 				;	GDC - Get Data Under Cursor
 13548 				*
 13549 				*	ENTRY	JSR	GDC
 13550 				*
 13551 				*	MODS
 13552 				*		Original Author Unknown
 13553 				*		1. Bring closer to Coding Standard (object unchanged).
 13554 				*		   R. K. Nordin	11/01/83
 13555
 13556
 13557 = F18F			GDC	=	*	;entry
 13558 F18F 20 AC F5			JSR	CCA	;convert cursor row/column to addre:
 13559 F192 B1 64			LDA	(ADRESS),Y
 13560 F194 2D A0 02			AND	DMASK
 13561
 13562 F197 46 6F		GDC1	LSR	SHFAMT	;shift data down to low bits
 13563 F199 B0 03			BCS	GDC2	;if done
 13564
 13565 F19B 4A				LSR
 13566 F19C 10 F9			BPL	GDC1	;continue shifting
 13567
 13568 F19E 8D FA 02		GDC2	STA	CHAR
 13569 F1A1 C9 00			CMP	#0	;restore flags
 13570 F1A3 60			F1A3	RTS		;return
 13571 					;SPACE	4,10
 13572 				;	SPB - Perform Screen PUT-BYTE
 13573 				*
 13574 				*	ENTRY	JSR	SPB
 13575 				*
 13576 				*	MODS
 13577 				*		Original Author Unknown
 13578 				*		1. Bring closer to Coding Standard (object unchanged).
 13579 				*		   R. K. Nordin	11/01/83
 13580
 13581
 13582 = F1A4			SPB	=	*	;entry
 13583 F1A4 8D FB 02			STA	ATACHR
 13584
 13585 				;	JSR	ROD	;restore old data under cursor
 13586
 13587 F1A7 C9 7D			CMP	#CLS
 13588 F1A9 D0 06			BNE	SPB1	;if not clear screen
 13589
 13590 F1AB 20 20 F4			JSR	CSC	;clear screen
 13591 F1AE 4C 0B F2			JMP	SEC	;set exit contitions, return
 13592
 13593 F1B1 20 CA F6		SPB1	JSR	CCR	;check cursor range
 13594 				;	JMP	CEL	;check EOL, return
 13595 					;SPACE	4,10
 13596 				;	CEL - Check End of Line
 13597 				*
 13598 				*	ENTRY	JSR	CEL
 13599 				*
 13600 				*	MODS
 13601 				*		Original Author Unknown
 13602 				*		1. Bring closer to Coding Standard (object unchanged).
 13603 				*		   R. K. Nordin	11/01/83
 13604
 13605
 13606 = F1B4			CEL	=	*	;entry
 13607 F1B4 AD FB 02			LDA	ATACHR
 13608 F1B7 C9 9B			CMP	#EOL
 13609 F1B9 D0 06			BNE	CEL1	;if not EOL
 13610
 13611 F1BB 20 61 F6			JSR	RWS	;return with scrolling
 13612 F1BE 4C 0B F2			JMP	SEC	;set exit conditions, return
 13613
 13614 F1C1 20 CA F1		CEL1	JSR	PLO	;plot point
 13615 F1C4 20 0E F6			JSR	SEA	;set EOL data and advance cursor
 13616 F1C7 4C 0B F2			JMP	SEC	;set exit conditions, return
 13617 					;SPACE	4,10
 13618 				;	PLO - Plot Point
 13619 				*
 13620 				*	ENTRY	JSR	PLO
 13621 				*
 13622 				*	MODS
 13623 				*		Original Author Unknown
 13624 				*		1. Bring closer to Coding Standard (object unchanged).
 13625 				*		   R. K. Nordin	11/01/83
 13626
 13627
 13628 = F1CA			PLO	=	*		;entry
 13629
 13630 				;	Wait for start/stop flag clear.
 13631
 13632 F1CA AD FF 02		PLO0	LDA	SSFLAG		;start/stop flag
 13633 F1CD D0 FB			BNE	PLO0		;if start/stop flag non-zer:
 13634
 13635 				;	Save cursor row/column.
 13636
 13637 F1CF A2 02			LDX	#2		;offset to last byte
 13638
 13639 F1D1 B5 54		PLO1	LDA	ROWCRS,X	;byte of cursor row/column
 13640 F1D3 95 5A			STA	OLDROW,X	;save byte of cursor row/co:
 13641 F1D5 CA				DEX
 13642 F1D6 10 F9			BPL	PLO1		;if not done
 13643
 13644 				;	Convert ATASCII character to internal.
 13645
 13646 F1D8 AD FB 02			LDA	ATACHR		;character
 13647 F1DB A8				TAY			;character
 13648 F1DC 2A				ROL
 13649 F1DD 2A				ROL
 13650 F1DE 2A				ROL
 13651 F1DF 2A				ROL
 13652 F1E0 29 03			AND	#3
 13653 F1E2 AA				TAX			;index into TAIC
 13654 F1E3 98				TYA			;character
 13655 F1E4 29 9F			AND	#$9F		;strip off column address
 13656 F1E6 1D 49 FB			ORA	TAIC,X		;or in new column address
 13657 				;	JMP	SPQ		;display, return
 13658 					;SPACE	4,10
 13659 				;	SPQ - Display
 13660 				*
 13661 				*	ENTRY	JSR	SPQ
 13662 				*
 13663 				*	MODS
 13664 				*		Original Author Unknown
 13665 				*		1. Bring closer to Coding Standard (object unchanged).
 13666 				*		   R. K. Nordin	11/01/83
 13667
 13668
 13669 = F1E9			SPQ	=	*		;entry
 13670
 13671 				;	Set CHAR.
 13672
 13673 F1E9 8D FA 02			STA	CHAR		;character
 13674
 13675 				;	Convert cursor row/column to address.
 13676
 13677 F1EC 20 AC F5			JSR	CCA		;convert cursor row/column :
 13678
 13679 				;	Shift up to proper position.
 13680
 13681 F1EF AD FA 02			LDA	CHAR		;character
 13682
 13683 F1F2 46 6F		SPQ1	LSR	SHFAMT
 13684 F1F4 B0 04			BCS	SPQ2		;if done
 13685
 13686 F1F6 0A				ASL
 13687 F1F7 4C F2 F1			JMP	SPQ1		;continue shifting
 13688
 13689 				;	Update data.
 13690
 13691 F1FA 2D A0 02		SPQ2	AND	DMASK
 13692 F1FD 85 50			STA	TMPCHR		;save shifted data
 13693 F1FF AD A0 02			LDA	DMASK		;display mask
 13694 F202 49 FF			EOR	#$FF		;complement display mask
 13695 F204 31 64			AND	(ADRESS),Y	;mask off old data
 13696 F206 05 50			ORA	TMPCHR		;or in new data
 13697 F208 91 64			STA	(ADRESS),Y	;update data
 13698 F20A 60				RTS			;return
 13699 					;SPACE	4,10
 13700 				;	SEC - Set Exit Conditions
 13701 				*
 13702 				*	ENTRY	JSR	SEC
 13703 				*
 13704 				*	MODS
 13705 				*		Original Author Unknown
 13706 				*		1. Bring closer to Coding Standard (object unchanged).
 13707 				*		   R. K. Nordin	11/01/83
 13708
 13709
 13710 = F20B			SEC	=	*	;entry
 13711 F20B 20 8F F1			JSR	GDC	;get data under cursor
 13712 F20E 85 5D			STA	OLDCHR
 13713 F210 A6 57			LDX	DINDEX	;mode
 13714 F212 D0 0A			BNE	SST	;if graphics, no cursor
 13715
 13716 F214 AE F0 02			LDX	CRSINH	;cursor inhibit flag
 13717 F217 D0 05			BNE	SST	;if cursor inhibited
 13718
 13719 F219 49 80			EOR	#$80	;complement most significant bit
 13720 F21B 20 E9 F1			JSR	SPQ	;display
 13721 				;	JMP	SST	;perform screen status, return
 13722 					;SPACE	4,10
 13723 				;	SST - Perform Screen STATUS
 13724 				*
 13725 				*	ENTRY	JSR	SST
 13726 				*
 13727 				*	MODS
 13728 				*		Original Author Unknown
 13729 				*		1. Bring closer to Coding Standard (object unchanged).
 13730 				*		   R. K. Nordin	11/01/83
 13731
 13732
 13733 = F21E			SST	=	*	;entry
 13734 F21E A4 4C			LDY	DSTAT	;status
 13735 F220 4C 26 F2			JMP	SST1	;continue
 13736 				;	;SUBTTL	'$F223 Patch'
 13737 					;SPACE	4,10
 13738 F223				ORG	$F223
 13739 					;SPACE	4,10
 13740 				;	F223 - $F223 Patch
 13741 				*
 13742 				*	For compatibility with OS Revision B, perform power-up display.
 13743
 13744
 13745 = F223			PPD	=	*	;entry
 13746 F223 4C FC C8			JMP	SES	;select and execute self-test
 13747 				;	;SUBTTL	'Keyboard, Editor and Screen Handler, Part 3'
 13748 					;SPACE	4,10
 13749 				;	Continue.
 13750
 13751 F226 A9 01		SST1	LDA	#SUCCES	;indicate success
 13752 F228 85 4C			STA	DSTAT	;status
 13753 F22A AD FB 02			LDA	ATACHR	;data
 13754 				;	JMP	ESP	;return
 13755 					;SPACE	4,10
 13756 				;	ESP - Perform Editor SPECIAL
 13757 				*
 13758 				*	ESP does nothing.
 13759 				*
 13760 				*	ENTRY	JSR	ESP
 13761 				*
 13762 				*	MODS
 13763 				*		Original Author Unknown
 13764 				*		1. Bring closer to Coding Standard (object unchanged).
 13765 				*		   R. K. Nordin	11/01/83
 13766
 13767
 13768 = F22D			ESP	=	*	;entry
 13769 F22D 60				RTS		;return
 13770 					;SPACE	4,10
 13771 				;	ECL - Perform Editor CLOSE
 13772 				*
 13773 				*	ENTRY	JSR	ECL
 13774 				*
 13775 				*	MODS
 13776 				*		Original Author Unknown
 13777 				*		1. Bring closer to Coding Standard (object unchanged).
 13778 				*		   R. K. Nordin	11/01/83
 13779
 13780
 13781 = F22E			ECL	=	*	;entry
 13782
 13783 				;	Check for fine scrolling.
 13784
 13785 F22E 2C 6E 02			BIT	FINE	;fine scrolling flag
 13786 F231 10 EB			BPL	SST	;if not fine scrolling, perform STA:
 13787
 13788 				;	Process fine scrolling.
 13789
 13790 F233 A9 40			LDA	#$40
 13791 F235 8D 0E D4			STA	NMIEN		;disable DLI
 13792 F238 A9 00			LDA	#0		;clear fine scrolling flag
 13793 F23A 8D 6E 02			STA	FINE
 13794 F23D A9 CE			LDA	#<RIR	;return from interrupt rout:
 13795 F23F 8D 00 02			STA	VDSLST		;restore initial DLI vector:
 13796 F242 A9 C0			LDA	#>RIR
 13797 F244 8D 01 02			STA	VDSLST+1
 13798 F247 4C 94 EF			JMP	EOP		;perform editor OPEN, retur:
 13799 					;SPACE	4,10
 13800 				;	EGB - Perform Editor GET-BYTE
 13801 				*
 13802 				*	ENTRY	JSR	EGB
 13803 				*
 13804 				*	MODS
 13805 				*		Original Author Unknown
 13806 				*		1. Bring closer to Coding Standard (object unchanged).
 13807 				*		   R. K. Nordin	11/01/83
 13808
 13809
 13810 = F24A			EGB	=	*	;entry
 13811
 13812 				;	Initialize.
 13813
 13814 F24A 20 62 F9			JSR	SWA	;swap
 13815 F24D 20 BC F6			JSR	CRE	;check cursor range for editor
 13816 F250 A5 6B			LDA	BUFCNT	;buffer count
 13817 F252 D0 34			BNE	EGB4	;if something in the buffer
 13818
 13819 				;	Get line.
 13820
 13821 F254 A5 54			LDA	ROWCRS		;cursor row
 13822 F256 85 6C			STA	BUFSTR		;buffer start pointer
 13823 F258 A5 55			LDA	COLCRS		;low cursor column
 13824 F25A 85 6D			STA	BUFSTR+1	;high buffer start pointer
 13825
 13826 F25C 20 FD F2		EGB1	JSR	KGB	;perform keyboard GET-BYTE
 13827 F25F 84 4C			STY	DSTAT	;status
 13828 F261 AD FB 02			LDA	ATACHR	;ATASCII character
 13829 F264 C9 9B			CMP	#EOL
 13830 F266 F0 12			BEQ	EGB3	;if EOL
 13831
 13832 F268 20 BE F2			JSR	PCH	;process character
 13833 F26B 20 62 F9			JSR	SWA	;swap
 13834 F26E A5 63			LDA	LOGCOL	;logical column
 13835 F270 C9 71			CMP	#113	;column near column 120
 13836 F272 D0 03			BNE	EGB2	; if not near column 120, no beep
 13837
 13838 F274 20 56 F5			JSR	BEL	;beep
 13839
 13840 F277 4C 5C F2		EGB2	JMP	EGB1	;process new character
 13841
 13842 				;	Process EOL.
 13843
 13844 F27A 20 18 F7		EGB3	JSR	ROD		;restore old data under cur:
 13845 F27D 20 B1 F8			JSR	CBC		;compute buffer count
 13846 F280 A5 6C			LDA	BUFSTR		;buffer start pointer
 13847 F282 85 54			STA	ROWCRS		;cursor row
 13848 F284 A5 6D			LDA	BUFSTR+1	;high buffer start pointer
 13849 F286 85 55			STA	COLCRS		;low cursor column
 13850
 13851 				;	Check buffer count.
 13852
 13853 F288 A5 6B		EGB4	LDA	BUFCNT	;buffer count
 13854 F28A F0 11			BEQ	EGB6	;if buffer count zero
 13855
 13856 				;	Decrement and check buffer count.
 13857
 13858 F28C C6 6B		EGB5	DEC	BUFCNT	;decrement buffer count
 13859 F28E F0 0D			BEQ	EGB6	;if buffer count zero
 13860
 13861 				;	Check status.
 13862
 13863 F290 A5 4C			LDA	DSTAT	;status
 13864 F292 30 F8			BMI	EGB5	;if error, continue decrementing.
 13865
 13866 				;	Perform GET-BYTE.
 13867
 13868 F294 20 80 F1			JSR	SGB	;perform screen GET-BYTE
 13869 F297 8D FB 02			STA	ATACHR	;ATASCII character
 13870 F29A 4C 62 F9			JMP	SWA	;swap, return
 13871
 13872 				;	Exit.
 13873
 13874 F29D 20 61 F6		EGB6	JSR	RWS	;return with scrolling
 13875 F2A0 A9 9B			LDA	#EOL
 13876 F2A2 8D FB 02			STA	ATACHR	;ATASCII character
 13877 F2A5 20 0B F2			JSR	SEC	;set exit conditions
 13878 F2A8 84 4C			STY	DSTAT	;status
 13879 F2AA 4C 62 F9			JMP	SWA	;swap, return
 13880 					;SPACE	4,10
 13881 				;	IRA - Invoke Routine Pointed to by ADRESS
 13882 				*
 13883 				*	ENTRY	JSR	IRA
 13884 				*
 13885 				*	MODS
 13886 				*		Original Author Unknown
 13887 				*		1. Bring closer to Coding Standard (object unchanged).
 13888 				*		   R. K. Nordin	11/01/83
 13889
 13890
 13891 = F2AD			IRA	=	*		;entry
 13892 F2AD 6C 64 00			JMP	(ADRESS)	;execute, return
 13893 					;SPACE	4,10
 13894 				;	EPB - Perform Editor PUT-BYTE
 13895 				*
 13896 				*	ENTRY	JSR	EPB
 13897 				*
 13898 				*	MODS
 13899 				*		Original Author Unknown
 13900 				*		1. Bring closer to Coding Standard (object unchanged).
 13901 				*		   R. K. Nordin	11/01/83
 13902
 13903
 13904 = F2B0			EPB	=	*	;entry
 13905 F2B0 8D FB 02			STA	ATACHR	;ATASCII character
 13906 F2B3 20 62 F9			JSR	SWA	;swap
 13907 F2B6 20 BC F6			JSR	CRE	;check cursor range for editor
 13908 F2B9 A9 00			LDA	#0
 13909 F2BB 8D E8 03			STA	SUPERF	;clear super function flag
 13910 				;	JMP	PCH	;process character, return
 13911 					;SPACE	4,10
 13912 				;	PCH - Process Character
 13913 				*
 13914 				*	PCH displays the character or processes control cha:
 13915 				*	super functions (shifted function keys).
 13916 				*
 13917 				*	ENTRY	JSR	PCH
 13918 				*
 13919 				*	MODS
 13920 				*		Original Author Unknown
 13921 				*		1. Bring closer to Coding Standard (object unchanged).
 13922 				*		   R. K. Nordin	11/01/83
 13923
 13924
 13925 = F2BE			PCH	=	*	;entry
 13926 F2BE 20 18 F7			JSR	ROD	;restore old data under cursor
 13927 F2C1 20 3C F9			JSR	CCC	;check for control character
 13928 F2C4 F0 09			BEQ	PCH2	;if control character
 13929
 13930 				;	Display character.
 13931
 13932 F2C6 0E A2 02		PCH1	ASL	ESCFLG	;escape flag
 13933 F2C9 20 B4 F1			JSR	CEL	;check EOL
 13934 F2CC 4C 62 F9			JMP	SWA	;swap, return
 13935
 13936 				;	Process control character.
 13937
 13938 F2CF AD FE 02		PCH2	LDA	DSPFLG	;display flag
 13939 F2D2 0D A2 02			ORA	ESCFLG	;escape flag
 13940 F2D5 D0 EF			BNE	PCH1	;if display or escape, display chara:
 13941
 13942 				;	Continue.
 13943
 13944 F2D7 0E A2 02			ASL	ESCFLG
 13945 F2DA E8				INX
 13946
 13947 				;	Check for super function.
 13948
 13949 F2DB AD E8 03			LDA	SUPERF
 13950 F2DE F0 05			BEQ	PCH3		;if not super function
 13951
 13952 				;	Adjust for super function.
 13953
 13954 F2E0 8A				TXA
 13955 F2E1 18				CLC
 13956 F2E2 69 2D			ADC	#TSFR-TCCR-3
 13957 F2E4 AA				TAX			;adjusted offset
 13958
 13959 				;	Process control character or super function.
 13960
 13961 F2E5 BD 0D FB		PCH3	LDA	TCCR,X		;low routine address
 13962 F2E8 85 64			STA	ADRESS
 13963 F2EA BD 0E FB			LDA	TCCR+1,X	;high routine address
 13964 F2ED 85 65			STA	ADRESS+1
 13965 F2EF 20 AD F2			JSR	IRA		;invoke routine pointed to :
 13966 F2F2 20 0B F2			JSR	SEC		;set exit conditions
 13967 F2F5 4C 62 F9			JMP	SWA		;swap, return
 13968 					;SPACE	4,10
 13969 				;	IGN - Ignore Character and Perform Keyboard GET-BYT:
 13970 				*
 13971 				*	ENTRY	JSR	IGN
 13972 				*
 13973 				*	EXIT
 13974 				*		CH = $FF
 13975 				*
 13976 				*	MODS
 13977 				*		Original Author Unknown
 13978 				*		1. Bring closer to Coding Standard (object unchanged).
 13979 				*		   R. K. Nordin	11/01/83
 13980
 13981
 13982 = F2F8			IGN	=	*	;entry
 13983 F2F8 A9 FF			LDA	#$FF	;clear code indicator
 13984 F2FA 8D FC 02			STA	CH	;key code
 13985 				;	JMP	KGB	;perform keyboard GET-BYTE, return
 13986 					;SPACE	4,10
 13987 				;	KGB - Perform Keyboard GET-BYTE
 13988 				*
 13989 				*	ENTRY	JSR	KGB
 13990 				*
 13991 				*	NOTES
 13992 				*		Problem: byte wasted by unnecessary TAX nea:
 13993 				*
 13994 				*	MODS
 13995 				*		Original Author Unknown
 13996 				*		1. Bring closer to Coding Standard (object unchanged).
 13997 				*		   R. K. Nordin	11/01/83
 13998
 13999
 14000 = F2FD			KGB	=	*	;entry
 14001
 14002 				;	Initialize.
 14003
 14004 F2FD A9 00		KGB1	LDA	#0
 14005 F2FF 8D E8 03			STA	SUPERF	;clear super function flag
 14006
 14007 				;	Check for special edit read mode.
 14008
 14009 F302 A5 2A			LDA	ICAX1Z
 14010 F304 4A				LSR
 14011 F305 B0 6F			BCS	KGB11	;if special edit read mode
 14012
 14013 				;	Check for BREAK abort.
 14014
 14015 F307 A9 80			LDA	#BRKABT	;assume BREAK abort
 14016 F309 A6 11			LDX	BRKKEY	;BREAK key flag
 14017 F30B F0 65			BEQ	KGB10	;if BREAK abort
 14018
 14019 				;	Check for character.
 14020
 14021 F30D AD FC 02			LDA	CH	;key code
 14022 F310 C9 FF			CMP	#$FF	;clear code indicator
 14023 F312 F0 E9			BEQ	KGB1	;if no character
 14024
 14025 				;	Process character.
 14026
 14027 F314 85 7C			STA	HOLDCH	;save character
 14028 F316 A2 FF			LDX	#$FF	;clear code indicator
 14029 F318 8E FC 02			STX	CH	;key code
 14030
 14031 				;	Sound key click if desired.
 14032
 14033 F31B AE DB 02			LDX	NOCLIK	;click inhibit flag
 14034 F31E D0 03			BNE	KGB2	;if click inhibited
 14035
 14036 F320 20 83 F9			JSR	SKC	;sound key click
 14037
 14038 				;	Set offset to key definition.
 14039
 14040 F323 A8			KGB2	TAY		;save character
 14041
 14042 				;	Check for CTRL and SHIFT together.
 14043
 14044 F324 C0 C0			CPY	#$C0
 14045 F326 B0 D0			BCS	IGN	;if CTRL and SHIFT together, ignore
 14046
 14047 				;	Convert to ATASCII character.
 14048
 14049 F328 B1 79			LDA	(KEYDEF),Y	;ATASCII character
 14050
 14051 				;	Set ATASCII character.
 14052
 14053 F32A 8D FB 02		KGB3	STA	ATACHR	;ATASCII character
 14054 F32D AA				TAX
 14055 F32E 30 03			BMI	KGB4	;if special key
 14056
 14057 F330 4C B4 F3			JMP	KGB17	;process shift/control lock
 14058
 14059 				;	Check for null character.
 14060
 14061 F333 C9 80		KGB4	CMP	#$80
 14062 F335 F0 C1			BEQ	IGN	;if null, ignore
 14063
 14064 				;	Check for inverse video key.
 14065
 14066 F337 C9 81			CMP	#$81
 14067 F339 D0 0A			BNE	KGB5	;if not inverse video key
 14068
 14069 				;	Process inverse video key.
 14070
 14071 F33B AD B6 02			LDA	INVFLG
 14072 F33E 49 80			EOR	#$80
 14073 F340 8D B6 02			STA	INVFLG
 14074 F343 B0 B3			BCS	IGN	;ignore
 14075
 14076 				;	Check for CAPS key.
 14077
 14078 F345 C9 82		KGB5	CMP	#$82
 14079 F347 D0 0C			BNE	KGB6	;if not CAPS key
 14080
 14081 				;	Process CAPS key.
 14082
 14083 F349 AD BE 02			LDA	SHFLOK	;shift/control lock flags
 14084 F34C F0 0B			BEQ	KGB7	;if no lock, process CAPS lock
 14085
 14086 F34E A9 00			LDA	#$00	;no lock indicator
 14087 F350 8D BE 02			STA	SHFLOK	;shoft/control lock flags
 14088 F353 F0 A3			BEQ	IGN	;ignore
 14089
 14090 				;	Check for SHIFT-CAPS key.
 14091
 14092 F355 C9 83		KGB6	CMP	#$83
 14093 F357 D0 07			BNE	KGB8	;if not SHIFT-CAPS
 14094
 14095 				;	Process SHIFT-CAPS key.
 14096
 14097 F359 A9 40		KGB7	LDA	#$40	;CAPS lock indicator
 14098 F35B 8D BE 02			STA	SHFLOK	;shift/control lock flags
 14099 F35E D0 98			BNE	IGN	;ignore
 14100
 14101 				;	Check for CTRL-CAPS key.
 14102
 14103 F360 C9 84		KGB8	CMP	#$84
 14104 F362 D0 08			BNE	KGB9	;if not CTRL-CAPS
 14105
 14106 				;	Process CTRL-CAPS key.
 14107
 14108 F364 A9 80			LDA	#$80	;control lock indicator
 14109 F366 8D BE 02			STA	SHFLOK	;shift/control lock flags
 14110 F369 4C F8 F2			JMP	IGN	;ignore
 14111
 14112 				;	Check for CTRL-3 key.
 14113
 14114 F36C C9 85		KGB9	CMP	#$85
 14115 F36E D0 0B			BNE	KGB12	;if not CTRL-3 key.
 14116
 14117 				;	Process CTRL-3 key.
 14118
 14119 F370 A9 88			LDA	#EOFERR
 14120
 14121 				;	Set status and BREAK key flag.
 14122
 14123 F372 85 4C		KGB10	STA	DSTAT	;status
 14124 F374 85 11			STA	BRKKEY	;BREAK key flag
 14125
 14126 				;	Set EOL character.
 14127
 14128 F376 A9 9B		KGB11	LDA	#EOL
 14129 F378 4C DA F3			JMP	KGB19	;set ATASCII character
 14130
 14131 				;	Check for CTRL-F3 key.
 14132
 14133 F37B C9 89		KGB12	CMP	#$89
 14134 F37D D0 10			BNE	KGB14	;if not CTRL-F3 key
 14135
 14136 				;	Process CTRL-F3 key.
 14137
 14138 F37F AD DB 02			LDA	NOCLIK	;toggle keyclick status
 14139 F382 49 FF			EOR	#$FF
 14140 F384 8D DB 02			STA	NOCLIK
 14141 F387 D0 03			BNE	KGB13	;if click inhibited
 14142
 14143 F389 20 83 F9			JSR	SKC	;sound key click
 14144
 14145 F38C 4C F8 F2		KGB13	JMP	IGN	;ignore
 14146
 14147 				;	Check for function key.
 14148
 14149 F38F C9 8E		KGB14	CMP	#$8E
 14150 F391 B0 12			BCS	KGB16	;if code >= $8E, not a function key
 14151
 14152 F393 C9 8A			CMP	#$8A
 14153 F395 90 F5			BCC	KGB13	;if code < $8A, not a function key,:
 14154
 14155 				;	Process function key.
 14156
 14157 F397 E9 8A			SBC	#$8A		;convert $8A - $bD to 0 - 3
 14158 F399 06 7C			ASL	HOLDCH		;saved character
 14159 F39B 10 02			BPL	KGB15		;if no SHIFT
 14160
 14161 F39D 09 04			ORA	#$04		;convert 0 - 3 to 4 - 7
 14162
 14163 F39F A8			KGB15	TAY			;offset to function key def:
 14164 F3A0 B1 60			LDA	(FKDEF),Y	;function key
 14165 F3A2 4C 2A F3			JMP	KGB3		;set ATASCII character
 14166
 14167 				;	Check for super function.
 14168
 14169 F3A5 C9 92		KGB16	CMP	#$92
 14170 F3A7 B0 0B			BCS	KGB17	;if code >= $92, process shift/cont:
 14171
 14172 F3A9 C9 8E			CMP	#$8E
 14173 F3AB 90 DF			BCC	KGB13	;if code < $8E, not super function,:
 14174
 14175 				;	Process super function.
 14176
 14177 F3AD E9 72			SBC	#$8E-$1C	;convert $8E - $91 to $1C -:
 14178 F3AF EE E8 03			INC	SUPERF		;set super function flag
 14179 F3B2 D0 26			BNE	KGB19		;set ATASCII character
 14180
 14181 				;	Process shift/control lock.
 14182
 14183 F3B4 A5 7C		KGB17	LDA	HOLDCH	;saved character
 14184 F3B6 C9 40			CMP	#$40
 14185 F3B8 B0 15			BCS	KGB18	;if not lower case
 14186
 14187 F3BA AD FB 02			LDA	ATACHR	;ATASCII character
 14188 F3BD C9 61			CMP	#'a'
 14189 F3BF 90 0E			BCC	KGB18	;if < "a", do not process
 14190
 14191 F3C1 C9 7B			CMP	#'z'+1
 14192 F3C3 B0 0A			BCS	KGB18	;if > "z", do not process
 14193
 14194 F3C5 AD BE 02			LDA	SHFLOK	;shift/control lock flags
 14195 F3C8 F0 05			BEQ	KGB18	;if no lock
 14196
 14197 F3CA 05 7C			ORA	HOLDCH	;modify character
 14198 F3CC 4C 23 F3			JMP	KGB2	;reprocess character
 14199
 14200 				;	Invert character, if necessary.
 14201
 14202 F3CF 20 3C F9		KGB18	JSR	CCC	;check for control character
 14203 F3D2 F0 09			BEQ	KGB20	;if control character, do not inver:
 14204
 14205 F3D4 AD FB 02			LDA	ATACHR	;ATASCII character
 14206 F3D7 4D B6 02			EOR	INVFLG	;invert character
 14207
 14208 				;	Set ATASCII character.
 14209
 14210 F3DA 8D FB 02		KGB19	STA	ATACHR	;ATASCII character
 14211 				;	Exit
 14212
 14213 F3DD 4C 1E F2		KGB20	JMP	SST	;perform screen status, return
 14214 					;SPACE	4,10
 14215 				;	ESC - Escape
 14216 				*
 14217 				*	ENTRY	JSR	ESC
 14218 				*
 14219 				*	MODS
 14220 				*		Original Author Unknown
 14221 				*		1. Bring closer to Coding Standard (object unchanged).
 14222 				*		   R. K. Nordin	11/01/83
 14223
 14224
 14225 = F3E0			ESC	=	*	;entry
 14226 F3E0 A9 80			LDA	#$80	;indicate escape detected
 14227 F3E2 8D A2 02			STA	ESCFLG	;escape flag
 14228 F3E5 60				RTS		;return
 14229 					;SPACE	4,10
 14230 				;	CUP - Move Cursor Up
 14231 				*
 14232 				*	ENTRY	JSR	CUP
 14233 				*
 14234 				*	MODS
 14235 				*		Original Author Unknown
 14236 				*		1. Bring closer to Coding Standard (object unchanged).
 14237 				*		   R. K. Nordin	11/01/83
 14238
 14239
 14240 = F3E6			CUP	=	*	;entry
 14241 F3E6 C6 54			DEC	ROWCRS	;decrement cursor row
 14242 F3E8 10 06			BPL	CUP2	;if row positive
 14243
 14244 F3EA AE BF 02			LDX	BOTSCR	;screen bottom
 14245 F3ED CA				DEX		;screen bottom - 1
 14246
 14247 F3EE 86 54		CUP1	STX	ROWCRS	;update cursor row
 14248
 14249 F3F0 4C 0C F9		CUP2	JMP	SBS	;set buffer start and logical colum:
 14250 					;SPACE	4,10
 14251 				;	CDN - Move Cursor Down
 14252 				*
 14253 				*	ENTRY	JSR	CDN
 14254 				*
 14255 				*	MODS
 14256 				*		Original Author Unknown
 14257 				*		1. Bring closer to Coding Standard (object unchanged).
 14258 				*		   R. K. Nordin	11/01/83
 14259
 14260
 14261 = F3F3			CDN	=	*	;entry
 14262 F3F3 E6 54			INC	ROWCRS	;increment cursor row
 14263 F3F5 A5 54			LDA	ROWCRS	;cursor row
 14264 F3F7 CD BF 02			CMP	BOTSCR	;screen bottom
 14265 F3FA 90 F4			BCC	CUP2	;if at bottom, set buffer start, re:
 14266
 14267 F3FC A2 00			LDX	#0
 14268 F3FE F0 EE			BEQ	CUP1	;update cursor row, return
 14269 					;SPACE	4,10
 14270 				;	CLF - Move Cursor Left
 14271 				*
 14272 				*	ENTRY	JSR	CLF
 14273 				*
 14274 				*	MODS
 14275 				*		Original Author Unknown
 14276 				*		1. Bring closer to Coding Standard (object unchanged).
 14277 				*		   R. K. Nordin	11/01/83
 14278
 14279
 14280 = F400			CLF	=	*	;entry
 14281 F400 C6 55			DEC	COLCRS	;decrement low cursor column
 14282 F402 A5 55			LDA	COLCRS	;low cursor column
 14283 F404 30 04			BMI	CRM	;if negative, move cursor to margin:
 14284
 14285 F406 C5 52			CMP	LMARGN	;left margin
 14286 F408 B0 04			BCS	SCC1	;if at left margin, set logical col:
 14287
 14288 				;	JMP	CRM	;move cursor to right margin, retur:
 14289 					;SPACE	4,10
 14290 				;	CRM - Move Cursor to Right Margin
 14291 				*
 14292 				*	ENTRY	JSR	CRM
 14293 				*
 14294 				*	MODS
 14295 				*		Original Author Unknown
 14296 				*		1. Bring closer to Coding Standard (object unchanged).
 14297 				*		   R. K. Nordin	11/01/83
 14298
 14299
 14300 = F40A			CRM	=	*	;entry
 14301 F40A A5 53			LDA	RMARGN	;right margin
 14302 				;	JMP	SCC	;set cursor column, return
 14303 					;SPACE	4,10
 14304 				;	SCC - Set Cursor Column
 14305 				*
 14306 				*	ENTRY	JSR	SCC
 14307 				*
 14308 				*	MODS
 14309 				*		Original Author Unknown
 14310 				*		1. Bring closer to Coding Standard (object unchanged).
 14311 				*		   R. K. Nordin	11/01/83
 14312
 14313
 14314 = F40C			SCC	=	*	;entry
 14315 F40C 85 55			STA	COLCRS	;set low cursor column
 14316
 14317 F40E 4C 8E F8		SCC1	JMP	SLC	;set logical column, return
 14318 					;SPACE	4,10
 14319 				;	CRT - Move Cursor Right
 14320 				*
 14321 				*	ENTRY	JSR	CRT
 14322 				*
 14323 				*	MODS
 14324 				*		Original Author Unknown
 14325 				*		1. Bring closer to Coding Standard (object unchanged).
 14326 				*		   R. K. Nordin	11/01/83
 14327
 14328
 14329 = F411			CRT	=	*	;entry
 14330 F411 E6 55			INC	COLCRS	;increment low cursor column
 14331 F413 A5 55			LDA	COLCRS	;low cursor column
 14332 F415 C5 53			CMP	RMARGN	;right margin
 14333 F417 90 F5			BCC	SCC1	;if before right margin, process, r:
 14334
 14335 F419 F0 F3			BEQ	SCC1	;if at right margin
 14336
 14337 				;	JMP	CLM	;move cursor to left margin, return
 14338 					;SPACE	4,10
 14339 				;	CLM - Move Cursor to Left Margin
 14340 				*
 14341 				*	ENTRY	JSR	CLM
 14342 				*
 14343 				*	MODS
 14344 				*		Original Author Unknown
 14345 				*		1. Bring closer to Coding Standard (object unchanged).
 14346 				*		   R. K. Nordin	11/01/83
 14347
 14348
 14349 = F41B			CLM	=	*	;entry
 14350 F41B A5 52			LDA	LMARGN	;left margin
 14351 F41D 4C 0C F4			JMP	SCC	;set cursor column, return
 14352 					;SPACE	4,10
 14353 				;	CSC - Clear Screen
 14354 				*
 14355 				*	ENTRY	JSR	CSC
 14356 				*
 14357 				*	MODS
 14358 				*		Original Author Unknown
 14359 				*		1. Bring closer to Coding Standard (object unchanged).
 14360 				*		   R. K. Nordin	11/01/83
 14361
 14362
 14363 = F420			CSC	=	*	;entry
 14364
 14365 				;	Set memory scan counter address.
 14366
 14367 F420 20 A6 F9			JSR	SMS	;set memory scan counter ad:
 14368
 14369 				;	Clear address.
 14370
 14371 F423 A4 64			LDY	ADRESS
 14372 F425 A9 00			LDA	#0
 14373 F427 85 64			STA	ADRESS
 14374
 14375 F429 91 64		CSC1	STA	(ADRESS),Y
 14376 F42B C8				INY
 14377 F42C D0 FB			BNE	CSC1		;if not done with page
 14378
 14379 F42E E6 65			INC	ADRESS+1
 14380 F430 A6 65			LDX	ADRESS+1
 14381 F432 E4 6A			CPX	RAMTOP		;(high) RAM size
 14382 F434 90 F3			BCC	CSC1		;if not done
 14383
 14384 				;	Clean up logical line bit map
 14385
 14386 				;	LDY	#0		;offset to first byte of bi:
 14387 F436 A9 FF			LDA	#$FF
 14388
 14389 F438 99 B2 02		CSC2	STA	LOGMAP,Y	;byte of logical line bit m:
 14390 F43B C8				INY
 14391 F43C C0 04			CPY	#4		;4 bytes
 14392 F43E 90 F8			BCC	CSC2		;if not done
 14393
 14394 				;	Exit.
 14395
 14396 				;	JMP	CHM		;move cursor home, return
 14397 					;SPACE	4,10
 14398 				;	CHM - Move Cursor Home
 14399 				*
 14400 				*	ENTRY	JSR	CHM
 14401 				*
 14402 				*	MODS
 14403 				*		Original Author Unknown
 14404 				*		1. Bring closer to Coding Standard (object unchanged).
 14405 				*		   R. K. Nordin	11/01/83
 14406
 14407
 14408 = F440			CHM	=	*		;entry
 14409 F440 20 97 F9			JSR	SCL		;set cursor at left edge
 14410 F443 85 63			STA	LOGCOL		;logical column
 14411 F445 85 6D			STA	BUFSTR+1	;high buffer start
 14412 F447 A9 00			LDA	#0
 14413 F449 85 54			STA	ROWCRS		;cursor row
 14414 F44B 85 56			STA	COLCRS+1	;high cursor column
 14415 F44D 85 6C			STA	BUFSTR		;low buffer start pointer
 14416 F44F 60				RTS			;return
 14417 					;SPACE	4,10
 14418 				;	BSP - Backspace
 14419 				*
 14420 				*	ENTRY	JSR	BSP
 14421 				*
 14422 				*	MODS
 14423 				*		Original Author Unknown
 14424 				*		1. Bring closer to Coding Standard (object unchanged).
 14425 				*		   R. K. Nordin	11/01/83
 14426
 14427
 14428 = F450			BSP	=	*	;entry
 14429 F450 A5 63			LDA	LOGCOL	;logical column
 14430 F452 C5 52			CMP	LMARGN	;left margin
 14431 F454 F0 21			BEQ	BSP3	;if at left margin
 14432
 14433 F456 A5 55			LDA	COLCRS	;low cursor column
 14434 F458 C5 52			CMP	LMARGN	;left margin
 14435 F45A D0 03			BNE	BSP1	;if not atleft margin
 14436
 14437 F45C 20 23 F9			JSR	DWQ	;see if line should be deleted
 14438
 14439 F45F 20 00 F4		BSP1	JSR	CLF	;move cursor left
 14440 F462 A5 55			LDA	COLCRS	;low cursor column
 14441 F464 C5 53			CMP	RMARGN	;right margin
 14442 F466 D0 07			BNE	BSP2	;if not at right margin
 14443
 14444 F468 A5 54			LDA	ROWCRS	;cursor low
 14445 F46A F0 03			BEQ	BSP2	;if row zero
 14446
 14447 F46C 20 E6 F3			JSR	CUP	;move cursor up
 14448
 14449 F46F A9 20		BSP2	LDA	#' '
 14450 F471 8D FB 02			STA	ATACHR	;ATASCII character
 14451 F474 20 CA F1			JSR	PLO	;plot point
 14452
 14453 F477 4C 8E F8		BSP3	JMP	SLC	;set logical column, return
 14454 					;SPACE	4,10
 14455 				;	TAB - Tab
 14456 				*
 14457 				*	ENTRY	JSR	TAB
 14458 				*
 14459 				*	MODS
 14460 				*		Original Author Unknown
 14461 				*		1. Bring closer to Coding Standard (object unchanged).
 14462 				*		   R. K. Nordin	11/01/83
 14463
 14464
 14465 = F47A			TAB	=	*	;entry
 14466
 14467 F47A 20 11 F4		TAB1	JSR	CRT	;move cursor right
 14468 F47D A5 55			LDA	COLCRS	;low cursor column
 14469 F47F C5 52			CMP	LMARGN	;left margin
 14470 F481 D0 08			BNE	TAB2	;if not at left margin
 14471
 14472 F483 20 65 F6			JSR	RET	;return
 14473 F486 20 58 F7			JSR	BLG	;get bit from logical line bit map
 14474 F489 B0 07			BCS	TAB3	;if end of logical line
 14475
 14476 				;	Check for tab stop.
 14477
 14478 F48B A5 63		TAB2	LDA	LOGCOL	;logical column
 14479 F48D 20 5D F7			JSR	BMG	;set bit from bit map
 14480 F490 90 E8			BCC	TAB1	;if not tab stop, keep looking
 14481
 14482 				;	Set logical lolumn
 14483
 14484 F492 4C 8E F8		TAB3	JMP	SLC	;set logical column, return
 14485 					;SPACE	4,10
 14486 				;	STB - Set Tab
 14487 				*
 14488 				*	ENTRY	JSR	STB
 14489 				*
 14490 				*	MODS
 14491 				*		Original Author Unknown
 14492 				*		1. Bring closer to Coding Standard (object unchanged).
 14493 				*		   R. K. Nordin	11/01/83
 14494
 14495
 14496 = F495			STB	=	*	;entry
 14497 F495 A5 63			LDA	LOGCOL	;logical column
 14498 F497 4C 3E F7			JMP	BMS	;set bit in bit map, retrun
 14499 					;SPACE	4,10
 14500 				;	CTB - Clear Tab
 14501 				*
 14502 				*	ENTRY	JSR	CTB
 14503 				*
 14504 				*	MODS
 14505 				*		Original Author Unknown
 14506 				*		1. Bring closer to Coding Standard (object unchanged).
 14507 				*		   R. K. Nordin	11/01/83
 14508
 14509
 14510 = F49A			CTB	=	*	;entry
 14511 F49A A5 63			LDA	LOGCOL	;logical column
 14512 F49C 4C 4A F7			JMP	BMC	;clear bit in bit map, return
 14513 					;SPACE	4,10
 14514 				;	ICH - Insert Character
 14515 				*
 14516 				*	ENTRY	JSR	ICH
 14517 				*
 14518 				*	MODS
 14519 				*		Original Author Unknown
 14520 				*		1. Bring closer to Coding Standard (object unchanged).
 14521 				*		   R. K. Nordin	11/01/83
 14522
 14523
 14524 = F49F			ICH	=	*	;entry
 14525 F49F 20 4C F9			JSR	SRC	;save row and column
 14526 F4A2 20 8F F1			JSR	GDC	;get data under cursor
 14527 F4A5 85 7D			STA	INSDAT
 14528 F4A7 A9 00			LDA	#0
 14529 F4A9 8D BB 02			STA	SCRFLG
 14530
 14531 F4AC 20 E9 F1		ICH1	JSR	SPQ	;store data
 14532 F4AF A5 63			LDA	LOGCOL	;logical column
 14533 F4B1 48				PHA		;save logical column
 14534 F4B2 20 12 F6			JSR	ACC	;advance cursor column
 14535 F4B5 68				PLA		;saved logical column
 14536 F4B6 C5 63			CMP	LOGCOL	;logical column	
 14537 F4B8 B0 0C			BCS	ICH2	;if saved logical column >= logical:
 14538
 14539 F4BA A5 7D			LDA	INSDAT
 14540 F4BC 48				PHA
 14541 F4BD 20 8F F1			JSR	GDC	;get data under cursor
 14542 F4C0 85 7D			STA	INSDAT
 14543 F4C2 68				PLA
 14544 F4C3 4C AC F4			JMP	ICH1	;continue
 14545
 14546 				;	Exit.
 14547
 14548 F4C6 20 57 F9		ICH2	JSR	RRC	;restore row and column
 14549
 14550 F4C9 CE BB 02		ICH3	DEC	SCRFLG
 14551 F4CC 30 04			BMI	ICH4	;if scroll occured
 14552
 14553 F4CE C6 54			DEC	ROWCRS	;decrement cursor row
 14554 F4D0 D0 F7			BNE	ICH3	;continue
 14555
 14556 F4D2 4C 8E F8		ICH4	JMP	SLC	;set logical column, return
 14557 					;SPACE	4,10
 14558 				;	DCH - Delete Character
 14559 				*
 14560 				*	ENTRY	JSR	DCH
 14561 				*
 14562 				*	MODS
 14563 				*		Original Author Unknown
 14564 				*		1. Bring closer to Coding Standard (object unchanged).
 14565 				*		   R. K. Nordin	11/01/83
 14566
 14567
 14568 = F4D5			DCH	=	*		;entry
 14569
 14570 				;	Save row and column.
 14571
 14572 F4D5 20 4C F9			JSR	SRC		;save row and column
 14573
 14574 				;	Get data to the right of cursor.
 14575
 14576 F4D8 20 AC F5		DCH1	JSR	CCA	;convert cursor row/column to addre:
 14577 F4DB A5 64			LDA	ADRESS
 14578 F4DD 85 68			STA	SAVADR	;save address
 14579 F4DF A5 65			LDA	ADRESS+1
 14580 F4E1 85 69			STA	SAVADR+1
 14581 F4E3 A5 63			LDA	LOGCOL	;logical column
 14582 F4E5 48				PHA		;save lgical column
 14583 F4E6 20 0A F6			JSR	SZA	;set zero data and advance cursor
 14584 F4E9 68				PLA		;saved logical column
 14585 F4EA C5 63			CMP	LOGCOL	;logical column
 14586 F4EC B0 10			BCS	DCH2	;if saved logical column >= logical
 14587
 14588 F4EE A5 54			LDA	ROWCRS		;cursor row
 14589 F4F0 CD BF 02			CMP	BOTSCR		;screen bottom
 14590 F4F3 B0 09			BCS	DCH2		;if row off screem, exit
 14591
 14592 F4F5 20 8F F1			JSR	GDC		;get data under cursor
 14593 F4F8 A0 00			LDY	#0
 14594 F4FA 91 68			STA	(SAVADR),Y	;put data in previous posit:
 14595 F4FC F0 DA			BEQ	DCH1		;continue
 14596
 14597 F4FE A0 00		DCH2	LDY	#0
 14598 F500 98				TYA
 14599 F501 91 68			STA	(SAVADR),Y	;clear last position
 14600 F503 20 18 F9			JSR	DQQ		;try to delete a line
 14601 F506 20 57 F9			JSR	RRC		;restore row and column
 14602 F509 4C 8E F8			JMP	SLC		;set logical column, return
 14603 					;SPACE	4,10
 14604 				;	ILN - Insert Line
 14605 				*
 14606 				*	ENTRY	JSR	ILN
 14607 				*
 14608 				*	MODS
 14609 				*		Original Author Unknown
 14610 				*		1. Bring closer to Coding Standard (object unchanged).
 14611 				*		   R. K. Nordin	11/01/83
 14612
 14613
 14614 = F50C			ILN	=	*	;entry
 14615 F50C 38				SEC
 14616 				;	JMP	ILN1
 14617 					;SPACE	4,10
 14618 				;	ILN1 - Insert Line
 14619 				*
 14620 				*	ENTRY	JSR	ILN1
 14621 				*
 14622 				*	MODS
 14623 				*		Original Author Unknown
 14624 				*		1. Bring closer to Coding Standard (object unchanged).
 14625 				*		   R. K. Nordin	11/01/83
 14626
 14627
 14628 = F50D			ILN1	=	*	;entry
 14629 F50D 20 C2 F7			JSR	ELL	;extend logical line
 14630 F510 A5 52			LDA	LMARGN	;left margin
 14631 F512 85 55			STA	COLCRS	;low cursor column
 14632 F514 20 AC F5			JSR	CCA	;convert cursor row/column to addre:
 14633 F517 20 8E F7			JSR	MLN	;move line
 14634 F51A 20 E2 F7			JSR	CLN	;clear current line
 14635 F51D 4C 8E F8			JMP	SLC	;set logical column, return
 14636 					;SPACE	4,10
 14637 				;	DLN - Delete Line
 14638 				*
 14639 				*	ENTRY	JSR	DLN
 14640 				*
 14641 				*	MODS
 14642 				*		Original Author Unknown
 14643 				*		1. Bring closer to Coding Standard (object unchanged).
 14644 				*		   R. K. Nordin	11/01/83
 14645
 14646
 14647 = F520			DLN	=	*	;entry
 14648 F520 20 8E F8			JSR	SLC	;set logical column
 14649 F523 A4 51			LDY	HOLD1
 14650 F525 84 54			STY	ROWCRS	;cursor row
 14651 				;	JMP	DLN1
 14652 					;SPACE	4,10
 14653 				;	DLN1 - Delete Line
 14654 				*
 14655 				*	ENTRY	JSR	DLN1
 14656 				*
 14657 				*	MODS
 14658 				*		Original Author Unknown
 14659 				*		1. Bring closer to Coding Standard (object unchanged).
 14660 				*		   R. K. Nordin	11/01/83
 14661
 14662
 14663 = F527			DLN1	=	*		;entry
 14664
 14665 F527 A4 54		DLN0	LDY	ROWCRS		;cursor row
 14666
 14667 F529 98			DLN2	TYA
 14668 F52A 38				SEC
 14669 F52B 20 5B F7			JSR	BLG2		;get next bit
 14670 F52E 08				PHP
 14671 F52F 98				TYA
 14672 F530 18				CLC
 14673 F531 69 78			ADC	#8*[LOGMAP-TABMAP]	;add offset for log:
 14674 F533 28				PLP
 14675 F534 20 3C F7			JSR	BMP		;put bit in bit map
 14676 F537 C8				INY
 14677 F538 C0 18			CPY	#24
 14678 F53A D0 ED			BNE	DLN2		;if not done
 14679
 14680 F53C AD B4 02			LDA	LOGMAP+2
 14681 F53F 09 01			ORA	#1		;set least significant bit
 14682 F541 8D B4 02			STA	LOGMAP+2	;update logical line bit ma:
 14683 F544 A9 00			LDA	#0		;delete line of data
 14684 F546 85 55			STA	COLCRS		;low cursor column
 14685 F548 20 AC F5			JSR	CCA		;convert cursor row/column :
 14686 F54B 20 2A F8			JSR	SSD		;scroll screen for delete
 14687
 14688 				;	Check for new logical line.
 14689
 14690 F54E 20 58 F7			JSR	BLG		;get bit from logical line :
 14691 F551 90 D4			BCC	DLN0		;if not new logical line
 14692
 14693 				;	Move cursor to left margin.
 14694
 14695 F553 4C 1B F4			JMP	CLM		;move cursor to left margin:
 14696 					;SPACE	4,10
 14697 				;	BEL - Sound Bell
 14698 				*
 14699 				*	ENTRY	JSR	BEL
 14700 				*
 14701 				*	MODS
 14702 				*		Original Author Unknown
 14703 				*		1. Bring closer to Coding Standard (object unchanged).
 14704 				*		   R. K. Nordin	11/01/83
 14705
 14706
 14707 = F556			BEL	=	*	;entry
 14708 F556 A0 20			LDY	#$20
 14709
 14710 F558 20 83 F9		BEL1	JSR	SKC	;sound key click
 14711 F55B 88				DEY
 14712 F55C 10 FA			BPL	BEL1	;if not done
 14713
 14714 F55E 60				RTS		;return
 14715 					;SPACE	4,10
 14716 				;	CBT - Move Cursor to Bottom
 14717 				*
 14718 				*	ENTRY	JSR	CBT
 14719 				*
 14720 				*	MODS
 14721 				*		Original Author Unknown
 14722 				*		1. Bring closer to Coding Standard (object unchanged).
 14723 				*		   R. K. Nordin	11/01/83
 14724
 14725
 14726 = F55F			CBT	=	*	;entry
 14727 F55F 20 40 F4			JSR	CHM	;move cursor home
 14728 F562 4C E6 F3			JMP	CUP	;move cursor up, return
 14729 					;SPACE	4,10
 14730 				;	DDD - Perform Double Byte Double Decrement
 14731 				*
 14732 				*	ENTRY	JSR	DDD
 14733 				*
 14734 				*	MODS
 14735 				*		Original Author Unknown
 14736 				*		1. Bring closer to Coding Standard (object unchanged).
 14737 				*		   R. K. Nordin	11/01/83
 14738
 14739
 14740 = F565			DDD	=	*	;entry
 14741 F565 A9 02			LDA	#2	;indicate subtracting 2
 14742 F567 D0 11			BNE	DBS	;perform double byte subtract, retu:
 14743 					;SPACE	4,10
 14744 				;	SDF - Store Data Indirect for Fine Scrolling
 14745 				*
 14746 				*	ENTRY	JSR	SDF
 14747 				*
 14748 				*	MODS
 14749 				*		Original Author Unknown
 14750 				*		1. Bring closer to Coding Standard (object unchanged).
 14751 				*		   R. K. Nordin	11/01/83
 14752
 14753
 14754 = F569			SDF	=	*	;entry
 14755 F569 AC 6E 02			LDY	FINE
 14756 F56C F0 02			BEQ	SDI	;if not fine scrolling
 14757
 14758 F56E 09 20			ORA	#$20	;enable vertical scroll
 14759 				;	JMP	SDI	;store data indirect, return
 14760 					;SPACE	4,10
 14761 				;	SDI - Store Data Indirect
 14762 				*
 14763 				*	ENTRY	JSR	SDI
 14764 				*
 14765 				*	MODS
 14766 				*		Original Author Unknown
 14767 				*		1. Bring closer to Coding Standard (object unchanged).
 14768 				*		   R. K. Nordin	11/01/83
 14769
 14770
 14771 = F570			SDI	=	*	;entry
 14772
 14773 				;	Check current status.
 14774
 14775 F570 A4 4C			LDY	DSTAT	;status
 14776 F572 30 2B			BMI	DBS3	;if error, return
 14777
 14778 				;	Store data.
 14779
 14780 F574 A0 00			LDY	#0
 14781 F576 91 64			STA	(ADRESS),Y
 14782
 14783 				;	Decrement.
 14784
 14785 				;	JMP	DSD	;perform double byte single decreme:
 14786 					;SPACE	4,10
 14787 				;	DSD - Perform Double Byte Single Decrement
 14788 				*
 14789 				*	ENTRY	JSR	DSD
 14790 				*
 14791 				*	MODS
 14792 				*		Original Author Unknown
 14793 				*		1. Bring closer to Coding Standard (object unchanged).
 14794 				*		   R. K. Nordin	11/01/83
 14795
 14796
 14797 = F578			DSD	=	*	;entry
 14798 F578 A9 01			LDA	#1	;indicate subtracting 1
 14799 				;	JMP	DBS	;perform double byte subtract, retu:
 14800 					;SPACE	4,10
 14801 				;	DBS - Perform Double Byte Subtract
 14802 				*
 14803 				*	ENTRY	JSR	DBS
 14804 				*
 14805 				*	MODS
 14806 				*		Original Author Unknown
 14807 				*		1. Bring closer to Coding Standard (object unchanged).
 14808 				*		   R. K. Nordin	11/01/83
 14809
 14810
 14811 = F57A			DBS	=	*	;entry
 14812
 14813 				;	Initialize.
 14814
 14815 F57A 8D 9E 02			STA	SUBTMP
 14816
 14817 				;	Check current status.
 14818
 14819 F57D A5 4C			LDA	DSTAT		;status
 14820 F57F 30 1E			BMI	DBS3		;if error
 14821
 14822 				;	Subtract.
 14823
 14824 F581 A5 64			LDA	ADRESS
 14825 F583 38				SEC
 14826 F584 ED 9E 02			SBC	SUBTMP
 14827 F587 85 64			STA	ADRESS
 14828 F589 B0 02			BCS	DBS1		;if no borrow
 14829
 14830 F58B C6 65			DEC	ADRESS+1	;adjust high byte
 14831
 14832 				;	Check for overwriting APPMHI.
 14833
 14834 F58D A5 0F		DBS1	LDA	APPMHI+1
 14835 F58F C5 65			CMP	ADRESS+1
 14836 F591 90 0C			BCC	DBS3		;if not overwriting APPMHI
 14837
 14838 F593 D0 06			BNE	DBS2		;if overwriting APPMHI, err:
 14839
 14840 F595 A5 0E			LDA	APPMHI
 14841 F597 C5 64			CMP	ADRESS
 14842 F599 90 04			BCC	DBS3		;if not overwriting APPMHI
 14843
 14844 				;	Process error.
 14845
 14846 F59B A9 93		DBS2	LDA	#SCRMEM		;indicate insufficient memo:
 14847 F59D 85 4C			STA	DSTAT		;status
 14848
 14849 				;	Exit.
 14850
 14851 F59F 60			DBS3	RTS		;return
 14852 					;SPACE	4,10
 14853 				;	SSE - Set Scrolling Display List Entry
 14854 				*
 14855 				*	Store extra line in display list for fine scrolling:
 14856 				*
 14857 				*	ENTRY	JSR	SSE
 14858 				*
 14859 				*	MODS
 14860 				*		H. Stewart	06/01/82
 14861 				*		1. Bring closer to Coding Standard (object unchanged).
 14862 				*		   R. K. Nordin	11/01/83
 14863
 14864
 14865 = F5A0			SSE	=	*	;entry
 14866 F5A0 A9 02			LDA	#$02
 14867 F5A2 20 70 F5			JSR	SDI	;store data indirect
 14868 F5A5 A9 A2			LDA	#$A2	;DLI on last visible line
 14869 F5A7 20 70 F5			JSR	SDI	;store data indirect
 14870 F5AA CA				DEX
 14871 F5AB 60				RTS		;return
 14872 					;SPACE	4,10
 14873 				;	CCA - Convert Cursor Row/Column to Address
 14874 				*
 14875 				*	ENTRY	JSR	CCA
 14876 				*
 14877 				*	MODS
 14878 				*		L. Winner	06/01/82
 14879 				*		1. Bring closer to Coding Standard (object unchanged).
 14880 				*		   R. K. Nordin	11/01/83
 14881
 14882
 14883 = F5AC			CCA	=	*		;entry
 14884 F5AC A2 01			LDX	#1
 14885 F5AE 86 66			STX	MLTTMP		;initialize
 14886 F5B0 CA				DEX
 14887 F5B1 86 65			STX	ADRESS+1	;clear high address
 14888 F5B3 A5 54			LDA	ROWCRS		;cursor row position
 14889 F5B5 0A				ASL		;2 times row position
 14890 F5B6 26 65			ROL	ADRESS+1
 14891 F5B8 0A				ASL		;4 time row position
 14892 F5B9 26 65			ROL	ADRESS+1
 14893 F5BB 65 54			ADC	ROWCRS		;add to get 5 times row pos:
 14894 F5BD 85 64			STA	ADRESS
 14895 F5BF 90 02			BCC	CCA1
 14896
 14897 F5C1 E6 65			INC	ADRESS+1
 14898
 14899 F5C3 A4 57		CCA1	LDY	DINDEX		;mode
 14900 F5C5 BE 6D EE			LDX	TLSC,Y		;left shift count
 14901
 14902 F5C8 06 64		CCA2	ASL	ADRESS		;ADRESS = ADRESS*X
 14903 F5CA 26 65			ROL	ADRESS+1	;divide
 14904 F5CC CA				DEX
 14905 F5CD D0 F9			BNE	CCA2
 14906
 14907 F5CF A5 56			LDA	COLCRS+1	;high cursor column
 14908 F5D1 4A				LSR		;save least significant bit
 14909 F5D2 A5 55			LDA	COLCRS		;low cursor column
 14910 F5D4 BE 9D EE			LDX	TRSC,Y		;right shift count
 14911 F5D7 F0 06			BEQ	CCA4		;if no shift
 14912
 14913 F5D9 6A			CCA3	ROR		;roll in carry
 14914 F5DA 06 66			ASL	MLTTMP		;shift index
 14915 F5DC CA				DEX
 14916 F5DD D0 FA			BNE	CCA3
 14917
 14918 F5DF 65 64		CCA4	ADC	ADRESS		;add address
 14919 F5E1 90 02			BCC	CCA5		;if no carry
 14920
 14921 F5E3 E6 65			INC	ADRESS+1	;adjuct high address
 14922
 14923 F5E5 18			CCA5	CLC
 14924 F5E6 65 58			ADC	SAVMSC		;add saved memory scan coun:
 14925 F5E8 85 64			STA	ADRESS		;update address
 14926 F5EA 85 5E			STA	OLDADR		;save address
 14927 F5EC A5 65			LDA	ADRESS+1
 14928 F5EE 65 59			ADC	SAVMSC+1
 14929 F5F0 85 65			STA	ADRESS+1
 14930 F5F2 85 5F			STA	OLDADR+1
 14931
 14932 F5F4 BE 9D EE			LDX	TRSC,Y
 14933 F5F7 BD 04 FB			LDA	TMSK,X
 14934 F5FA 25 55			AND	COLCRS		;and in low cursor column
 14935 F5FC 65 66			ADC	OPNTMP
 14936 F5FE A8				TAY
 14937 F5FF B9 AC EE			LDA	TDSM-1,Y	;display mask
 14938 F602 8D A0 02			STA	DMASK		;display mask
 14939 F605 85 6F			STA	SHFAMT
 14940 F607 A0 00			LDY	#0
 14941
 14942 F609 60			CCA6	RTS			;return
 14943 					;SPACE	4,10
 14944 				;	SZA - Set Zero Data and Advance Cursor Column
 14945 				*
 14946 				*	ENTRY	JSR	SZA
 14947 				*
 14948 				*	MODS
 14949 				*		Original Author Unknown
 14950 				*		1. Bring closer to Coding Standard (object unchanged).
 14951 				*		   R. K. Nordin	11/01/83
 14952
 14953
 14954 = F60A			SZA	=	*	;entry
 14955 F60A A9 00			LDA	#0
 14956 F60C F0 02			BEQ	SDA	;set data and advance cursor
 14957 					;SPACE	4,10
 14958 				;	SEA - Set EOL Data and Advance Cursor Column
 14959 				*
 14960 				*	ENTRY	JSR	SEA
 14961 				*
 14962 				*	MODS
 14963 				*		Original Author Unknown
 14964 				*		1. Bring closer to Coding Standard (object unchanged).
 14965 				*		   R. K. Nordin	11/01/83
 14966
 14967
 14968 = F60E			SEA	=	*	;entry
 14969 F60E A9 9B			LDA	#EOL	;special case eliminator
 14970 				;	JMP	SDA	;set data and advance cursor, retur:
 14971 					;SPACE	4,10
 14972 				;	SDA - Set Data and Advance Cursor Column
 14973 				*
 14974 				*	ENTRY	JSR	SDA
 14975 				*
 14976 				*	MODS
 14977 				*		Original Author Unknown
 14978 				*		1. Bring closer to Coding Standard (object unchanged).
 14979 				*		   R. K. Nordin	11/01/83
 14980
 14981
 14982 = F610			SDA	=	*	;entry
 14983 F610 85 7D			STA	INSDAT	;set data
 14984 				;	JMP	ACC	;advance cursor column, return
 14985 					;SPACE	4,10
 14986 				;	ACC - Advance Cursor Column
 14987 				*
 14988 				*	ENTRY	JSR	ACC
 14989 				*
 14990 				*	MODS
 14991 				*		Original Author Unknown
 14992 				*		1. Bring closer to Coding Standard (object unchanged).
 14993 				*		   R. K. Nordin	11/01/83
 14994
 14995
 14996 = F612			ACC	=	*		;entry
 14997 F612 E6 63			INC	LOGCOL		;increment logical column
 14998 F614 E6 55			INC	COLCRS		;increment low cursor colum:
 14999 F616 D0 02			BNE	ACC1		;if no carry
 15000
 15001 F618 E6 56			INC	COLCRS+1	;adjust high cursor column
 15002
 15003 F61A A5 55		ACC1	LDA	COLCRS		;low cursor column
 15004 F61C A6 57			LDX	DINDEX		;mode
 15005 F61E DD 7D EE			CMP	TMCC,X
 15006 F621 F0 0A			BEQ	ACC2		;if equal, process EOL
 15007
 15008 F623 E0 00			CPX	#0
 15009 F625 D0 E2			BNE	CCA6		;if not mode 0, exit
 15010
 15011 F627 C5 53			CMP	RMARGN		;right margin
 15012 F629 F0 DE			BEQ	CCA6		;if at right margin, exit
 15013
 15014 F62B 90 DC			BCC	CCA6		;if before right margin, ex:
 15015
 15016 F62D E0 08		ACC2	CPX	#8
 15017 F62F D0 04			BNE	ACC3		;if not mode 8
 15018
 15019 F631 A5 56			LDA	COLCRS+1	;high cursor column
 15020 F633 F0 D4			BEQ	CCA6		;if only at 64
 15021
 15022 F635 A5 57		ACC3	LDA	DINDEX		;mode
 15023 F637 D0 2C			BNE	RET		;if mode 0, exit
 15024
 15025 F639 A5 63			LDA	LOGCOL		;logical column
 15026 F63B C9 51			CMP	#81
 15027 F63D 90 0A			BCC	ACC4		;if < 81, definitely not li:
 15028
 15029 F63F A5 7D			LDA	INSDAT
 15030 F641 F0 22			BEQ	RET		;if non-zero, do not do log:
 15031
 15032 F643 20 61 F6			JSR	RWS		;return with scrolling
 15033 F646 4C AB F6			JMP	RET5		;return
 15034
 15035 F649 20 65 F6		ACC4	JSR	RET		;return
 15036 F64C A5 54			LDA	ROWCRS		;cursor row
 15037 F64E 18				CLC
 15038 F64F 69 78			ADC	#8*[LOGMAP-TABMAP]	;add offset for log:
 15039 F651 20 5D F7			JSR	BMG		;ger bit from bit map
 15040 F654 90 08			BCC	ACC5
 15041
 15042 F656 A5 7D			LDA	INSDAT
 15043 F658 F0 04			BEQ	ACC5		;if zero, do not extend
 15044
 15045 F65A 18				CLC
 15046 F65B 20 0D F5			JSR	ILN1		;insert line
 15047
 15048 F65E 4C 8E F8		ACC5	JMP	SLC		;set logical column, return
 15049 					;SPACE	4,10
 15050 				;	RWS - Return with Scrolling
 15051 				*
 15052 				*	ENTRY	JSR	RWS
 15053 				*
 15054 				*	MODS
 15055 				*		Original Author Unknown
 15056 				*		1. Bring closer to Coding Standard (object unchanged).
 15057 				*		   R. K. Nordin	11/01/83
 15058
 15059
 15060 = F661			RWS	=	*	;entry
 15061 F661 A9 9B			LDA	#EOL	;select scrolling
 15062 F663 85 7D			STA	INSDAT
 15063 				;	JMP	RET	;return, return .
 15064 					;SPACE	4,10
 15065 				;	RET - Return
 15066 				*
 15067 				*	ENTRY	JSR	RET
 15068 				*
 15069 				*	MODS
 15070 				*		Original Author Unknown
 15071 				*		1. Bring closer to Coding Standard (object unchanged).
 15072 				*		   R. K. Nordin	11/01/83
 15073
 15074
 15075 = F665			RET	=	*		;entry
 15076 F665 20 97 F9			JSR	SCL		;set cursor at left edge
 15077 F668 A9 00			LDA	#0
 15078 F66A 85 56			STA	COLCRS+1	;high cursor column
 15079 F66C E6 54			INC	ROWCRS		;increment cursor row
 15080 F66E A6 57			LDX	DINDEX
 15081 F670 A0 18			LDY	#24		;assume 24 lines
 15082 F672 24 7B			BIT	SWPFLG
 15083 F674 10 05			BPL	RET1		;if normal
 15084
 15085 F676 A0 04			LDY	#4		;substitute 4 lines
 15086 F678 98				TYA
 15087 F679 D0 03			BNE	RET2
 15088
 15089 F67B BD 8D EE		RET1	LDA	TMRC,X	;mode row count
 15090
 15091 F67E C5 54		RET2	CMP	ROWCRS	;cursor row
 15092 F680 D0 29			BNE	RET5
 15093
 15094 F682 8C 9D 02			STY	HOLD3
 15095 F685 8A				TXA		;mode
 15096 F686 D0 23			BNE	RET5	;if mode not 0, do not scroll
 15097
 15098 F688 A5 7D			LDA	INSDAT
 15099 F68A F0 1F			BEQ	RET5	;if zero, do not scroll
 15100
 15101 				;	If EOL, roll in a 0.
 15102
 15103 F68C C9 9B			CMP	#EOL	;to extend bottom logical line
 15104 F68E F0 01			BEQ	RET3	;if EOL
 15105
 15106 F690 18				CLC
 15107
 15108 F691 20 F7 F7		RET3	JSR	SCR
 15109 F694 EE BB 02			INC	SCRFLG
 15110 F697 C6 6C			DEC	BUFSTR
 15111 F699 10 02			BPL	RET4
 15112
 15113 F69B E6 6C			INC	BUFSTR
 15114
 15115 F69D CE 9D 02		RET4	DEC	HOLD3
 15116 F6A0 AD B2 02			LDA	LOGMAP
 15117 F6A3 38				SEC		;indicate for partial line
 15118 F6A4 10 EB			BPL	RET3	;if partial logical line
 15119
 15120 F6A6 AD 9D 02			LDA	HOLD3
 15121 F6A9 85 54			STA	ROWCRS	;cursor row
 15122
 15123 F6AB 4C 8E F8		RET5	JMP	SLC	;set logical column, return
 15124 					;SPACE	4,10
 15125 				;	SEP - Subtract End Point
 15126 				*
 15127 				*	ENTRY	JSR	SEP
 15128 				*		X = 0, if row or 2, if column
 15129 				*
 15130 				*	MODS
 15131 				*		Original Author Unknown
 15132 				*		1. Bring closer to Coding Standard (object unchanged).
 15133 				*		   R. K. Nordin	11/01/83
 15134
 15135
 15136 = F6AE			SEP	=	*		;entry
 15137 F6AE 38				SEC
 15138 F6AF B5 70			LDA	ROWAC,X		;low value from which to su:
 15139 F6B1 E5 74			SBC	ENDPT
 15140 F6B3 95 70			STA	ROWAC,X		;new low value
 15141 F6B5 B5 71			LDA	ROWAC+1,X	;hogh value from which to s:
 15142 F6B7 E5 75			SBC	ENDPT+1
 15143 F6B9 95 71			STA	ROWAC+1,X	;new high value
 15144 F6BB 60				RTS			;return
 15145 					;SPACE	4,10
 15146 				;	CRE - Check Cursor Range for Editor
 15147 				*
 15148 				*	ENTRY	JSR	SEP
 15149 				*
 15150 				*	MODS
 15151 				*		Original Author Unknown
 15152 				*		1. Bring closer to Coding Standard (object unchanged).
 15153 				*		   R. K. Nordin	11/01/83
 15154
 15155
 15156 = F6BC			CRE	=	*	;entry
 15157
 15158 				;	Check for mixed mode.
 15159
 15160 F6BC AD BF 02			LDA	BOTSCR
 15161 F6BF C9 04			CMP	#4	;mixed mode indicator
 15162 F6C1 F0 07			BEQ	CCR	;if mixed mode, check cursor range,:
 15163
 15164 				;	Check for mode 0.
 15165
 15166 F6C3 A5 57			LDA	DINDEX	;mode
 15167 F6C5 F0 03			BEQ	CCR	;if mode 0, check ursor usage
 15168
 15169 				;	Open editor.
 15170
 15171 F6C7 20 94 EF			JSR	EOP	;perform editor OPEN
 15172 				;	JMP	CCR	;check cursor range, return
 15173 					;SPACE	4,10
 15174 				;	CCR - Check Cursor Range
 15175 				*
 15176 				*	ENTRY	JSR	CCR
 15177 				*
 15178 				*	MODS
 15179 				*		Original Author Unknown
 15180 				*		1. Bring closer to Coding Standard (object unchanged).
 15181 				*		   R. K. Nordin	11/01/83
 15182
 15183
 15184 = F6CA			CCR	=	*		;entry
 15185 F6CA A9 27			LDA	#39
 15186 F6CC C5 53			CMP	RMARGN		;right margin
 15187 F6CE B0 02			BCS	CCR1		;if 39 >= right margin
 15188
 15189 F6D0 85 53			STA	RMARGN		;set right margin
 15190
 15191 F6D2 A6 57		CCR1	LDX	DINDEX
 15192 F6D4 BD 8D EE			LDA	TMRC,X		;mode row count
 15193 F6D7 C5 54			CMP	ROWCRS		;cursor row
 15194 F6D9 90 2A			BCC	CCR5		;if count > row position, e:
 15195
 15196 F6DB F0 28			BEQ	CCR5		;if count = row position, e:
 15197
 15198 F6DD E0 08			CPX	#8
 15199 F6DF D0 0A			BNE	CCR2		;if not mode 8
 15200
 15201 F6E1 A5 56			LDA	COLCRS+1	;high cursor column
 15202 F6E3 F0 13			BEQ	CCR4		;if high cursor column zero
 15203
 15204 F6E5 C9 01			CMP	#1
 15205 F6E7 D0 1C			BNE	CCR5		;if >1, bad
 15206
 15207 F6E9 F0 04			BEQ	CCR3		;if 1, check low
 15208
 15209 F6EB A5 56		CCR2	LDA	COLCRS+1	;high cursor column
 15210 F6ED D0 16			BNE	CCR5		;if high cursor column non-:
 15211
 15212 F6EF BD 7D EE		CCR3	LDA	TMCC,X		;mode column count
 15213 F6F2 C5 55			CMP	COLCRS		;low cursor column
 15214 F6F4 90 0F			BCC	CCR5		;if count > column position:
 15215
 15216 F6F6 F0 0D			BEQ	CCR5		;if count = column position:
 15217
 15218 F6F8 A9 01		CCR4	LDA	#SUCCES		;success indicator
 15219 F6FA 85 4C			STA	DSTAT		;indicate success
 15220 F6FC A9 80			LDA	#BRKABT		;assume BREAK abort
 15221 F6FE A6 11			LDX	BRKKEY		;BREAK key status
 15222 F700 85 11			STA	BRKKEY		;clear BREAK key status
 15223 F702 F0 06			BEQ	CCR6		;if BREAK
 15224
 15225 F704 60				RTS			;return
 15226
 15227 				;	Process range error.
 15228
 15229 F705 20 40 F4		CCR5	JSR	CHM		;move cursor home
 15230 F708 A9 8D			LDA	#CRSROR		;indicate cursor overrange
 15231
 15232 				;	Exit.
 15233
 15234 F70A 85 4C		CCR6	STA	DSTAT		;status
 15235 F70C 68				PLA			;clean stack for return to :
 15236 F70D 68				PLA
 15237 F70E A5 7B			LDA	SWPFLG
 15238 F710 10 03			BPL	CCR7		;if not swapped
 15239
 15240 F712 4C 62 F9			JMP	SWA		;swap, return
 15241
 15242 F715 4C 1E F2		CCR7	JMP	SST		;return (to CIO)
 15243 					;SPACE	4,10
 15244 				;	ROD - Restore Old Data under Cursor
 15245 				*
 15246 				*	ENTRY	JSR	ROD
 15247 				*
 15248 				*	MODS
 15249 				*		Original Author Unknown
 15250 				*		1. Bring closer to Coding Standard (object unchanged).
 15251 				*		   R. K. Nordin	11/01/83
 15252
 15253
 15254 = F718			ROD	=	*		;entry
 15255 F718 A0 00			LDY	#0
 15256 F71A A5 5F			LDA	OLDADR+1
 15257 F71C F0 04			BEQ	ROD1		;if page zero
 15258
 15259 F71E A5 5D			LDA	OLDCHR		;old data
 15260 F720 91 5E			STA	(OLDADR),Y
 15261
 15262 F722 60			ROD1	RTS			;return
 15263 					;SPACE	4,10
 15264 				;	BMI - Initialize for Bit Map Operation
 15265 				*
 15266 				*	BMI sets the bit mask in BITMSK and byte offset in :
 15267 				*
 15268 				*	ENTRY	JSR	BMI
 15269 				*
 15270 				*	MODS
 15271 				*		Original Author Unknown
 15272 				*		1. Bring closer to Coding Standard (object unchanged).
 15273 				*		   R. K. Nordin	11/01/83
 15274
 15275
 15276 = F723			BMI	=	*	;entry
 15277 F723 48				PHA		;save logical column
 15278 F724 29 07			AND	#7	;logical column modulo 8
 15279 F726 AA				TAX		;offset to bit mask
 15280 F727 BD B4 EE			LDA	TBTM,X	;bit mask
 15281 F72A 85 6E			STA	BITMSK	;set bit mask
 15282 F72C 68				PLA		;logical column
 15283 F72D 4A				LSR
 15284 F72E 4A				LSR
 15285 F72F 4A				LSR	;logical column divided by 8
 15286 F730 AA				TAX		;offset
 15287 F731 60				RTS		;return
 15288 					;SPACE	4,10
 15289 				;	BLR - Rotate Logical Line Bit Map Left
 15290 				*
 15291 				*	BLR rotates the logical line bit map left, scrollin:
 15292 				*	logical lines up.
 15293 				*
 15294 				*	ENTRY	JSR	BLR
 15295 				*
 15296 				*	MODS
 15297 				*		Original Author Unknown
 15298 				*		1. Bring closer to Coding Standard (object unchanged).
 15299 				*		   R. K. Nordin	11/01/83
 15300
 15301
 15302 = F732			BLR	=	*		;entry
 15303 F732 2E B4 02			ROL	LOGMAP+2
 15304 F735 2E B3 02			ROL	LOGMAP+1
 15305 F738 2E B2 02			ROL	LOGMAP
 15306 F73B 60				RTS			;return
 15307 					;SPACE	4,10
 15308 				;	BMP - Put Bit in Bit Map
 15309 				*
 15310 				*	PUT CARRY INTO BITMAP
 15311 				*
 15312 				*	ENTRY	JSR	BMP
 15313 				*
 15314 				*	MODS
 15315 				*		Original Author Unknown
 15316 				*		1. Bring closer to Coding Standard (object unchanged).
 15317 				*		   R. K. Nordin	11/01/83
 15318
 15319
 15320 = F73C			BMP	=	*	;entry
 15321 F73C 90 0C			BCC	BMC	;if C clear, clear bit in bit map,:
 15322
 15323 				;	JMP	BMS	;set bit in bit map, return
 15324 					;SPACE	4,10
 15325 				;	BMS - Set Bit in Bit Map
 15326 				*
 15327 				*	ENTRY	JSR	BMS
 15328 				*
 15329 				*	MODS
 15330 				*		Original Author Unknown
 15331 				*		1. Bring closer to Coding Standard (object unchanged).
 15332 				*		   R. K. Nordin	11/01/83
 15333
 15334
 15335 = F73E			BMS	=	*		;entry
 15336 F73E 20 23 F7			JSR	BMI		;initialize for bit mask op:
 15337 F741 BD A3 02			LDA	TABMAP,X
 15338 F744 05 6E			ORA	BITMSK		;set bit
 15339 F746 9D A3 02			STA	TABMAP,X	;update bit map
 15340 F749 60				RTS			;return
 15341 					;SPACE	4,10
 15342 				;	BMC - Clear Bit in Bit Map
 15343 				*
 15344 				*	ENTRY	JSR	BMC
 15345 				*
 15346 				*	MODS
 15347 				*		Original Author Unknown
 15348 				*		1. Bring closer to Coding Standard (object unchanged).
 15349 				*		   R. K. Nordin	11/01/83
 15350
 15351
 15352 = F74A			BMC	=	*		;entry
 15353 F74A 20 23 F7			JSR	BMI		;initialize for bit mask op:
 15354 F74D A5 6E			LDA	BITMSK
 15355 F74F 49 FF			EOR	#$FF
 15356 F751 3D A3 02			AND	TABMAP,X	;clear bit
 15357 F754 9D A3 02			STA	TABMAP,X	;update bit map
 15358 F757 60				RTS			;return
 15359 					;SPACE	4,10
 15360 				;	BLG - Get Bit from Logical Line Bit Map
 15361 				*
 15362 				*	ENTRY	JSR	BLG
 15363 				*
 15364 				*	MODS
 15365 				*		Original Author Unknown
 15366 				*		1. Bring closer to Coding Standard (object unchanged).
 15367 				*		   R. K. Nordin	11/01/83
 15368
 15369
 15370 = F758			BLG	=	*	;entry
 15371 F758 A5 54			LDA	ROWCRS	;cursor row
 15372 				;	JMP	BLG1
 15373 					;SPACE	4,10
 15374 				;	BLG1 - Get Bit from Logical Line Bit Map
 15375 				*
 15376 				*	ENTRY	JSR	BLG1
 15377 				*
 15378 				*	MODS
 15379 				*		Original Author Unknown
 15380 				*		1. Bring closer to Coding Standard (object unchanged).
 15381 				*		   R. K. Nordin	11/01/83
 15382
 15383
 15384 = F75A			BLG1	=	*	;entry
 15385 F75A 18				CLC
 15386 				;	JMP	BLG2
 15387 					;SPACE	4,10
 15388 				;	BLG2 - Get Bit from Logical Line Bit Map
 15389 				*
 15390 				*	ENTRY	JSR	BLG2
 15391 				*
 15392 				*	MODS
 15393 				*		Original Author Unknown
 15394 				*		1. Bring closer to Coding Standard (object unchanged).
 15395 				*		   R. K. Nordin	11/01/83
 15396
 15397
 15398 = F75B			BLG2	=	*	;entry
 15399 F75B 69 78			ADC	#8*[LOGMAP-TABMAP]	;add offset for log:
 15400 				;	JMP	BMG	;get bit from bit map, return
 15401 					;SPACE	4,10
 15402 				;	BMG - Get Bit from Bit Map
 15403 				*
 15404 				*	ENTRY	JSR	BMG
 15405 				*
 15406 				*	MODS
 15407 				*		Original Author Unknown
 15408 				*		1. Bring closer to Coding Standard (object unchanged).
 15409 				*		   R. K. Nordin	11/01/83
 15410
 15411
 15412 = F75D			BMG	=	*	;entry
 15413 F75D 20 23 F7			JSR	BMI	;initialize for bit mask operation
 15414 F760 18				CLC
 15415 F761 BD A3 02			LDA	TABMAP,X
 15416 F764 25 6E			AND	BITMSK
 15417 F766 F0 01			BEQ	BMG1
 15418
 15419 F768 38				SEC
 15420
 15421 F769 60			BMG1	RTS		;return
 15422 					;SPACE	4,10
 15423 				;	CIA - Convert Internal Character to ATASCII
 15424 				*
 15425 				*	ENTRY	JSR	CIA
 15426 				*
 15427 				*	MODS
 15428 				*		Original Author Unknown
 15429 				*		1. Bring closer to Coding Standard (object unchanged).
 15430 				*		   R. K. Nordin	11/01/83
 15431
 15432
 15433 = F76A			CIA	=	*	;entry
 15434
 15435 				;	Initialize.
 15436
 15437 F76A AD FA 02			LDA	CHAR
 15438
 15439 				;	Check mode.
 15440
 15441 F76D A4 57			LDY	DINDEX	;mode
 15442 F76F C0 0E			CPY	#14
 15443 F771 B0 17			BCS	CIA2	;if mode >= 14
 15444
 15445 F773 C0 0C			CPY	#12
 15446 F775 B0 04			BCS	CIA1	;if mode 12 or 13
 15447
 15448 F777 C0 03			CPY	#3
 15449 F779 B0 0F			BCS	CIA2	;if mode >= 3
 15450
 15451 				;	Convert internal character to ATASCII.
 15452
 15453 F77B 2A			CIA1	ROL
 15454 F77C 2A				ROL
 15455 F77D 2A				ROL
 15456 F77E 2A				ROL
 15457 F77F 29 03			AND	#3
 15458 F781 AA				TAX
 15459 F782 AD FA 02			LDA	CHAR	;character
 15460 F785 29 9F			AND	#$9F	;strip off cloumn address
 15461 F787 1D 4D FB			ORA	TIAC,X	;or in new column address
 15462
 15463 				;	Exit.
 15464
 15465 F78A 8D FB 02		CIA2	STA	ATACHR	;ATASCII character
 15466
 15467 F78D 60			CIA3	RTS		;return
 15468 					;SPACE	4,10
 15469 				;	MLN - Move Line
 15470 				*
 15471 				*	ENTRY	JSR	MLN
 15472 				*
 15473 				*	MODS
 15474 				*		Original Author Unknown
 15475 				*		1. Bring closer to Coding Standard (object unchanged).
 15476 				*		   R. K. Nordin	11/01/83
 15477
 15478
 15479 = F78E			MLN	=	*		;entry
 15480
 15481 				; Initialize.
 15482
 15483 F78E A6 6A			LDX	RAMTOP		;(high) RAM size
 15484 F790 CA				DEX			;decrement (high) RAM size
 15485 F791 86 69			STX	FRMADR+1	;high source address
 15486 F793 86 67			STX	TOADR+1		;high destination address
 15487 F795 A9 B0			LDA	#<[$0000-80]	;low RAM size - 80
 15488 F797 85 68			STA	FRMADR		;low source address
 15489 F799 A9 D8			LDA	#<[$0000-40]	;low RAM size - 40
 15490 F79B 85 66			STA	TOADR		;low destination address
 15491
 15492 F79D A6 54			LDX	ROWCRS		;cursor row
 15493
 15494 				;	Check for completion.
 15495
 15496 F79F E8			MLN1	INX
 15497 F7A0 EC BF 02			CPX	BOTSCR		;screen bottom
 15498 F7A3 F0 E8			BEQ	CIA3		;if done, return
 15499
 15500 				;	Move line.
 15501
 15502 F7A5 A0 27			LDY	#39		;offset to last byte
 15503
 15504 F7A7 B1 68		MLN2	LDA	(FRMADR),Y	;byte of source
 15505 F7A9 91 66			STA	(TOADR),Y	;byte of destination
 15506 F7AB 88				DEY
 15507 F7AC 10 F9			BPL	MLN2		;if not done
 15508
 15509 				;	Adjust source and destination addresses.
 15510
 15511 F7AE 38				SEC
 15512 F7AF A5 68			LDA	FRMADR		;source address
 15513 F7B1 85 66			STA	TOADR		;update destination address
 15514 F7B3 E9 28			SBC	#<40		;subtract 40
 15515 F7B5 85 68			STA	FRMADR		;update.source address
 15516 F7B7 A5 69			LDA	FRMADR+1
 15517 F7B9 85 67			STA	TOADR+1
 15518 F7BB E9 00			SBC	#>40
 15519 F7BD 85 69			STA	FRMADR+1
 15520
 15521 				;	Continue.
 15522
 15523 F7BF 4C 9F F7			JMP	MLN1		;continue
 15524 					;SPACE	4,10
 15525 				;	ELL - Extend Logical Line
 15526 				*
 15527 				*	ENTRY	JSR	ELL
 15528 				*
 15529 				*	MODS
 15530 				*		Original Author Unknown
 15531 				*		1. Bring closer to Coding Standard (object unchanged).
 15532 				*		   R. K. Nordin	11/01/83
 15533
 15534
 15535 = F7C2			ELL	=	*	;entry
 15536 F7C2 08				PHP		;save bit
 15537 F7C3 A0 16			LDY	#22
 15538
 15539 F7C5 98			ELL1	TYA
 15540 F7C6 20 5A F7			JSR	BLG1
 15541 F7C9 08				PHP
 15542 F7CA 98				TYA
 15543 F7CB 18				CLC
 15544 F7CC 69 79			ADC	#8*[LOGMAP-TABMAP]+1	;add offset for log:
 15545 F7CE 28				PLP
 15546 F7CF 20 3C F7			JSR	BMP	;put bit in bit map
 15547 F7D2 88				DEY
 15548 F7D3 30 04			BMI	ELL2
 15549
 15550 F7D5 C4 54			CPY	ROWCRS	;cursor row
 15551 F7D7 B0 EC			BCS	ELL1
 15552
 15553 F7D9 A5 54		ELL2	LDA	ROWCRS	;cursor row
 15554 F7DB 18				CLC
 15555 F7DC 69 78			ADC	#8*[LOGMAP-TABMAP]	;add offset for log:
 15556 F7DE 28				PLP
 15557 F7DF 4C 3C F7			JMP	BMP	;put bit in bit map, return
 15558 					;SPACE	4,10
 15559 				;	CLN - Clear Line
 15560 				*
 15561 				*	ENTRY	JSR	CLN
 15562 				*
 15563 				*	MODS
 15564 				*		Original Author Unknown
 15565 				*		1. Bring closer to Coding Standard (object unchanged).
 15566 				*		   R. K. Nordin	11/01/83
 15567
 15568
 15569 = F7E2			CLN	=	*	;entry
 15570 F7E2 A5 52			LDA	LMARGN	;left margin
 15571 F7E4 85 55			STA	COLCRS	;low cursor column
 15572 F7E6 20 AC F5			JSR	CCA	;convert cursor row/column to addre:
 15573 F7E9 38				SEC
 15574 F7EA A5 53			LDA	RMARGN	;right margin
 15575 F7EC E5 52			SBC	LMARGN	;subtract left margin
 15576 F7EE A8				TAY		;screen width
 15577 F7EF A9 00			LDA	#0
 15578
 15579 F7F1 91 64		CLN1	STA	(ADRESS),Y
 15580 F7F3 88				DEY
 15581 F7F4 10 FB			BPL	CLN1	;if not done
 15582
 15583 F7F6 60				RTS		;return
 15584 					;SPACE	4,10
 15585 				;	SCR - Scroll
 15586 				*
 15587 				*	ENTRY	JSR	SCR
 15588 				*
 15589 				*	MODS
 15590 				*		Original Author Unknown
 15591 				*		1. Bring closer to Coding Standard (object unchanged).
 15592 				*		   R. K. Nordin	11/01/83
 15593
 15594
 15595 = F7F7			SCR	=	*	;entry
 15596
 15597 				;	Initialize.
 15598
 15599 F7F7 20 32 F7			JSR	BLR	;rotate logical line bit map left
 15600
 15601 				;	Check for fine scrolling.
 15602
 15603 F7FA AD 6E 02			LDA	FINE
 15604 F7FD F0 28			BEQ	SCR5	;if not fine scrolling
 15605
 15606 F7FF AD 6C 02		SCR1	LDA	VSFLAG	;vertical scroll count
 15607 F802 D0 FB			BNE	SCR1	;if prior scroll not yet done
 15608
 15609 F804 A9 08			LDA	#8
 15610 F806 8D 6C 02			STA	VSFLAG	;vertical scroll count
 15611
 15612 				;	Wait forscroll to complete.
 15613
 15614 F809 AD 6C 02		SCR2	LDA	VSFLAG	;vertical scroll count
 15615 F80C C9 01			CMP	#1	;start of last scan
 15616 F80E D0 F9			BNE	SCR2	;if not done waiting
 15617
 15618 F810 AD 0B D4		SCR3	LDA	VCOUNT
 15619 F813 C9 40			CMP	#$40
 15620 F815 B0 F9			BCS	SCR3	;if not done waiting for safe place
 15621
 15622 F817 A2 0D			LDX	#$0D
 15623 F819 AD BF 02			LDA	BOTSCR
 15624 F81C C9 04			CMP	#4
 15625 F81E D0 02			BNE	SCR4	;if not split screen
 15626
 15627 F820 A2 70			LDX	#$70
 15628
 15629 F822 EC 0B D4		SCR4	CPX	VCOUNT
 15630 F825 B0 FB			BCS	SCR4	;if not done waiting
 15631
 15632 				;	Exit.
 15633
 15634 F827 20 A6 F9		SCR5	JSR	SMS	;set memory scan counter address
 15635 				;	JMP	SSD	;scroll screen for delete, return
 15636 					;SPACE	4,10
 15637 				;	SSD - Scroll Screen for Delete
 15638 				*
 15639 				*	ENTRY	JSR	SSD
 15640 				*
 15641 				*	MODS
 15642 				*		Original Author Unknown
 15643 				*		1. Bring closer to Coding Standard (object unchanged).
 15644 				*		   R. K. Nordin	11/01/83
 15645
 15646
 15647 = F82A			SSD	=	*		;entry
 15648
 15649 				;	Initialize
 15650
 15651 F82A A5 64			LDA	ADRESS		;address
 15652 F82C A6 65			LDX	ADRESS+1
 15653
 15654 				;	Calculate number of bytes to move.
 15655
 15656 F82E E8			SSD1	INX
 15657 F82F E4 6A			CPX	RAMTOP
 15658 F831 F0 06			BEQ	SSD2		;if at RAMTOP
 15659
 15660 F833 38				SEC
 15661 F834 E9 10			SBC	#$10
 15662 F836 4C 2E F8			JMP	SSD1		;continue
 15663
 15664 F839 69 27		SSD2	ADC	#39		;(CLC and ADC #40)
 15665 F83B D0 0A			BNE	SSD3		;if byte count non-zero
 15666
 15667 F83D A6 65			LDX	ADRESS+1
 15668 F83F E8				INX
 15669 F840 E4 6A			CPX	RAMTOP
 15670 F842 F0 38			BEQ	SSD6		;if at RAMTOP
 15671
 15672 F844 18				CLC
 15673 F845 69 10			ADC	#$10
 15674
 15675 				;	Adjust address.
 15676
 15677 F847 A8			SSD3	TAY			;number of bytes
 15678 F848 85 7E			STA	COUNTR
 15679 F84A 38				SEC
 15680 F84B A5 64			LDA	ADRESS
 15681 F84D E5 7E			SBC	COUNTR		;subtract
 15682 F84F 85 64			STA	ADRESS		;update low address
 15683 F851 B0 02			BCS	SSD4		;if no borrow
 15684
 15685 F853 C6 65			DEC	ADRESS+1	;adjust high address
 15686
 15687 				;	Move data down.
 15688
 15689 F855 A5 64		SSD4	LDA	ADRESS
 15690 F857 18				CLC
 15691 F858 69 28			ADC	#40
 15692 F85A 85 7E			STA	COUNTR		;address + 40
 15693 F85C A5 65			LDA	ADRESS+1
 15694 F85E 69 00			ADC	#0
 15695 F860 85 7F			STA	COUNTR+1
 15696
 15697 F862 B1 7E		SSD5	LDA	(COUNTR),Y	;byte to move
 15698 F864 91 64			STA	(ADRESS),Y	;move byte
 15699 F866 C8				INY
 15700 F867 D0 F9			BNE	SSD5		;if not done (256-=16 times)
 15701
 15702 F869 A0 10			LDY	#256-240
 15703 F86B A5 64			LDA	ADRESS
 15704 F86D C9 D8			CMP	#-40
 15705 F86F F0 0B			BEQ	SSD6		;if all done
 15706
 15707 F871 18				CLC
 15708 F872 69 F0			ADC	#240
 15709 F874 85 64			STA	ADRESS		;update low address
 15710 F876 90 DD			BCC	SSD4		;if no carry
 15711
 15712 F878 E6 65			INC	ADRESS+1	;adjust high address
 15713 F87A D0 D9			BNE	SSD4		;continue
 15714
 15715 				;	Clear last line.
 15716
 15717 F87C A6 6A		SSD6	LDX	RAMTOP
 15718 F87E CA				DEX
 15719 F87F 86 7F			STX	COUNTR+1
 15720 F881 A2 D8			LDX	#-40
 15721 F883 86 7E			STX	COUNTR
 15722 F885 A9 00			LDA	#0
 15723 F887 A0 27			LDY	#39
 15724
 15725 F889 91 7E		SSD7	STA	(COUNTR),Y	;clear byte of last line
 15726 F88B 88				DEY
 15727 F88C 10 FB			BPL	SSD7		;if not done
 15728
 15729 				;	JMP	SLC		;set logical column, return
 15730 					;SPACE	4,10
 15731 				;	SLC - Set Logical Column
 15732 				*
 15733 				*	ENTRY	JSR	SLC
 15734 				*
 15735 				*	MODS
 15736 				*		Original Author Unknown
 15737 				*		1. Bring closer to Coding Standard (object unchanged).
 15738 				*		   R. K. Nordin	11/01/83
 15739
 15740
 15741 = F88E			SLC	=	*	;entry
 15742
 15743 				;	Initialize.
 15744
 15745 F88E A9 00			LDA	#0
 15746 F890 85 63			STA	LOGCOL	;initialize logical column
 15747 F892 A5 54			LDA	ROWCRS	;cursor row
 15748 F894 85 51			STA	HOLD1	;working row
 15749
 15750 				;	Search for beginning of line.
 15751
 15752 F896 A5 51		SLC1	LDA	HOLD1	;add in row component
 15753 F898 20 5A F7			JSR	BLG1
 15754 F89B B0 0C			BCS	SLC2	;if beginning of line found
 15755
 15756 F89D A5 63			LDA	LOGCOL	;logical column
 15757 F89F 18				CLC
 15758 F8A0 69 28			ADC	#40	;add number of characters per line
 15759 F8A2 85 63			STA	LOGCOL	;update logical column
 15760 F8A4 C6 51			DEC	HOLD1	;decrement working row
 15761 F8A6 4C 96 F8			JMP	SLC1	;continue
 15762
 15763 				;	Add in cursor column.
 15764
 15765 F8A9 18			SLC2	CLC
 15766 F8AA A5 63			LDA	LOGCOL	;logical column
 15767 F8AC 65 55			ADC	COLCRS	;add low cursor column
 15768 F8AE 85 63			STA	LOGCOL	;update logical column
 15769 F8B0 60				RTS		;return
 15770 					;SPACE	4,10
 15771 				;	CBC - Compute Buffer Count
 15772 				*
 15773 				*	CBC computes the buffer count as the number of byte:
 15774 				*	buffer start to the end of the logical line (with t:
 15775 				*	spaces removed).
 15776 				*
 15777 				*	ENTRY	JSR	CBC
 15778 				*
 15779 				*	MODS
 15780 				*		Original Author Unknown
 15781 				*		1. Bring closer to Coding Standard (object unchanged).
 15782 				*		   R. K. Nordin	11/01/83
 15783
 15784
 15785 = F8B1			CBC	=	*	;entry
 15786
 15787 				;	Initialize.
 15788
 15789 F8B1 20 4C F9			JSR	SRC		;save row and column
 15790 F8B4 A5 63			LDA	LOGCOL		;logical column
 15791 F8B6 48				PHA			;save logical column
 15792 F8B7 A5 6C			LDA	BUFSTR		;start of buffer
 15793 F8B9 85 54			STA	ROWCRS		;cursor row
 15794 F8BB A5 6D			LDA	BUFSTR+1
 15795 F8BD 85 55			STA	COLCRS		;low cursor column
 15796 F8BF A9 01			LDA	#1
 15797 F8C1 85 6B			STA	BUFCNT		;initialize buffer count
 15798
 15799 				;	Determine last line on screen.
 15800
 15801 F8C3 A2 17		CBC1	LDX	#23		;normal last line on screen
 15802 F8C5 A5 7B			LDA	SWPFLG
 15803 F8C7 10 02			BPL	CBC2		;if not swapped
 15804
 15805 F8C9 A2 03			LDX	#3		;last line on screen
 15806
 15807 				;	Check for cursor on last line of screen.
 15808
 15809 F8CB E4 54		CBC2	CPX	ROWCRS	;cursor row
 15810 F8CD D0 0B			BNE	CBC3	;if cursor on last line
 15811
 15812 F8CF A5 55			LDA	COLCRS	;low cursor column
 15813 F8D1 C5 53			CMP	RMARGN	;right margin
 15814 F8D3 D0 05			BNE	CBC3	;if not at right margin
 15815
 15816 F8D5 E6 6B			INC	BUFCNT	;fake SEA to avoid scrolling
 15817 F8D7 4C EA F8			JMP	CBC4
 15818
 15819 F8DA 20 0A F6		CBC3	JSR	SZA	;set zero data and advance cursor
 15820 F8DD E6 6B			INC	BUFCNT
 15821 F8DF A5 63			LDA	LOGCOL	;logical column
 15822 F8E1 C5 52			CMP	LMARGN	;left margin
 15823 F8E3 D0 DE			BNE	CBC1	;if not yet at left margin
 15824
 15825 F8E5 C6 54			DEC	ROWCRS	;decrement cursor row
 15826 F8E7 20 00 F4			JSR	CLF	;move cursor left
 15827
 15828 F8EA 20 8F F1		CBC4	JSR	GDC	;get data under cursor
 15829 F8ED D0 17			BNE	CBC6	;if non-zero, quit
 15830
 15831 F8EF C6 6B			DEC	BUFCNT	;DECREMENT COUNTER
 15832 F8F1 A5 63			LDA	LOGCOL	;logical column
 15833 F8F3 C5 52			CMP	LMARGN	;left margin
 15834 F8F5 F0 0F			BEQ	CBC6	;if beginning of logical line, exit
 15835
 15836 F8F7 20 00 F4			JSR	CLF	;move cursor left
 15837 F8FA A5 55			LDA	COLCRS	;low cursor column
 15838 F8FC C5 53			CMP	RMARGN	;right margin
 15839 F8FE D0 02			BNE	CBC5	;if cursor column not right margin
 15840
 15841 F900 C6 54			DEC	ROWCRS	;decrement cursor row
 15842
 15843 F902 A5 6B		CBC5	LDA	BUFCNT
 15844 F904 D0 E4			BNE	CBC4	;if BUFCNT non-zero, continue
 15845
 15846 F906 68			CBC6	PLA		;saved logical column
 15847 F907 85 63			STA	LOGCOL	;restore logical column
 15848 F909 4C 57 F9			JMP	RRC	;restore row and column, return
 15849 					;SPACE	4,10
 15850 				;	SBS - Set Bufer Start and Logical Column
 15851 				*
 15852 				*	ENTRY	JSR	SBS
 15853 				*
 15854 				*	MODS
 15855 				*		Original Author Unknown
 15856 				*		1. Bring closer to Coding Standard (object unchanged).
 15857 				*		   R. K. Nordin	11/01/83
 15858
 15859
 15860 = F90C			SBS	=	*		;entry
 15861 F90C 20 8E F8			JSR	SLC		;set logical column
 15862 F90F A5 51			LDA	HOLD1
 15863 F911 85 6C			STA	BUFSTR
 15864 F913 A5 52			LDA	LMARGN		;left margin
 15865 F915 85 6D			STA	BUFSTR+1
 15866
 15867 F917 60			SBS1	RTS			;return
 15868 					;SPACE	4,10
 15869 				;	DQQ - Delete Line
 15870 				*
 15871 				*	ENTRY	JSR	DQQ
 15872 				*
 15873 				*	MODS
 15874 				*		Original Author Unknown
 15875 				*		1. Bring closer to Coding Standard (object unchanged).
 15876 				*		   R. K. Nordin	11/01/83
 15877
 15878
 15879 = F918			DQQ	=	*	;entry
 15880 F918 A5 63			LDA	LOGCOL	;logical column
 15881 F91A C5 52			CMP	LMARGN	;left margin
 15882 F91C D0 02			BNE	DQQ1	;if not at left margin
 15883
 15884 F91E C6 54			DEC	ROWCRS	;decrement cursor row
 15885 F920 20 8E F8		DQQ1	JSR	SLC	;set logical column
 15886 				;	JMP	DWQ
 15887 					;SPACE	4,10
 15888 				;	DWQ - Delete Line
 15889 				*
 15890 				*	ENTRY	JSR	DWQ
 15891 				*
 15892 				*	MODS
 15893 				*		Original Author Unknown
 15894 				*		1. Bring closer to Coding Standard (object unchanged).
 15895 				*		   R. K. Nordin	11/01/83
 15896
 15897
 15898 = F923			DWQ	=	*	;entry
 15899
 15900 				;	Check for left margin.
 15901
 15902 F923 A5 63			LDA	LOGCOL	;logical column
 15903 F925 C5 52			CMP	LMARGN	;left margin
 15904 F927 F0 EE			BEQ	SBS1	;if at left margin, return
 15905
 15906 F929 20 AC F5			JSR	CCA	;convert cursor row/column to addre:
 15907 F92C A5 53			LDA	RMARGN	;right margin
 15908 F92E 38				SEC
 15909 F92F E5 52			SBC	LMARGN	;subtract left margin
 15910 F931 A8				TAY		;offset to last byte
 15911
 15912 F932 B1 64		DWQ1	LDA	(ADRESS),Y
 15913 F934 D0 E1			BNE	SBS1
 15914
 15915 F936 88				DEY
 15916 F937 10 F9			BPL	DWQ1	;if not done
 15917
 15918 F939 4C 27 F5			JMP	DLN1	;delete line, return
 15919 					;SPACE	4,10
 15920 				;	CCC - Check for Control Character
 15921 				*
 15922 				*	ENTRY	JSR	CCC
 15923 				*
 15924 				*	MODS
 15925 				*		Original Author Unknown
 15926 				*		1. Bring closer to Coding Standard (object unchanged).
 15927 				*		   R. K. Nordin	11/01/83
 15928
 15929
 15930 = F93C			CCC	=	*	;entry
 15931
 15932 F93C A2 2D			LDX	#TCCRL-3	;offset to last entry
 15933
 15934 F93E BD 0D FB		CCC1	LDA	TCCR,X		;control character
 15935 F941 CD FB 02			CMP	ATACHR		;ATASCII character
 15936 F944 F0 05			BEQ	CCC2		;if character found, exit
 15937
 15938 F946 CA				DEX
 15939 F947 CA				DEX
 15940 F948 CA				DEX
 15941 F949 10 F3			BPL	CCC1		;if not done, continue sear:
 15942
 15943 F94B 60			CCC2	RTS			;return
 15944 					;SPACE	4,10
 15945 				;	SRC - Save Row and Column
 15946 				*
 15947 				*	ENTRY	JSR	SRC
 15948 				*
 15949 				*	MODS
 15950 				*		Original Author Unknown
 15951 				*		1. Bring closer to Coding Standard (object unchanged).
 15952 				*		   R. K. Nordin	11/01/83
 15953
 15954
 15955 = F94C			SRC	=	*		;entry
 15956 F94C A2 02			LDX	#2		;offset to last byte
 15957
 15958 F94E B5 54		SRC1	LDA	ROWCRS,X	;byte of cursor row/column
 15959 F950 9D B8 02			STA	TMPROW,X	;save byte of cursor row/co:
 15960 F953 CA				DEX
 15961 F954 10 F8			BPL	SRC1		;if not done
 15962
 15963 F956 60				RTS			;return
 15964 					;SPACE	4,10
 15965 				;	RRC - Restore Row and Column
 15966 				*
 15967 				*	ENTRY	JSR	RRC
 15968 				*
 15969 				*	MODS
 15970 				*		Original Author Unknown
 15971 				*		1. Bring closer to Coding Standard (object unchanged).
 15972 				*		   R. K. Nordin	11/01/83
 15973
 15974
 15975 = F957			RRC	=	*		;entry
 15976 F957 A2 02			LDX	#2		;offset to last byte
 15977
 15978 F959 BD B8 02		RRC1	LDA	TMPROW,X	;byte of saved cursor row/c:
 15979 F95C 95 54			STA	ROWCRS,X	;byte of row/column
 15980 F95E CA				DEX
 15981 F95F 10 F8			BPL	RRC1		;if not done
 15982
 15983 F961 60				RTS			;return
 15984 					;SPACE	4,10
 15985 				;	SWA - Swap Cursor Position with Regular Cursor Posi:
 15986 				*
 15987 				*	ENTRY	JSR	SWA
 15988 				*
 15989 				*	MODS
 15990 				*		Original Author Unknown
 15991 				*		1. Bring closer to Coding Standard (object unchanged).
 15992 				*		   R. K. Nordin	11/01/83
 15993
 15994
 15995 = F962			SWA	=	*		;entry
 15996
 15997 				;	Check for split screen.
 15998
 15999 F962 AD BF 02			LDA	BOTSCR		;screen bottom
 16000 F965 C9 18			CMP	#24		;normal indicator
 16001 F967 F0 17			BEQ	SWA2		;if not split screen
 16002
 16003 				;	Swap cursor parameters.
 16004
 16005 F969 A2 0B			LDX	#11		;offset to last byte
 16006
 16007 F96B B5 54		SWA1	LDA	ROWCRS,X	;destination cursor paramet:
 16008 F96D 48				PHA			;save cursor parameter
 16009 F96E BD 90 02			LDA	TXTROW,X	;source cursor parameter
 16010 F971 95 54			STA	ROWCRS,X	;update destination cursor :
 16011 F973 68				PLA			;saved cursor parameter
 16012 F974 9D 90 02			STA	TXTROW,X	;update source cursor param:
 16013 F977 CA				DEX
 16014 F978 10 F1			BPL	SWA1		;if not done
 16015
 16016 				;	Complement swap flag.
 16017
 16018 F97A A5 7B			LDA	SWPFLG		;swap flag
 16019 F97C 49 FF			EOR	#$FF		;complement swap flag
 16020 F97E 85 7B			STA	SWPFLG		;update swap flag
 16021
 16022 				;	Exit.
 16023
 16024 F980 4C 1E F2		SWA2	JMP	SST	;perform pscreen STATUS, return
 16025 					;SPACE	4,10
 16026 				;	SKC - Sound Key Click
 16027 				*
 16028 				*	ENTRY	JSR	SKC
 16029 				*
 16030 				*	MODS
 16031 				*		Original Author Unknown
 16032 				*		1. Bring closer to Coding Standard (object unchanged).
 16033 				*		   R. K. Nordin	11/01/83
 16034
 16035
 16036 = F983			SKC	=	*	;entry
 16037
 16038 				;	Initialize.
 16039
 16040 F983 A2 7E			LDX	#2*63	;2 times trip count
 16041 F985 48				PHA		;save A
 16042
 16043 				;	Turn loudspeaker on.
 16044
 16045 F986 8E 1F D0		SKC1	STX	CONSOL	;turn loudspeaker on
 16046
 16047 				;	Wait for VBLANK (loudspeaker off).
 16048
 16049 F989 AD 0B D4			LDA	VCOUNT	;vertical line counter
 16050
 16051 F98C CD 0B D4		SKC2	CMP	VCOUNT	;current vertical line counter
 16052 F98F F0 FB			BEQ	SKC2	;if vertical line not changed
 16053
 16054 				;	Decrement and check trip count.
 16055
 16056 F991 CA				DEX
 16057 F992 CA				DEX
 16058 F993 10 F1			BPL	SKC1	;if not done
 16059
 16060 				;	Exit.
 16061
 16062 F995 68				PLA		;restore A
 16063 F996 60				RTS		;return
 16064 					;SPACE	4,10
 16065 				;	SCL - Set Cursor at Left Edge
 16066 				*
 16067 				*	ENTRY	JSR	SCL
 16068 				*
 16069 				*	MODS
 16070 				*		Original Author Unknown
 16071 				*		1. Bring closer to Coding Standard (object unchanged).
 16072 				*		   R. K. Nordin	11/01/83
 16073
 16074
 16075 = F997			SCL	=	*	;entry
 16076
 16077 F997 A9 00			LDA	#0	;assume 0
 16078
 16079 F999 A6 7B			LDX	SWPFLG	;swap flag
 16080 F99B D0 04			BNE	SCL1	;if not swapped
 16081
 16082 F99D A6 57			LDX	DINDEX	;mode
 16083 F99F D0 02			BNE	SCL2	;if not mode 0
 16084
 16085 F9A1 A5 52		SCL1	LDA	LMARGN	;use left margin instead of 0
 16086
 16087 F9A3 85 55		SCL2	STA	COLCRS	;set low cursor column
 16088 F9A5 60				RTS		;return
 16089 					;SPACE	4,10
 16090 				;	SMS - Set Memory Scan Counter Address
 16091 				*
 16092 				*	ENTRY	JSR	SMS
 16093 				*
 16094 				*	MODS
 16095 				*		Original Author Unknown
 16096 				*		1. Bring closer to Coding Standard (object unchanged).
 16097 				*		   R. K. Nordin	11/01/83
 16098
 16099
 16100 = F9A6			SMS	=	*		;entry
 16101 F9A6 A5 58			LDA	SAVMSC		;saved low memory scan coun:
 16102 F9A8 85 64			STA	ADRESS		;saved low address
 16103 F9AA A5 59			LDA	SAVMSC+1	;saved high memory scan cou:
 16104 F9AC 85 65			STA	ADRESS+1	;set high address
 16105 F9AE 60				RTS			;return
 16106 					;SPACE	4,10
 16107 				;	SSP - Perform Screen SPECIAL
 16108 				*
 16109 				*	SSP draws a line from OLDROW/OLDCOL to NEWROW/NEWCO:
 16110 				*
 16111 				*	ENTRY	JSR	SSP
 16112 				*
 16113 				*	MODS
 16114 				*		A. Miller
 16115 				*		1. Bring closer to Coding Standard (object unchanged).
 16116 				*		   R. K. Nordin	11/01/83
 16117
 16118
 16119 = F9AF			SSP	=	*		;entry
 16120
 16121 				;	Determine command.
 16122
 16123 F9AF A2 00			LDX	#0		;assume no fill
 16124 F9B1 A5 22			LDA	ICCOMZ		;command
 16125 F9B3 C9 11			CMP	#$11		;DRAW command
 16126 F9B5 F0 08			BEQ	SSP2		;if DRAW command
 16127
 16128 F9B7 C9 12			CMP	#$12		;FILL command
 16129 F9B9 F0 03			BEQ	SSP1		;if FILL command
 16130
 16131 F9BB A0 84			LDY	#NVALID		;invalid command error
 16132 F9BD 60				RTS			;return
 16133
 16134 F9BE E8			SSP1	INX			;indicate fill
 16135
 16136 F9BF 8E B7 02		SSP2	STX	FILFLG		;right fill flag
 16137
 16138 				;	Set destination row/column.
 16139
 16140 F9C2 A5 54			LDA	ROWCRS		;cursor row
 16141 F9C4 8D F5 02			STA	NEWROW
 16142 F9C7 A5 55			LDA	COLCRS		;cursor column
 16143 F9C9 8D F6 02			STA	NEWCOL
 16144 F9CC A5 56			LDA	COLCRS+1
 16145 F9CE 8D F7 02			STA	NEWCOL+1
 16146
 16147 				;	Compute row increment and difference.
 16148
 16149 F9D1 A9 01			LDA	#1		;assume increment +1
 16150 F9D3 8D F8 02			STA	ROWINC		;row increment
 16151 F9D6 8D F9 02			STA	COLINC		;column increment
 16152 F9D9 38				SEC
 16153 F9DA AD F5 02			LDA	NEWROW		;destination row
 16154 F9DD E5 5A			SBC	OLDROW		;subtract source row
 16155 F9DF 85 76			STA	DELTAR		;row difference
 16156 F9E1 B0 0E			BCS	SSP3		;if difference positive
 16157
 16158 				;	Set row increment to -1 and complement row differen:
 16159
 16160 F9E3 A9 FF			LDA	#$FF		;increment -1
 16161 F9E5 8D F8 02			STA	ROWINC		;update row increment
 16162 F9E8 A5 76			LDA	DELTAR		;row difference
 16163 F9EA 49 FF			EOR	#$FF
 16164 F9EC 18				CLC
 16165 F9ED 69 01			ADC	#1		;add 1 for 2's complement
 16166 F9EF 85 76			STA	DELTAR		;update row difference
 16167
 16168 				;	Compute column increment and difference.
 16169
 16170 F9F1 38			SSP3	SEC
 16171 F9F2 AD F6 02			LDA	NEWCOL		;destination column
 16172 F9F5 E5 5B			SBC	OLDCOL		;source column
 16173 F9F7 85 77			STA	DELTAC		;column difference
 16174 F9F9 AD F7 02			LDA	NEWCOL+1
 16175 F9FC E5 5C			SBC	OLDCOL+1
 16176 F9FE 85 78			STA	DELTAC+1
 16177 FA00 B0 17			BCS	SSP4		;if difference positive
 16178
 16179 				;	Set column increment to -1 and complement column di:
 16180
 16181 FA02 A9 FF			LDA	#$FF		;increment -1
 16182 FA04 8D F9 02			STA	COLINC		;update column increment
 16183 FA07 A5 77			LDA	DELTAC		;column difference
 16184 FA09 49 FF			EOR	#$FF		;absolute value of column d:
 16185 FA0B 85 77			STA	DELTAC		;update column difference
 16186 FA0D A5 78			LDA	DELTAC+1
 16187 FA0F 49 FF			EOR	#$FF
 16188 FA11 85 78			STA	DELTAC+1
 16189 FA13 E6 77			INC	DELTAC		;add 1 for 2's complement
 16190 FA15 D0 02			BNE	SSP4		;if no carry
 16191
 16192 FA17 E6 78			INC	DELTAC+1	;adjust for 2's complement
 16193
 16194 FA19 A2 02		SSP4	LDX	#2		;offset to last byte
 16195 FA1B A0 00			LDY	#0
 16196 FA1D 84 73			STY	COLAC+1		;zero high working column
 16197
 16198 FA1F 98			SSP5	TYA
 16199 FA20 95 70			STA	ROWAC,X		;zero byte of working row/c:
 16200 FA22 B5 5A			LDA	OLDROW,X	;byte of source row/column
 16201 FA24 95 54			STA	ROWCRS,X	;byte of cursor row/column
 16202 FA26 CA				DEX
 16203 FA27 10 F6			BPL	SSP5		;if not done
 16204
 16205 				;	Determine difference.
 16206
 16207 FA29 A5 77			LDA	DELTAC		;low column difference
 16208 FA2B E8				INX			;offset to working row
 16209 FA2C A8				TAY			;low column difference
 16210 FA2D A5 78			LDA	DELTAC+1	;high column difference
 16211 FA2F 85 7F			STA	COUNTR+1	;initialize high iteration :
 16212 FA31 85 75			STA	ENDPT+1		;initialize high end point
 16213 FA33 D0 0B			BNE	SSP6		;if high column difference :
 16214
 16215 FA35 A5 77			LDA	DELTAC		;low column difference
 16216 FA37 C5 76			CMP	DELTAR		;row difference
 16217 FA39 B0 05			BCS	SSP6		;if column difference > row:
 16218
 16219 FA3B A5 76			LDA	DELTAR		;row difference
 16220 FA3D A2 02			LDX	#2		;offset to working column
 16221 FA3F A8				TAY			;row difference
 16222
 16223 FA40 98			SSP6	TYA			;low maximum difference
 16224 FA41 85 7E			STA	COUNTR		;low iteration counter
 16225 FA43 85 74			STA	ENDPT		;low end point
 16226 FA45 48				PHA			;save low end point
 16227 FA46 A5 75			LDA	ENDPT+1		;high end point
 16228 FA48 4A				LSR		;C = LSB of high end point
 16229 FA49 68				PLA			;saved low end point
 16230 FA4A 6A				ROR
 16231 FA4B 95 70			STA	ROWAC,X		;low working row or column
 16232
 16233 				;	Check for iteration counter zero.
 16234
 16235 FA4D A5 7E		SSP7	LDA	COUNTR		;low iteration counter
 16236 FA4F 05 7F			ORA	COUNTR+1	;or in high iteration count:
 16237 FA51 D0 03			BNE	SSP8		;if iteration counter is no:
 16238
 16239 FA53 4C 01 FB			JMP	SSP19		;exit
 16240
 16241 				;	Update working row.
 16242
 16243 FA56 18			SSP8	CLC
 16244 FA57 A5 70			LDA	ROWAC		;working row
 16245 FA59 65 76			ADC	DELTAR		;row difference
 16246 FA5B 85 70			STA	ROWAC		;update working row
 16247 FA5D 90 02			BCC	SSP9		;if no carry
 16248
 16249 FA5F E6 71			INC	ROWAC+1		;adjust high working row
 16250
 16251 FA61 A5 71		SSP9	LDA	ROWAC+1		;high working row
 16252 FA63 C5 75			CMP	ENDPT+1		;high end point
 16253 FA65 90 15			BCC	SSP11		;if high working row < high:
 16254
 16255 FA67 D0 06			BNE	SSP10		;if high working row > high:
 16256
 16257 FA69 A5 70			LDA	ROWAC		;low working row
 16258 FA6B C5 74			CMP	ENDPT		;low end point
 16259 FA6D 90 0D			BCC	SSP11		;if low working row < low e:
 16260
 16261 FA6F 18			SSP10	CLC
 16262 FA70 A5 54			LDA	ROWCRS		;cursor row
 16263 FA72 6D F8 02			ADC	ROWINC		;add row increment
 16264 FA75 85 54			STA	ROWCRS		;update cursor row
 16265 FA77 A2 00			LDX	#0		;indicate subtract from wor:
 16266 FA79 20 AE F6			JSR	SEP		;subtract end pointer
 16267
 16268 FA7C 18			SSP11	CLC
 16269 FA7D A5 72			LDA	COLAC		;low working column
 16270 FA7F 65 77			ADC	DELTAC		;add column difference
 16271 FA81 85 72			STA	COLAC		;update working column
 16272 FA83 A5 73			LDA	COLAC+1
 16273 FA85 65 78			ADC	DELTAC+1
 16274 FA87 85 73			STA	COLAC+1
 16275 FA89 C5 75			CMP	ENDPT+1		;high end point
 16276 FA8B 90 28			BCC	SSP15		;if high working column < h:
 16277
 16278 FA8D D0 06			BNE	SSP12		;if high working column > h:
 16279
 16280 FA8F A5 72			LDA	COLAC		;low working column
 16281 FA91 C5 74			CMP	ENDPT		;low end point
 16282 FA93 90 20			BCC	SSP15		;if low working column < lo:
 16283
 16284 FA95 2C F9 02		SSP12	BIT	COLINC		;column increment
 16285 FA98 10 10			BPL	SSP13		;if column increment positi:
 16286
 16287 FA9A C6 55			DEC	COLCRS		;decrement low cursor colum:
 16288 FA9C A5 55			LDA	COLCRS		;low cursor column
 16289 FA9E C9 FF			CMP	#$FF
 16290 FAA0 D0 0E			BNE	SSP14
 16291
 16292 FAA2 A5 56			LDA	COLCRS+1	;high cursor column
 16293 FAA4 F0 0A			BEQ	SSP14		;if zero, do not decrement
 16294
 16295 FAA6 C6 56			DEC	COLCRS+1	;decrement high cursor colu:
 16296 FAA8 10 06			BPL	SSP14
 16297
 16298 FAAA E6 55		SSP13	INC	COLCRS		;increment low cursor colum:
 16299 FAAC D0 02			BNE	SSP14		;if no carry
 16300
 16301 FAAE E6 56			INC	COLCRS+1	;adjust high cursor column
 16302
 16303 FAB0 A2 02		SSP14	LDX	#2		;indicate subtract from wor:
 16304 FAB2 20 AE F6			JSR	SEP		;subtract end pointer
 16305
 16306 				;	Plot point.
 16307
 16308 FAB5 20 CA F6		SSP15	JSR	CCR		;check cursor range
 16309 FAB8 20 CA F1			JSR	PLO		;plot point
 16310
 16311 				;	Check for right fill.
 16312
 16313 FABB AD B7 02			LDA	FILFLG		;right fill flag
 16314 FABE F0 2F			BEQ	SSP18		;if no right fill
 16315
 16316 				;	Process right fill.
 16317
 16318 FAC0 20 4C F9			JSR	SRC		;save row and column
 16319 FAC3 AD FB 02			LDA	ATACHR		;plot point
 16320 FAC6 8D BC 02			STA	HOLD4		;save plot point
 16321
 16322 FAC9 A5 54		SSP16	LDA	ROWCRS		;cursor row
 16323 FACB 48				PHA			;save cursor row
 16324 FACC 20 12 F6			JSR	ACC		;advance cursor column
 16325 FACF 68				PLA			;saved cursor row
 16326 FAD0 85 54			STA	ROWCRS		;restore cursor row
 16327 FAD2 20 CA F6			JSR	CCR		;check cursor range
 16328 FAD5 20 8F F1			JSR	GDC		;get data under cursor
 16329 FAD8 D0 0C			BNE	SSP17		;if non-zero data encounter:
 16330
 16331 FADA AD FD 02			LDA	FILDAT		;fill data
 16332 FADD 8D FB 02			STA	ATACHR		;plot point
 16333 FAE0 20 CA F1			JSR	PLO		;plot point
 16334 FAE3 4C C9 FA			JMP	SSP16		;continue
 16335
 16336 FAE6 AD BC 02		SSP17	LDA	HOLD4		;saved plot point
 16337 FAE9 8D FB 02			STA	ATACHR		;restore plot point
 16338 FAEC 20 57 F9			JSR	RRC		;restore row and column
 16339
 16340 				;	Subtract 1 from iteration counter.
 16341
 16342 FAEF 38			SSP18	SEC
 16343 FAF0 A5 7E			LDA	COUNTR		;iteration counter
 16344 FAF2 E9 01			SBC	#1		;subtract 1
 16345 FAF4 85 7E			STA	COUNTR		;update iteration counter
 16346 FAF6 A5 7F			LDA	COUNTR+1
 16347 FAF8 E9 00			SBC	#0
 16348 FAFA 85 7F			STA	COUNTR+1
 16349
 16350 				;	Check for completion.
 16351
 16352 FAFC 30 03			BMI	SSP19	;if iteration counter negative, exi:
 16353
 16354 FAFE 4C 4D FA			JMP	SSP7	;continue
 16355
 16356 				;	Exit.
 16357
 16358 FB01 4C 1E F2		SSP19	JMP	SST	;perform screen STATUS, return
 16359 					;SPACE	4,10
 16360 				;	TMSK - Table of Bit Masks
 16361
 16362
 16363 FB04 00			TMSK	.byte	$00	;0 - mask for no bits
 16364 FB05 01				.byte	$01	;1 - mask for lower 1 bit
 16365 FB06 03				.byte	$03	;2 - mask for lower 2 bits
 16366 FB07 07				.byte	$07	;3 - mask for lower 3 bits
 16367 					;SPACE	4,10
 16368 				;	TDSC - Table of Default Screen Colors
 16369
 16370
 16371 FB08 28			TDSC	.byte	$28	;default playfield 0 color
 16372 FB09 CA				.byte	$CA	;default playfield 1 color
 16373 FB0A 94				.byte	$94	;default playfield 2 color
 16374 FB0B 46				.byte	$46	;default playfield 3 color
 16375 FB0C 00				.byte	$00	;default background color
 16376 					;SPACE	4,10
 16377 				;	TCCR - Table of Control Character Routines
 16378 				*
 16379 				*	Each entry is 3 bytes. The first byte is the contr:
 16380 				*	character; the second and third bytes are the addre:
 16381 				*	the routine which processes the control character.
 16382
 16383
 16384 FB0D 1B			TCCR	.byte	$1B
 16385 FB0E E0 F3			.word	ESC	;escape
 16386
 16387 FB10 1C				.byte	$1C
 16388 FB11 E6 F3			.word	CUP	;move cursor up
 16389
 16390 FB13 1D				.byte	$1D
 16391 FB14 F3 F3			.word	CDN	;move cursor down
 16392
 16393 FB16 1E				.byte	$1E
 16394 FB17 00 F4			.word	CLF	;move cursor left
 16395
 16396 FB19 1F				.byte	$1F
 16397 FB1A 11 F4			.word	CRT	;move cursor right
 16398
 16399 FB1C 7D				.byte	$7D
 16400 FB1D 20 F4			.word	CSC	;clear screen
 16401
 16402 FB1F 7E				.byte	$7E
 16403 FB20 50 F4			.word	BSP	;backspace
 16404
 16405 FB22 7F				.byte	$7F
 16406 FB23 7A F4			.word	TAB	;tab
 16407
 16408 FB25 9B				.byte	$9B
 16409 FB26 61 F6			.word	RWS	;return with scrolling
 16410
 16411 FB28 9C				.byte	$9C
 16412 FB29 20 F5			.word	DLN	;delete line
 16413
 16414 FB2B 9D				.byte	$9D
 16415 FB2C 0C F5			.word	ILN	;insert line
 16416
 16417 FB2E 9E				.byte	$9E
 16418 FB2F 9A F4			.word	CTB	;clear tab
 16419
 16420 FB31 9F				.byte	$9F
 16421 FB32 95 F4			.word	STB	;set tab
 16422
 16423 FB34 FD				.byte	$FD
 16424 FB35 56 F5			.word	BEL	;sound bell
 16425
 16426 FB37 FE				.byte	$FE
 16427 FB38 D5 F4			.word	DCH	;delete character
 16428
 16429 FB3A FF				.byte	$FF
 16430 FB3B 9F F4			.word	ICH	;insert character
 16431
 16432 = 0030			TCCRL	=	*-TCCR	;length
 16433 					;SPACE	4,10
 16434 				;	TSFR - Table of Super Function (Shifted Function Ke:
 16435 				*
 16436 				*	Each entry is 3 bytes. The first byte is the super:
 16437 				*	character; the second and third bytes are the addre:
 16438 				*	routine which processes the super function.
 16439
 16440
 16441 FB3D 1C			TSFR	.byte	$1C
 16442 FB3E 40 F4			.word	CHM	;move cursor home
 16443
 16444 FB40 1D				.byte	$1D
 16445 FB41 5F F5			.word	CBT	;move cursor to bottom
 16446
 16447 FB43 1E				.byte	$1E
 16448 FB44 1B F4			.word	CLM	;move cursor to left margin
 16449
 16450 FB46 1F				.byte	$1F
 16451 FB47 0A F4			.word	CRM	;move cursor to right margin
 16452 					;SPACE	4,10
 16453 				;	TAIC - Table of ATASCII to Internal Conversion Cons:
 16454
 16455
 16456 FB49 40			TAIC	.byte	$40	;0
 16457 FB4A 00				.byte	$00	;1
 16458 FB4B 20				.byte	$20	;2
 16459 FB4C 60				.byte	$60	;3
 16460 					;SPACE	4,10
 16461 				;	TIAC - Table of Internal to ATASCII Conversion Cons:
 16462
 16463
 16464 FB4D 20			TIAC	.byte	$20	;0
 16465 FB4E 40				.byte	$40	;1
 16466 FB4F 00				.byte	$00	;2
 16467 FB50 60				.byte	$60	;3
 16468 					;SPACE	4,10
 16469 				;	TCKD - Table of Character Key Definitions
 16470 				*
 16471 				*	Entry n is the ATASCII equivalent of key code n.
 16472
 16473
 16474 = FB51			TCKD	=	*
 16475
 16476 				;	Lower Case Characters
 16477
 16478 FB51 6C				.byte	$6C	;$00 - l
 16479 FB52 6A				.byte	$6A	;$01 - j
 16480 FB53 3B				.byte	$3B	;$02 - semicolon
 16481 FB54 8A				.byte	$8A	;$03 - F1
 16482 FB55 8B				.byte	$8B	;$04 - F2
 16483 FB56 6B				.byte	$6B	;$05 - k
 16484 FB57 2B				.byte	$2B	;$06 - +
 16485 FB58 2A				.byte	$2A	;$07 - *
 16486 FB59 6F				.byte	$6F	;$08 - o
 16487 FB5A 80				.byte	$80	;$09 - (invalid)
 16488 FB5B 70				.byte	$70	;$0A - p
 16489 FB5C 75				.byte	$75	;$0B - u
 16490 FB5D 9B				.byte	$9B	;$0C - return
 16491 FB5E 69				.byte	$69	;$0D - i
 16492 FB5F 2D				.byte	$2D	;$0E - -
 16493 FB60 3D				.byte	$3D	;$0F - =
 16494
 16495 FB61 76				.byte	$76	;$10 - v
 16496 FB62 80				.byte	$80	;$11 - (invalid)
 16497 FB63 63				.byte	$63	;$12 - c
 16498 FB64 8C				.byte	$8C	;$13 - F3
 16499 FB65 8D				.byte	$8D	;$14 - F4
 16500 FB66 62				.byte	$62	;$15 - b
 16501 FB67 78				.byte	$78	;$16 - x
 16502 FB68 7A				.byte	$7A	;$17 - z
 16503 FB69 34				.byte	$34	;$18 - 4
 16504 FB6A 80				.byte	$80	;$19 - (invalid)
 16505 FB6B 33				.byte	$33	;$1A - 3
 16506 FB6C 36				.byte	$36	;$1B - 6
 16507 FB6D 1B				.byte	$1B	;$1C - escape
 16508 FB6E 35				.byte	$35	;$1D - 5
 16509 FB6F 32				.byte	$32	;$1E - 2
 16510 FB70 31				.byte	$31	;$1F - 1
 16511
 16512 FB71 2C				.byte	$2C	;$20 - comma
 16513 FB72 20				.byte	$20	;$21 - space
 16514 FB73 2E				.byte	$2E	;$22 - period
 16515 FB74 6E				.byte	$6E	;$23 - n
 16516 FB75 80				.byte	$80	;$24 - (invalid)
 16517 FB76 6D				.byte	$6D	;$25 - m
 16518 FB77 2F				.byte	$2F	;$26 - /
 16519 FB78 81				.byte	$81	;$27 - inverse
 16520 FB79 72				.byte	$72	;$28 - r
 16521 FB7A 80				.byte	$80	;$29 - (invalid)
 16522 FB7B 65				.byte	$65	;$2A - e
 16523 FB7C 79				.byte	$79	;$2B - y
 16524 FB7D 7F				.byte	$7F	;$2C - tab
 16525 FB7E 74				.byte	$74	;$2D - t
 16526 FB7F 77				.byte	$77	;$2E - w
 16527 FB80 71				.byte	$71	;$2F - q
 16528
 16529 FB81 39				.byte	$39	;$30 - 9
 16530 FB82 80				.byte	$80	;$31 - (invalid)
 16531 FB83 30				.byte	$30	;$32 - 0
 16532 FB84 37				.byte	$37	;$33 - 7
 16533 FB85 7E				.byte	$7E	;$34 - backspace
 16534 FB86 38				.byte	$38	;$35 - 8
 16535 FB87 3C				.byte	$3C	;$36 - <
 16536 FB88 3E				.byte	$3E	;$37 - >
 16537 FB89 66				.byte	$66	;$38 - f
 16538 FB8A 68				.byte	$68	;$39 - h
 16539 FB8B 64				.byte	$64	;$3A - d
 16540 FB8C 80				.byte	$80	;$3B - (invalid)
 16541 FB8D 82				.byte	$82	;$3C - CAPS
 16542 FB8E 67				.byte	$67	;$3D - g
 16543 FB8F 73				.byte	$73	;$3E - s
 16544 FB90 61				.byte	$61	;$3F - a
 16545
 16546 				;	Upper Case Characters
 16547
 16548 FB91 4C				.byte	$4C	;$40 - L
 16549 FB92 4A				.byte	$4A	;$41 - J
 16550 FB93 3A				.byte	$3A	;$42 - colon
 16551 FB94 8A				.byte	$8A	;$43 - SHIFT-F1
 16552 FB95 8B				.byte	$8B	;$44 - SHIFT-F2
 16553 FB96 4B				.byte	$4B	;$45 - K
 16554 FB97 5C				.byte	$5C	;$46 - \
 16555 FB98 5E				.byte	$5E	;$47 - ^
 16556 FB99 4F				.byte	$4F	;$48 - O
 16557 FB9A 80				.byte	$80	;$49 - (invalid)
 16558 FB9B 50				.byte	$50	;$4A - P
 16559 FB9C 55				.byte	$55	;$4B - U
 16560 FB9D 9B				.byte	$9B	;$4C - SHIFT-return
 16561 FB9E 49				.byte	$49	;$4D - I
 16562 FB9F 5F				.byte	$5F	;$4E - _
 16563 FBA0 7C				.byte	$7C	;$4F - |
 16564
 16565 FBA1 56				.byte	$56	;$50 - V
 16566 FBA2 80				.byte	$80	;$51 - (invalid)
 16567 FBA3 43				.byte	$43	;$52 - C
 16568 FBA4 8C				.byte	$8C	;$53 - SHIFT-F3
 16569 FBA5 8D				.byte	$8D	;$54 - SHIFT-F4
 16570 FBA6 42				.byte	$42	;$55 - B
 16571 FBA7 58				.byte	$58	;$56 - X
 16572 FBA8 5A				.byte	$5A	;$57 - Z
 16573 FBA9 24				.byte	$24	;$58 - $
 16574 FBAA 80				.byte	$80	;$59 - (invalid)
 16575 FBAB 23				.byte	$23	;$5A - #
 16576 FBAC 26				.byte	$26	;$5B - &
 16577 FBAD 1B				.byte	$1B	;$5C - SHIFT-escape
 16578 FBAE 25				.byte	$25	;$5D - %
 16579 FBAF 22				.byte	$22	;$5E - "
 16580 FBB0 21				.byte	$21	;$5F - !
 16581
 16582 FBB1 5B				.byte	$5B	;$60 - [
 16583 FBB2 20				.byte	$20	;$61 - SHIFT-space
 16584 FBB3 5D				.byte	$5D	;$62 - ]
 16585 FBB4 4E				.byte	$4E	;$63 - N
 16586 FBB5 80				.byte	$80	;$64 - (invalid)
 16587 FBB6 4D				.byte	$4D	;$65 - M
 16588 FBB7 3F				.byte	$3F	;$66 - ?
 16589 FBB8 81				.byte	$81	;$67 - SHIFT-inverse
 16590 FBB9 52				.byte	$52	;$68 - R
 16591 FBBA 80				.byte	$80	;$69 - (invalid)
 16592 FBBB 45				.byte	$45	;$6A - E
 16593 FBBC 59				.byte	$59	;$6B - Y
 16594 FBBD 9F				.byte	$9F	;$6C - SHIFT-tab
 16595 FBBE 54				.byte	$54	;$6D - T
 16596 FBBF 57				.byte	$57	;$6E - W
 16597 FBC0 51				.byte	$51	;$6F - Q
 16598
 16599 FBC1 28				.byte	$28	;$70 - (
 16600 FBC2 80				.byte	$80	;$71 - (invalid)
 16601 FBC3 29				.byte	$29	;$72 - )
 16602 FBC4 27				.byte	$27	;$73 - '
 16603 FBC5 9C				.byte	$9C	;$74 - SHIFT-delete
 16604 FBC6 40				.byte	$40	;$75 - @
 16605 FBC7 7D				.byte	$7D	;$76 - SHIFT-clear
 16606 FBC8 9D				.byte	$9D	;$77 - SHIFT-insert
 16607 FBC9 46				.byte	$46	;$78 - F
 16608 FBCA 48				.byte	$48	;$79 - H
 16609 FBCB 44				.byte	$44	;$7A - D
 16610 FBCC 80				.byte	$80	;$7B - (invalid)
 16611 FBCD 83				.byte	$83	;$7C - SHIFT-CAPS
 16612 FBCE 47				.byte	$47	;$7D - G
 16613 FBCF 53				.byte	$53	;$7E - S
 16614 FBD0 41				.byte	$41	;$7F - A
 16615
 16616 				;	Control Characters
 16617
 16618 FBD1 0C				.byte	$0C	;$80 - CTRL-L
 16619 FBD2 0A				.byte	$0A	;$81 - CTRL-J
 16620 FBD3 7B				.byte	$7B	;$82 - CTRL-semicolon
 16621 FBD4 80				.byte	$80	;$83 - (invalid)
 16622 FBD5 80				.byte	$80	;$84 - (invalid)
 16623 FBD6 0B				.byte	$0B	;$85 - CTRL-K
 16624 FBD7 1E				.byte	$1E	;$86 - CTRL-left arrow
 16625 FBD8 1F				.byte	$1F	;$87 - CTRL-right arrow
 16626 FBD9 0F				.byte	$0F	;$88 - CTRL-O
 16627 FBDA 80				.byte	$80	;$89 - (invalid)
 16628 FBDB 10				.byte	$10	;$8A - CTRL-P
 16629 FBDC 15				.byte	$15	;$8B - CTRL-U
 16630 FBDD 9B				.byte	$9B	;$8C - CTRL-return
 16631 FBDE 09				.byte	$09	;$8D - CTRL-I
 16632 FBDF 1C				.byte	$1C	;$8E - CTRL-up arrow
 16633 FBE0 1D				.byte	$1D	;$8F - CTRL-down arrow
 16634
 16635 FBE1 16				.byte	$16	;$90 - CTRL-V
 16636 FBE2 80				.byte	$80	;$91 - (invalid)
 16637 FBE3 03				.byte	$03	;$92 - CTRL-C
 16638 FBE4 89				.byte	$89	;$93 - CTRL-F3
 16639 FBE5 80				.byte	$80	;$94 - (invalid)
 16640 FBE6 02				.byte	$02	;$95 - CTRL-B
 16641 FBE7 18				.byte	$18	;$96 - CTRL-X
 16642 FBE8 1A				.byte	$1A	;$97 - CTRL-Z
 16643 FBE9 80				.byte	$80	;$98 - (invalid)
 16644 FBEA 80				.byte	$80	;$99 - (invalid)
 16645 FBEB 85				.byte	$85	;$9A - CTRL-3
 16646 FBEC 80				.byte	$80	;$9B - (invalid)
 16647 FBED 1B				.byte	$1B	;$9C - CTRL-escape
 16648 FBEE 80				.byte	$80	;$9D - (invalid)
 16649 FBEF FD				.byte	$FD	;$9E - CTRL-2
 16650 FBF0 80				.byte	$80	;$9F - (invalid)
 16651
 16652 FBF1 00				.byte	$00	;$A0 - CTRL-comma
 16653 FBF2 20				.byte	$20	;$A1 - CTRL-space
 16654 FBF3 60				.byte	$60	;$A2 - CTRL-period
 16655 FBF4 0E				.byte	$0E	;$A3 - CTRL-N
 16656 FBF5 80				.byte	$80	;$A4 - (invalid)
 16657 FBF6 0D				.byte	$0D	;$A5 - CTRL-M
 16658 FBF7 80				.byte	$80	;$A6 - (invalid)
 16659 FBF8 81				.byte	$81	;$A7 - CTRL-inverse
 16660 FBF9 12				.byte	$12	;$A8 - CTRL-R
 16661 FBFA 80				.byte	$80	;$A9 - (invalid)
 16662 FBFB 05				.byte	$05	;$AA - CTRL-E
 16663 FBFC 19				.byte	$19	;$AB - CTRL-Y
 16664 FBFD 9E				.byte	$9E	;$AC - CTRL-tab
 16665 FBFE 14				.byte	$14	;$AD - CTRL-T
 16666 FBFF 17				.byte	$17	;$AE - CTRL-W
 16667 FC00 11				.byte	$11	;$AF - CTRL-Q
 16668
 16669 FC01 80				.byte	$80	;$B0 - (invalid)
 16670 FC02 80				.byte	$80	;$B1 - (invalid)
 16671 FC03 80				.byte	$80	;$B2 - (invalid)
 16672 FC04 80				.byte	$80	;$B3 - (invalid)
 16673 FC05 FE				.byte	$FE	;$B4 - CTRL-delete
 16674 FC06 80				.byte	$80	;$B5 - (invalid)
 16675 FC07 7D				.byte	$7D	;$B6 - CTRL-clear
 16676 FC08 FF				.byte	$FF	;$B7 - CTRL-insert
 16677 FC09 06				.byte	$06	;$B8 - CTRL-F
 16678 FC0A 08				.byte	$08	;$B9 - CTRL-H
 16679 FC0B 04				.byte	$04	;$BA - CTRL-D
 16680 FC0C 80				.byte	$80	;$BB - (invalid)
 16681 FC0D 84				.byte	$84	;$BC - CTRL-CAPS
 16682 FC0E 07				.byte	$07	;$BD - CTRL-G
 16683 FC0F 13				.byte	$13	;$BE - CTRL-S
 16684 FC10 01				.byte	$01	;$BF - CTRL-A
 16685 					;SPACE	4,10
 16686 				;	TFKD - Table of Function Key Definitions
 16687 				*
 16688 				*	Entry n is the ATASCII equivalent of adjusted funct:
 16689 				*	code n.
 16690
 16691
 16692 FC11 1C			TFKD	.byte	$1C	;0 - F1 key
 16693 FC12 1D				.byte	$1D	;1 - F2 key
 16694 FC13 1E				.byte	$1E	;2 - F3 key
 16695 FC14 1F				.byte	$1F	;3 - F3 key
 16696
 16697 FC15 8E				.byte	$8E	;4 - SHIFT-F1 key
 16698 FC16 8F				.byte	$8F	;5 - SHIFT-F2 key
 16699 FC17 90				.byte	$90	;6 - SHIFT-F3 key
 16700 FC18 91				.byte	$91	;7 - SHIFT-F4 key
 16701 					;SPACE	4,10
 16702 				;	KIR - Process Keyboard IRQ
 16703 				*
 16704 				*	ENTRY	JMP	KIR
 16705 				*
 16706 				*	EXIT
 16707 				*		Exits via RTI
 16708 				*
 16709 				*	MODS
 16710 				*		Original Author Unknown
 16711 				*		1. Bring closer to Coding Standard (object unchanged).
 16712 				*		   R. K. Nordin	11/01/83
 16713
 16714
 16715 = FC19			KIR	=	*	;entry
 16716
 16717 				;	Initialize.
 16718
 16719 FC19 8A				TXA
 16720 FC1A 48				PHA		;save X
 16721 FC1B 98				TYA
 16722 FC1C 48				PHA		;save Y
 16723 FC1D AC 01 D3			LDY	PORTB	;port B memory control
 16724 FC20 AD 09 D2			LDA	KBCODE	;keyboard code
 16725 FC23 CD F2 02			CMP	CH1	;last key code
 16726 FC26 D0 05			BNE	KIR1	;if not last key code
 16727
 16728 FC28 AE F1 02			LDX	KEYDEL	;keyboard debounce delay
 16729 FC2B D0 49			BNE	KIR8	;if delay not expired, tread as bou:
 16730
 16731 				;	Check for CTRL-F1.
 16732
 16733 FC2D AE 6D 02		KIR1	LDX	KEYDIS	;save keyboard disable flag
 16734 FC30 C9 83			CMP	#CNTLF1
 16735 FC32 D0 13			BNE	KIR4	;if not CTRL-F1
 16736
 16737 				;	Process CTRL-F1
 16738
 16739 FC34 8A				TXA		;keyboard disable flag
 16740 FC35 49 FF			EOR	#$FF	;complelent keyboard disable flag
 16741 FC37 8D 6D 02			STA	KEYDIS	;update keyboard disable flag
 16742 FC3A D0 05			BNE	KIR2	;if keyboard disabled
 16743
 16744 FC3C 98				TYA		;port B memory control
 16745 FC3D 09 04			ORA	#$04	;turn off LED 1
 16746 FC3F D0 03			BNE	KIR3	;update port B memory control
 16747
 16748 FC41 98			KIR2	TYA		;port B memory control
 16749 FC42 29 FB			AND	#$FB	;turn on LED 1
 16750
 16751 FC44 A8			KIR3	TAY		;updated port B memory control
 16752 FC45 B0 26			BCS	KIR7	;reset keyboard controls
 16753
 16754 				;	Check keyboard disable.
 16755
 16756 FC47 8A			KIR4	TXA		;keyboard disable flag
 16757 FC48 D0 3D			BNE	KIR9	;if keyboard disabled, exit
 16758
 16759 				;	Get character.
 16760
 16761 FC4A AD 09 D2			LDA	KBCODE	;keyyboard code
 16762 FC4D AA				TAX		;character
 16763
 16764 				;	Check for CTRL-1.
 16765
 16766 FC4E C9 9F			CMP	#CNTL1
 16767 FC50 D0 0A			BNE	KIR5	;if not CTRL-1
 16768
 16769 				;	Process CTRL-1.
 16770
 16771 FC52 AD FF 02			LDA	SSFLAG	;start/stop flag
 16772 FC55 49 FF			EOR	#$FF	;complement start/stop flag
 16773 FC57 8D FF 02			STA	SSFLAG	;update start/stop flag
 16774 FC5A B0 11			BCS	KIR7	;make CTRL-1 invisible
 16775
 16776 				;	Check character.
 16777
 16778 FC5C 29 3F		KIR5	AND	#$3F	;mask off shift and control bits
 16779 FC5E C9 11			CMP	#HELP
 16780 FC60 D0 2E			BNE	KIR10	;if not HELP key
 16781
 16782 				;	Process HELP.
 16783
 16784 FC62 8E DC 02			STX	HELPFG	;indicate HELP key pressed
 16785 FC65 F0 06			BEQ	KIR7	;reset keyboard controls
 16786
 16787 				;	Process character.
 16788
 16789 FC67 8E FC 02		KIR6	STX	CH	;key code
 16790 FC6A 8E F2 02			STX	CH1	;reset previous key code
 16791
 16792 				;	Reset keyboard controls.
 16793
 16794 FC6D A9 03		KIR7	LDA	#3
 16795 FC6F 8D F1 02			STA	KEYDEL	;re-initialize for debounce
 16796 FC72 A9 00			LDA	#0
 16797 FC74 85 4D			STA	ATRACT	;clear attract-mode timer/flag
 16798
 16799 				;	Prepare to exit.
 16800
 16801 FC76 AD D9 02		KIR8	LDA	KRPDEL	;auto-repeat delay
 16802 FC79 8D 2B 02			STA	SRTIMR	;reset software key repeat timer
 16803 FC7C AD 2F 02			LDA	SDMCTL	;DMA control
 16804 FC7F D0 06			BNE	KIR9	;if DMA not disabled, exit
 16805
 16806 FC81 AD DD 02			LDA	DMASAV	;saved DMA control
 16807 FC84 8D 2F 02			STA	SDMCTL	;DMA control
 16808
 16809 				;	Exit.
 16810
 16811 FC87 8C 01 D3		KIR9	STY	PORTB	;update port B memory control
 16812 FC8A 68				PLA		;saved Y
 16813 FC8B A8				TAY		;restore Y
 16814 FC8C 68				PLA		;saved X
 16815 FC8D AA				TAX		;restore X
 16816 FC8E 68				PLA		;restore A
 16817 FC8F 40				RTI		;return
 16818
 16819 				;	Check for CTRL-F2 or CTRL-F4.
 16820
 16821 FC90 E0 84		KIR10	CPX	#CNTLF2
 16822 FC92 F0 21			BEQ	KIR12	;if CTRL-F2
 16823
 16824 FC94 E0 94			CPX	#CNTLF4
 16825 FC96 D0 CF			BNE	KIR6	;if not CTRL-F4
 16826
 16827 				;	Process CTRL-F4.
 16828
 16829 FC98 AD F4 02			LDA	CHBAS	;character set base
 16830 FC9B AE 6B 02			LDX	CHSALT	;character set alternate
 16831 FC9E 8D 6B 02			STA	CHSALT	;update character set alternate
 16832 FCA1 8E F4 02			STX	CHBAS	;update character set base
 16833
 16834 FCA4 E0 CC			CPX	#>ICSORG	;high international charact:
 16835 FCA6 F0 06			BEQ	KIR11		;if international character:
 16836
 16837 FCA8 98				TYA		;port B memory control
 16838 FCA9 09 08			ORA	#$08	;turn off LED 2
 16839 FCAB A8				TAY		;updated port B memory control
 16840 FCAC D0 BF			BNE	KIR7	;reset keyboard controls
 16841
 16842 FCAE 98			KIR11	TYA		;port B memory control
 16843 FCAF 29 F7			AND	#$F7	;turn on LED 2
 16844 FCB1 A8				TAY		;updated port B memory control
 16845 FCB2 4C 6D FC			JMP	KIR7	;reset keyboard controls
 16846
 16847 				;	Process CTRL-F2.
 16848
 16849 FCB5 AD 2F 02		KIR12	LDA	SDMCTL	;DMA control
 16850 FCB8 F0 CD			BEQ	KIR9	;if disabled, exit
 16851
 16852 FCBA 8D DD 02			STA	DMASAV	;save DMA state
 16853 FCBD A9 00			LDA	#0	;disable DMA
 16854 FCBF 8D 2F 02			STA	SDMCTL	;DMA control
 16855 FCC2 F0 C3			BEQ	KIR9	;exit
 16856 					;SPACE	4,10
 16857 				;	FDL - Process Display List Interrupt for Fine Scrol:
 16858 				*
 16859 				*	ENTRY	JMP	DFL
 16860 				*
 16861 				*	EXIT
 16862 				*		Exits via RTI
 16863 				*
 16864 				*	NOTES
 16865 				*		Problem: in the CRASS65 version, COLRSH was:
 16866 				*		zero-page.
 16867 				*		Problem: in the CRASS65 version, DRKMSK was:
 16868 				*		zero-page.
 16869 				*
 16870 				*	MODS
 16871 				*		H. Stewart	06/01/82
 16872 				*		1. Bring closer to Coding Standard (object unchanged).
 16873 				*		   R. K. Nordin	11/01/83
 16874
 16875
 16876 = FCC4			FDL	=	*		;entry
 16877 FCC4 48				PHA			;save A
 16878 FCC5 AD C6 02			LDA	COLOR2		;playfield 2 color
 16879 FCC8 4D 4F 00			EOR.w	COLRSH		;modify with attract-mode c:
 16880 				;!!!	VFD	8\$4D,8\low COLRSH,8\high COLRSH
 16881 FCCB 2D 4E 00			AND.w	DRKMSK		;modify with attract-mode l:
 16882 				;!!!	VFD	8\$2D,8\low DRKMSK,8\high COLRSH
 16883 FCCE 8D 0A D4			STA	WSYNC		;wait for HBLANK synchroniz:
 16884 FCD1 8D 17 D0			STA	COLPF1		;playfield 1 color/luminanc:
 16885 FCD4 68				PLA			;restore A
 16886 FCD5 40				RTI			;return
 16887 				;	;SUBTTL	'$FCD8 Patch'
 16888 					;SPACE	4,10
 16889 FCD6				ORG	$FCD8
 16890 					;SPACE	4,10
 16891 				;	FCD8 - $FCD8 Patch
 16892 				*
 16893 				*	For compatibility with OS Revision B, sound key cli:
 16894
 16895
 16896 FCD8 4C 83 F9			JMP	SKC	;sound key click, return
 16897 				;	;SUBTTL	'Cassette Handler'
 16898 					;SPACE	4,10
 16899 				;	CIN - Initialize Cassette
 16900 				*
 16901 				*	ENTRY	JSR	CIN
 16902 				*
 16903 				*	MODS
 16904 				*		Original Author Unknown
 16905 				*		1. Bring closer to Coding Standard (object unchanged).
 16906 				*		   R. K. Nordin	11/01/83
 16907
 16908
 16909 = FCDB			CIN	=	*		;entry
 16910 FCDB A9 CC			LDA	#<B00600	;indicate 600 baud
 16911 FCDD 8D EE 02			STA	CBAUDL		;cassette baud rate
 16912 FCE0 A9 05			LDA	#>B00600
 16913 FCE2 8D EF 02			STA	CBAUDH
 16914 				;	JMP	CSP		;return
 16915 					;SPACE	4,10
 16916 				;	CSP - Perform Cassette SPECIAL
 16917 				*
 16918 				*	CSP does nothing.
 16919 				*
 16920 				*	ENTRY	JSR	CSP
 16921 				*
 16922 				*	MODS
 16923 				*		Original Author Unknown
 16924 				*		1. Bring closer to Coding Standard (object unchanged).
 16925 				*		   R. K. Nordin	11/01/83
 16926
 16927
 16928 = FCE5			CSP	=	*	;entry
 16929 FCE5 60				RTS		;return
 16930 					;SPACE	4,10
 16931 				;	COP - Perform Cassette OPEN
 16932 				*
 16933 				*	ENTRY	JSR	COP
 16934 				*
 16935 				*	MODS
 16936 				*		Original Author Unknown
 16937 				*		1. Bring closer to Coding Standard (object unchanged).
 16938 				*		   R. K. Nordin	11/01/83
 16939
 16940
 16941 = FCE6			COP	=	*	;entry
 16942
 16943 				;	Set Cassette IRG type.
 16944
 16945 FCE6 A5 2B			LDA	ICAX2Z	;second auxiliary information
 16946 FCE8 85 3E			STA	FTYPE	;cassette IRG type
 16947
 16948 				;	Check OPEN mode.
 16949
 16950 FCEA A5 2A			LDA	ICAX1Z	;OPEN mode
 16951 FCEC 29 0C			AND	#$0C	;open for input and output bits
 16952 FCEE C9 04			CMP	#$04	;open for input bit
 16953 FCF0 F0 05			BEQ	OCI	;if open for input, process, return
 16954
 16955 FCF2 C9 08			CMP	#$08	;open for output bit
 16956 FCF4 F0 3E			BEQ	OCO	;if open for output, process, retur:
 16957
 16958 				;	Exit.
 16959
 16960 FCF6 60				RTS		;return
 16961 					;SPACE	4,10
 16962 				;	OCI - Open Cassette for Input
 16963 				*
 16964 				*	ENTRY	JSR	OCI
 16965 				*
 16966 				*	MODS
 16967 				*		Original Author Unknown
 16968 				*		1. Bring closer to Coding Standard (object unchanged).
 16969 				*		   R. K. Nordin	11/01/83
 16970
 16971
 16972 = FCF7			OCI	=	*	;entry
 16973
 16974 				;	Process open for input.
 16975
 16976 FCF7 A9 00			LDA	#0	;indicate reading
 16977 FCF9 8D 89 02			STA	WMODE	;WRITE mode
 16978 FCFC 85 3F			STA	FEOF	;indicate no FEOF yet
 16979 FCFE A9 01			LDA	#TONE2	;tone for pressing PLAY
 16980 FD00 20 FC FD			JSR	AUB	;alert user with beep
 16981 FD03 30 29			BMI	PBC1	;if error
 16982
 16983 				;	Initialize cassette READ.
 16984
 16985 				;	JMP	ICR	;initialize cassette READ, return
 16986 					;SPACE	4,10
 16987 				;	ICR - Initialize Cassette READ
 16988 				*
 16989 				*	ENTRY	JSR	ICR
 16990 				*
 16991 				*	MODS
 16992 				*		Original Author Unknown
 16993 				*		1. Bring closer to Coding Standard (object unchanged).
 16994 				*		   R. K. Nordin	11/01/83
 16995
 16996
 16997 = FD05			ICR	=	*		;entry
 16998
 16999 				;	Initialize.
 17000
 17001 FD05 A9 34			LDA	#MOTRGO		;motor on
 17002 FD07 8D 02 D3			STA	PACTL		;port A control
 17003
 17004 				;	Wait for leader read.
 17005
 17006 FD0A A6 62			LDX	PALNTS
 17007 FD0C BC 93 FE			LDY	RLEADL,X	;low READ leader
 17008 FD0F BD 91 FE			LDA	RLEADH,X	;high READ leader
 17009 FD12 AA				TAX
 17010 FD13 A9 03			LDA	#3
 17011 FD15 8D 2A 02			STA	CDTMF3
 17012 FD18 20 5C E4			JSR	SETVBV		;set up VBLANK timer
 17013
 17014 FD1B AD 2A 02		ICR1	LDA	CDTMF3
 17015 FD1E D0 FB			BNE	ICR1		;if not done waiting
 17016
 17017 				;	Initialize.
 17018
 17019 FD20 A9 80			LDA	#128		;buffer size
 17020 FD22 85 3D			STA	BPTR		;initialize buffer pointer
 17021 FD24 8D 8A 02			STA	BLIM		;initialize buffer limit
 17022 FD27 4C 77 FD			JMP	OCO2		;exit
 17023 					;SPACE	4,10
 17024 				;	PBC - Process BREAK for Cassette Operation
 17025 				*
 17026 				*	ENTRY	JSR	PBC
 17027 				*
 17028 				*	MODS
 17029 				*		Original Author Unknown
 17030 				*		1. Bring closer to Coding Standard (object unchanged).
 17031 				*		   R. K. Nordin	11/01/83
 17032
 17033
 17034 = FD2A			PBC	=	*	;entry
 17035 FD2A A0 80			LDY	#BRKABT	;BREAK abort error
 17036 FD2C C6 11			DEC	BRKKEY	;reset BREAK key flag
 17037
 17038 FD2E A9 00		PBC1	LDA	#0	;indicate reading
 17039 FD30 8D 89 02			STA	WMODE	;WRITE mode
 17040 FD33 60				RTS		;return
 17041 					;SPACE	4,10
 17042 				;	OCO - Open Cassette for Output
 17043 				*
 17044 				*	ENTRY	JSR	OCO
 17045 				*
 17046 				*	MODS
 17047 				*		Original Author Unknown
 17048 				*		1. Bring closer to Coding Standard (object unchanged).
 17049 				*		   R. K. Nordin	11/01/83
 17050
 17051
 17052 = FD34			OCO	=	*	;entry
 17053
 17054 				;	Initialize.
 17055
 17056 FD34 A9 80			LDA	#$80	;indicate writing
 17057 FD36 8D 89 02			STA	WMODE	;WRITE mode
 17058 FD39 A9 02			LDA	#TONE1
 17059 FD3B 20 FC FD			JSR	AUB	;alert user with beep
 17060 FD3E 30 EE			BMI	PBC1	;if error
 17061
 17062 				;	Set baud rate to 600.
 17063
 17064 FD40 A9 CC			LDA	#<B00600	;600 baud
 17065 FD42 8D 04 D2			STA	$D204
 17066 FD45 A9 05			LDA	#>B00600
 17067 FD47 8D 06 D2			STA	$D206
 17068
 17069 				;	Write marks.
 17070
 17071 FD4A A9 60			LDA	#$60
 17072 FD4C 8D 00 03			STA	DDEVIC
 17073 FD4F 20 68 E4			JSR	SENDEV
 17074 FD52 A9 34			LDA	#MOTRGO		;write 5 second blank tape
 17075 FD54 8D 02 D3			STA	PACTL
 17076
 17077 				;	Wait for leader written.
 17078
 17079 FD57 A6 62			LDX	PALNTS
 17080 FD59 BC 8F FE			LDY	WLEADL,X
 17081 FD5C BD 8D FE			LDA	WLEADH,X
 17082 FD5F AA				TAX
 17083 FD60 A9 03			LDA	#3
 17084 FD62 20 5C E4			JSR	SETVBV		;set VBLANK parameters
 17085 FD65 A9 FF			LDA	#$FF
 17086 FD67 8D 2A 02			STA	CDTMF3
 17087
 17088 FD6A A5 11		OCO1	LDA	BRKKEY	;BREAK key flag
 17089 FD6C F0 BC			BEQ	PBC	;if BREAK during write leader, proc:
 17090
 17091 FD6E AD 2A 02			LDA	CDTMF3
 17092 FD71 D0 F7			BNE	OCO1	;if not done waiting
 17093
 17094 				;	Initialize buffer pointer.
 17095
 17096 FD73 A9 00			LDA	#0
 17097 FD75 85 3D			STA	BPTR	;buffer pointer
 17098
 17099 				;	Indicate success.
 17100
 17101 FD77 A0 01		OCO2	LDY	#SUCCES	;indicate success
 17102 FD79 60				RTS		;return
 17103 					;SPACE	4,10
 17104 				;	CGB - Perform Cassette GET-BYTE
 17105 				*
 17106 				*	ENTRY	JSR	CGB
 17107 				*
 17108 				*	MODS
 17109 				*		Original Author Unknown
 17110 				*		1. Bring closer to Coding Standard (object unchanged).
 17111 				*		   R. K. Nordin	11/01/83
 17112
 17113
 17114 = FD7A			CGB	=	*		;entry
 17115
 17116 				;	Check for EOF.
 17117
 17118 FD7A A5 3F			LDA	FEOF		;EOF flag
 17119 FD7C 30 33			BMI	RCB3		;if at EOF already
 17120
 17121 				;	Check for end of buffer.
 17122
 17123 FD7E A6 3D			LDX	BPTR		;buffer pointer
 17124 FD80 EC 8A 02			CPX	BLIM		;buffer limit
 17125 FD83 F0 08			BEQ	RCB		;if end of buffer, read blo:
 17126
 17127 				;	Get next byte.
 17128
 17129 FD85 BD 00 04			LDA	CASBUF+3,X	;byte
 17130 FD88 E6 3D			INC	BPTR		;increment pointer
 17131 FD8A A0 01			LDY	#SUCCES		;indicate success
 17132
 17133 FD8C 60			CGB1	RTS			;return
 17134 					;SPACE	4,10
 17135 				;	RCB - Read Cassette Block
 17136 				*
 17137 				*	ENTRY	JSR	RCB
 17138 				*
 17139 				*	MODS
 17140 				*		Original Author Unknown
 17141 				*		1. Bring closer to Coding Standard (object unchanged).
 17142 				*		   R. K. Nordin	11/01/83
 17143
 17144
 17145 = FD8D			RCB	=	*	;entry
 17146
 17147 				;	Perform READ.
 17148
 17149 FD8D A9 52			LDA	#'R'	;read
 17150 FD8F 20 3F FE			JSR	SCB	;perform SIO on cassette buffer
 17151 FD92 98				TYA
 17152 FD93 30 F7			BMI	CGB1	;if SIO error
 17153
 17154 FD95 A9 00			LDA	#0
 17155 FD97 85 3D			STA	BPTR	;reset pointer
 17156 FD99 A2 80			LDX	#$80	;default number of bytes
 17157
 17158 				;	Check for header.
 17159
 17160 FD9B AD FF 03			LDA	CASBUF+2
 17161 FD9E C9 FE			CMP	#EOT
 17162 FDA0 F0 0D			BEQ	RCB2	;if header, read again
 17163
 17164 				;	Check for last record.
 17165
 17166 FDA2 C9 FA			CMP	#DT1
 17167 FDA4 D0 03			BNE	RCB1		;if not last data record
 17168
 17169 FDA6 AE 7F 04			LDX	CASBUF+130	;number of bytes
 17170
 17171 				;	Set number of bytes.
 17172
 17173 FDA9 8E 8A 02		RCB1	STX	BLIM
 17174
 17175 				;	Perform cassette GET-BYTE.
 17176
 17177 FDAC 4C 7A FD			JMP	CGB		;perform cassette GET-BYTE,:
 17178
 17179 				;	Set EOF flag.
 17180
 17181 FDAF C6 3F		RCB2	DEC	FEOF		;set EOF flag
 17182
 17183 				;	Exit.
 17184
 17185 FDB1 A0 88		RCB3	LDY	#EOFERR		;end of file indicator
 17186 FDB3 60				RTS			;return
 17187 					;SPACE	4,10
 17188 				;	CPB - Perform Cassette PUT-BYTE
 17189 				*
 17190 				*	ENTRY	JSR	CPB
 17191 				*
 17192 				*	MODS
 17193 				*		Original Author Unknown
 17194 				*		1. Bring closer to Coding Standard (object unchanged).
 17195 				*		   R. K. Nordin	11/01/83
 17196
 17197
 17198 = FDB4			CPB	=	*		;entry
 17199
 17200 				;	Move data to buffer.
 17201
 17202 FDB4 A6 3D			LDX	BPTR		;buffer pointer
 17203 FDB6 9D 00 04			STA	CASBUF+3,X	;data
 17204 FDB9 E6 3D			INC	BPTR		;increment buffer pointer
 17205 FDBB A0 01			LDY	#SUCCES		;assume success
 17206
 17207 				;	Check buffer full.
 17208
 17209 FDBD E0 7F			CPX	#127		;offset to last byte of buf:
 17210 FDBF F0 01			BEQ	CPB1		;if buffer full
 17211
 17212 FDC1 60				RTS			;return
 17213
 17214 				;	Write cassette buffer.
 17215
 17216 FDC2 A9 FC		CPB1	LDA	#DTA	;indicate data record type
 17217 FDC4 20 7C FE			JSR	WCB	;write cassette buffer
 17218 FDC7 A9 00			LDA	#0
 17219 FDC9 85 3D			STA	BPTR	;reset buffer pointer
 17220 FDCB 60				RTS		;return
 17221 					;SPACE	4,10
 17222 				;	CST - Perform Cassette STATUS
 17223 				*
 17224 				*	ENTRY	JSR	CST
 17225 				*
 17226 				*	MODS
 17227 				*		Original Author Unknown
 17228 				*		1. Bring closer to Coding Standard (object unchanged).
 17229 				*		   R. K. Nordin	11/01/83
 17230
 17231
 17232 = FDCC			CST	=	*	;entry
 17233 FDCC A0 01			LDY	#SUCCES	;indicate success
 17234 FDCE 60				RTS		;return
 17235 					;SPACE	4,10
 17236 				;	CCL - Perform Cassette CLOSE
 17237 				*
 17238 				*	ENTRY	JSR	CCL
 17239 				*
 17240 				*	MODS
 17241 				*		Original Author Unknown
 17242 				*		1. Bring closer to Coding Standard (object unchanged).
 17243 				*		   R. K. Nordin	11/01/83
 17244
 17245
 17246 = FDCF			CCL	=	*	;entry
 17247
 17248 				;	Check mode.
 17249
 17250 FDCF AD 89 02			LDA	WMODE	;WRITE mode
 17251 FDD2 30 08			BMI	CCL2	;if writing
 17252
 17253 				;	Process reading.
 17254
 17255 FDD4 A0 01			LDY	#SUCCES	;indicate success
 17256
 17257 				;	Exit.
 17258
 17259 FDD6 A9 3C		CCL1	LDA	#MOTRST
 17260 FDD8 8D 02 D3			STA	PACTL	;stop motor
 17261 FDDB 60				RTS		;return
 17262
 17263 				;	Process writing.
 17264
 17265 FDDC A6 3D		CCL2	LDX	BPTR		;buffer pointer
 17266 FDDE F0 0A			BEQ	CCL3		;if no data bytes in buffer
 17267
 17268 FDE0 8E 7F 04			STX	CASBUF+130	;number of bytes
 17269 FDE3 A9 FA			LDA	#DT1		;indicate data record type
 17270 FDE5 20 7C FE			JSR	WCB		;write cassette buffer
 17271 FDE8 30 EC			BMI	CCL1		;if error, exit
 17272
 17273 				;	Zero buffer.
 17274
 17275 FDEA A2 7F		CCL3	LDX	#127		;offset to last byte in buf:
 17276 FDEC A9 00			LDA	#0
 17277
 17278 FDEE 9D 00 04		CCL4	STA	CASBUF+3,X	;zero byte
 17279 FDF1 CA				DEX
 17280 FDF2 10 FA			BPL	CCL4		;if not done
 17281
 17282 				;	Write cassette buffer.
 17283
 17284 FDF4 A9 FE			LDA	#EOT	;indicate EOT record type
 17285 FDF6 20 7C FE			JSR	WCB	;write cassette buffer
 17286
 17287 				;	Exit.
 17288
 17289 FDF9 4C D6 FD			JMP	CCL1	;exit
 17290 					;SPACE	4,10
 17291 				;	AUB - Alert User with Beep
 17292 				*
 17293 				*	ON ENTRY A= FREQ
 17294 				*
 17295 				*	ENTRY	JSR	AUB
 17296 				*
 17297 				*	MODS
 17298 				*		Original Author Unknown
 17299 				*		1. Bring closer to Coding Standard (object unchanged).
 17300 				*		   R. K. Nordin	11/01/83
 17301
 17302
 17303 = FDFC			AUB	=	*		;entry
 17304
 17305 				;	Initialize.
 17306
 17307 FDFC 85 40			STA	FREQ		;frequency
 17308
 17309 				;	Compute termination time of beep duration.
 17310
 17311 FDFE A5 14		AUB1	LDA	RTCLOK+2	;current time
 17312 FE00 18				CLC
 17313 FE01 A6 62			LDX	PALNTS
 17314 FE03 7D 95 FE			ADC	BEEPNX,X	;add constant for 1 second :
 17315 FE06 AA				TAX			;beep duration termination :
 17316
 17317 				;	Turn on speaker.
 17318
 17319 FE07 A9 FF		AUB2	LDA	#$FF
 17320 FE09 8D 1F D0			STA	CONSOL		;turn on speaker
 17321 FE0C A9 00			LDA	#$00
 17322
 17323 				;	Delay.
 17324
 17325 FE0E A0 F0			LDY	#$F0
 17326
 17327 FE10 88			AUB3	DEY
 17328 FE11 D0 FD			BNE	AUB3		;if not done delaying
 17329
 17330 				;	Turn off speaker.
 17331
 17332 FE13 8D 1F D0			STA	CONSOL		;turn off speaker
 17333
 17334 				;	Delay.
 17335
 17336 FE16 A0 F0			LDY	#$F0
 17337
 17338 FE18 88			AUB4	DEY
 17339 FE19 D0 FD			BNE	AUB4		;if not done delaying
 17340
 17341 				;	Check for beep duration termination time.
 17342
 17343 FE1B E4 14			CPX	RTCLOK+2	;compare current time
 17344 FE1D D0 E8			BNE	AUB2		;if termination time not re:
 17345
 17346 FE1F C6 40			DEC	FREQ		;decrement frequency
 17347 FE21 F0 0E			BEQ	AUB6		;if all done, wait for anot:
 17348
 17349 				;	Compute termination time of beep separation.
 17350
 17351 FE23 8A				TXA
 17352 FE24 18				CLC
 17353 FE25 A6 62			LDX	PALNTS
 17354 FE27 7D 97 FE			ADC	BEEPFX,X	;add constant
 17355 FE2A AA				TAX			;beep separation terminatio:
 17356
 17357 				;	Wait for termination of beep separation.
 17358
 17359 FE2B E4 14		AUB5	CPX	RTCLOK+2	;compare current time
 17360 FE2D D0 FC			BNE	AUB5		;if termination time not re:
 17361
 17362 				;	Beep again.
 17363
 17364 FE2F F0 CD			BEQ	AUB1		;beep again
 17365
 17366 				;	Wait for key.
 17367
 17368 FE31 20 36 FE		AUB6	JSR	WFK		;wait for key
 17369 FE34 98				TYA			;status
 17370 FE35 60				RTS			;return
 17371 					;SPACE	4,10
 17372 				;	WFK - Wait for Key
 17373 				*
 17374 				*	ENTRY	JSR	WFK
 17375 				*
 17376 				*	NOTES
 17377 				*		Problem: bytes wasted by not doing LDA #hig:
 17378 				*		and LDA #low[KGB-1].
 17379 				*		Problem: bytes wasted by this being a subro:
 17380 				*
 17381 				*	MODS
 17382 				*		Original Author Unknown
 17383 				*		1. Bring closer to Coding Standard (object unchanged).
 17384 				*		   R. K. Nordin	11/01/83
 17385
 17386
 17387 = FE36			WFK	=	*		;entry
 17388 FE36 AD 25 E4			LDA	KEYBDV+5	;keyboard GET-BYTE routine :
 17389 FE39 48				PHA			;put address on stack
 17390 FE3A AD 24 E4			LDA	KEYBDV+4
 17391 FE3D 48				PHA
 17392 FE3E 60				RTS			;invoke keyboard GET-BYTE r:
 17393 					;SPACE	4,10
 17394 				;	SCB - Perform SIO on Cassette Buffer
 17395 				*
 17396 				*	ENTRY	JSR	SCB
 17397 				*
 17398 				*	NOTES
 17399 				*		Problem: byte wasted on JSR/RTS exit.
 17400 				*
 17401 				*	MODS
 17402 				*		Original Author Unknown
 17403 				*		1. Bring closer to Coding Standard (object unchanged).
 17404 				*		   R. K. Nordin	11/01/83
 17405
 17406
 17407 = FE3F			SCB	=	*		;entry
 17408 FE3F 8D 02 03			STA	DCOMND		;command
 17409 FE42 A9 00			LDA	#>131
 17410 FE44 8D 09 03			STA	DBYTHI		;buffer length
 17411 FE47 A9 83			LDA	#<131
 17412 FE49 8D 08 03			STA	DBYTLO
 17413 FE4C A9 03			LDA	#>CASBUF
 17414 FE4E 8D 05 03			STA	DBUFHI		;buffer address
 17415 FE51 A9 FD			LDA	#<CASBUF
 17416 FE53 8D 04 03			STA	DBUFLO
 17417 FE56 A9 60			LDA	#$60		;cassette bus ID
 17418 FE58 8D 00 03			STA	DDEVIC
 17419 FE5B A9 00			LDA	#0
 17420 FE5D 8D 01 03			STA	DUNIT
 17421 FE60 A9 23			LDA	#35		;timeout
 17422 FE62 8D 06 03			STA	DTIMLO
 17423 FE65 AD 02 03			LDA	DCOMND		;command
 17424 FE68 A0 40			LDY	#GETDAT		;assume SIO GET-DATA comman:
 17425 FE6A C9 52			CMP	#READ
 17426 FE6C F0 02			BEQ	SCB1		;if READ command
 17427
 17428 FE6E A0 80			LDY	#PUTDAT		;SIO PUT-DATA command
 17429
 17430 FE70 8C 03 03		SCB1	STY	DSTATS		;SIO command
 17431 FE73 A5 3E			LDA	FTYPE		;IRG type
 17432 FE75 8D 0B 03			STA	DAUX2		;second auxiliary informati:
 17433 FE78 20 59 E4			JSR	SIOV		;vector to SIOV
 17434 FE7B 60				RTS			;return
 17435 					;SPACE	4,10
 17436 				;	WCB - Write Cassette Buffer
 17437 				*
 17438 				*	ENTRY	JSR	WCB
 17439 				*
 17440 				*	NOTES
 17441 				*		Problem: byte wasted on JSR/RTS exit.
 17442 				*
 17443 				*	MODS
 17444 				*		Original Author Unknown
 17445 				*		1. Bring closer to Coding Standard (object unchanged).
 17446 				*		   R. K. Nordin	11/01/83
 17447
 17448
 17449 = FE7C			WCB	=	*		;entry
 17450 FE7C 8D FF 03			STA	CASBUF+2	;record type
 17451 FE7F A9 55			LDA	#$55
 17452 FE81 8D FD 03			STA	CASBUF+0
 17453 FE84 8D FE 03			STA	CASBUF+1
 17454 FE87 A9 57			LDA	#'W'		;write
 17455 FE89 20 3F FE			JSR	SCB		;perform SIO on cassette bu:
 17456 FE8C 60				RTS			;return
 17457 					;SPACE	4,10
 17458 				;	NTSC/PAL Constant Tables
 17459
 17460
 17461 FE8D 04			WLEADH	.byte	>WLEADN	;>NTSC WRITE file leader
 17462 FE8E 03				.byte	>WLEADP	;>PAL WRITE file leader
 17463
 17464 FE8F 80			WLEADL	.byte	<WLEADN	;<NTSC WRITE file leader
 17465 FE90 C0				.byte	<WLEADP	;<PAL WRITE file leader
 17466
 17467 FE91 02			RLEADH	.byte	>RLEADN	;>NTSC READ file leader
 17468 FE92 01				.byte	>RLEADP	;>PAL READ file leader
 17469
 17470 FE93 40			RLEADL	.byte	<RLEADN	;<NTSC READ file leader
 17471 FE94 E0				.byte	<RLEADP	;<PAL READ file leader
 17472
 17473 FE95 1E			BEEPNX	.byte	BEEPNN		;NTSC beep duration
 17474 FE96 19				.byte	BEEPNP		;PAL beep duration
 17475
 17476 FE97 0A			BEEPFX	.byte	BEEPFN		;NTSC beep separation
 17477 FE98 08				.byte	BEEPFP		;PAL beep separation
 17478 				;	;SUBTTL	'Printer Handler'
 17479 					;SPACE	4,10
 17480 				;	PIN - Initialize Printer
 17481 				*
 17482 				*	ENTRY	JSR	PIN
 17483 				*
 17484 				*	MODS
 17485 				*		Original Author Unknown
 17486 				*		1. Bring closer to Coding Standard (object unchanged).
 17487 				*		   R. K. Nordin	11/01/83
 17488
 17489
 17490 = FE99			PIN	=	*	;entry
 17491 FE99 A9 1E			LDA	#30	;30 second timeout
 17492 FE9B 8D 14 03			STA	PTIMOT	;printer timeout
 17493 FE9E 60				RTS		;return
 17494 					;SPACE	4,10
 17495 				;	Printer Handler Address Data
 17496 				*
 17497 				*	NOTES
 17498 				*		Problem: bytes wasted by tables and code.  :
 17499 				*		Immediate instructions should be used.
 17500
 17501
 17502 FE9F EA 02		PSTB	.word	DVSTAT	;status buffer address
 17503
 17504 FEA1 C0 03		PPRB	.word	PRNBUF	;printer buffer address
 17505 					;SPACE	4,10
 17506 				;	PST - Perform Printer STATUS
 17507 				*
 17508 				*	ENTRY	JSR	PST
 17509 				*
 17510 				*	MODS
 17511 				*		Original Author Unknown
 17512 				*		1. Bring closer to Coding Standard (object unchanged).
 17513 				*		   R. K. Nordin	11/01/83
 17514
 17515
 17516 = FEA3			PST	=	*	;entry
 17517 FEA3 A9 04			LDA	#4	;4 bytes for status
 17518 FEA5 8D DF 02			STA	PBUFSZ	;buffer size
 17519 FEA8 AE 9F FE			LDX	PSTB	;address of status buffer
 17520 FEAB AC A0 FE			LDY	PSTB+1
 17521 FEAE A9 53			LDA	#STATC	;status command
 17522 FEB0 8D 02 03			STA	DCOMND	;command
 17523 FEB3 8D 0A 03			STA	DAUX1
 17524 FEB6 20 14 FF			JSR	SDP	;set up DCB for printer
 17525 FEB9 20 59 E4			JSR	SIOV	;vector to SIO
 17526 FEBC 30 03			BMI	PSP	;if error, return
 17527
 17528 				;	Exit.
 17529
 17530 FEBE 20 44 FF			JSR	STS	;set printer timeout from status
 17531 				;	JMP	PSP	; return
 17532 					;SPACE	4,10
 17533 				;	PSP - Perform Printer SPECIAL
 17534 				*
 17535 				*	PSP does nothing.
 17536 				*
 17537 				*	ENTRY	JSR	PSP
 17538 				*
 17539 				*	MODS
 17540 				*		Original Author Unknown
 17541 				*		1. Bring closer to Coding Standard (object unchanged).
 17542 				*		   R. K. Nordin	11/01/83
 17543
 17544
 17545 = FEC1			PSP	=	*	;entry
 17546 FEC1 60				RTS		;return
 17547 					;SPACE	4,10
 17548 				;	POP - Perform Printer OPEN
 17549 				*
 17550 				*	ENTRY	JSR	POP
 17551 				*
 17552 				*	MODS
 17553 				*		Original Author Unknown
 17554 				*		1. Bring closer to Coding Standard (object unchanged).
 17555 				*		   R. K. Nordin	11/01/83
 17556
 17557
 17558 = FEC2			POP	=	*	;entry
 17559 FEC2 20 A3 FE			JSR	PST	;perform printer STATUS
 17560 FEC5 A9 00			LDA	#0
 17561 FEC7 8D DE 02			STA	PBPNT	;clear pointer buffer pointer
 17562 FECA 60				RTS		;return
 17563 					;SPACE	4,10
 17564 				;	PPB - Perform Printer PUT-BYTE
 17565 				*
 17566 				*	ENTRY	JSR	PPB
 17567 				*
 17568 				*	MODS
 17569 				*		Original Author Unknown
 17570 				*		1. Bring closer to Coding Standard (object unchanged).
 17571 				*		   R. K. Nordin	11/01/83
 17572
 17573
 17574 = FECB			PPB	=	*		;entry
 17575
 17576 				;	Initialize.
 17577
 17578 FECB 48				PHA			;save data
 17579 FECC BD 41 03			LDA	ICDNO,X		;device number
 17580 FECF 85 21			STA	ICDNOZ		;device number
 17581 FED1 20 4B FF			JSR	PPM		;process print mode
 17582
 17583 				;	Put data in buffer.
 17584
 17585 FED4 AE DE 02			LDX	PBPNT		;printer buffer pointer
 17586 FED7 68				PLA			;saved data
 17587 FED8 9D C0 03			STA	PRNBUF,X	;put data in buffer
 17588 FEDB E8				INX
 17589
 17590 				;	Check for buffer full.
 17591
 17592 FEDC EC DF 02			CPX	PBUFSZ		;printer buffer size
 17593 FEDF F0 15			BEQ	PPP		;if buffer full, perform PU:
 17594
 17595 				;	Update printer buffer pointer.
 17596
 17597 FEE1 8E DE 02			STX	PBPNT		;printer buffer pointer
 17598
 17599 				;	Check for EOL.
 17600
 17601 FEE4 C9 9B			CMP	#EOL
 17602 FEE6 F0 03			BEQ	PPB1		;if EOL, space fill
 17603
 17604 				;	Exit.
 17605
 17606 FEE8 A0 01			LDY	#SUCCES		;indicate success
 17607 FEEA 60				RTS			;return
 17608
 17609 				;	Space fill buffer.
 17610
 17611 FEEB A9 20		PPB1	LDA	#' '		;indicate space fill
 17612 				;	JMP	FPB		;fill printer buffer, retur:
 17613 					;SPACE	4,10
 17614 				;	FPB - Fill Printer Buffer
 17615 				*
 17616 				*	ENTRY	JSR	FPB
 17617 				*
 17618 				*	MODS
 17619 				*		Original Author Unknown
 17620 				*		1. Bring closer to Coding Standard (object unchanged).
 17621 				*		   R. K. Nordin	11/01/83
 17622
 17623
 17624 = FEED			FPB	=	*		;entry
 17625
 17626 				;	Fill printer buffer.
 17627
 17628 FEED 9D C0 03		FPB1	STA	PRNBUF,X	;byte of printer buffer
 17629 FEF0 E8				INX
 17630 FEF1 EC DF 02			CPX	PBUFSZ		;printer buffer size
 17631 FEF4 D0 F7			BNE	FPB1		;if not done
 17632
 17633 				;	Perform printer PUT.
 17634
 17635 				;	JMP	PPP		;perform printer PUT, retur:
 17636 					;SPACE	4,10
 17637 				;	PPP - Perform Printer PUT
 17638 				*
 17639 				*	ENTRY	JSR	PPP
 17640 				*
 17641 				*	MODS
 17642 				*		Original Author Unknown
 17643 				*		1. Bring closer to Coding Standard (object unchanged).
 17644 				*		   R. K. Nordin	11/01/83
 17645
 17646
 17647 = FEF6			PPP	=	*	;entry
 17648
 17649 				;	Clear printer buffer pointer.
 17650
 17651 FEF6 A9 00			LDA	#0
 17652 FEF8 8D DE 02			STA	PBPNT	;clear printer buffer pointer
 17653
 17654 				;	Set up DCB.
 17655
 17656 FEFB AE A1 FE			LDX	PPRB	;address of printer buffer
 17657 FEFE AC A2 FE			LDY	PPRB+1
 17658 FF01 20 14 FF			JSR	SDP	;set up DCB for printer
 17659
 17660 				;	Perform PUT.
 17661
 17662 FF04 4C 59 E4			JMP	SIOV	;vector to SIO, return
 17663 					;SPACE	4,10
 17664 				;	PCL - Perform Printer CLOSE
 17665 				*
 17666 				*	ENTRY	JSR	PCL
 17667 				*
 17668 				*	MODS
 17669 				*		Original Author Unknown
 17670 				*		1. Bring closer to Coding Standard (object unchanged).
 17671 				*		   R. K. Nordin	11/01/83
 17672
 17673
 17674 = FF07			PCL	=	*	;entry
 17675
 17676 				;	Initialize.
 17677
 17678 FF07 20 4B FF			JSR	PPM	;process print mode
 17679
 17680 				;	Check buffer pointer.
 17681
 17682 FF0A A9 9B			LDA	#EOL	;indicate EOL fill
 17683 FF0C AE DE 02			LDX	PBPNT	;printer buffer pointer
 17684 FF0F D0 DC			BNE	FPB	;if buffer pointer non-zero, fill b:
 17685
 17686 				;	Exit.
 17687
 17688 FF11 A0 01			LDY	#SUCCES	;indicate success
 17689 FF13 60				RTS		;return
 17690 					;SPACE	4,10
 17691 				;	SDP - Set Up DCB for Printer
 17692 				*
 17693 				*	ENTRY	JSR	SDP
 17694 				*
 17695 				*	MODS
 17696 				*		Original Author Unknown
 17697 				*		1. Bring closer to Coding Standard (object unchanged).
 17698 				*		   R. K. Nordin	11/01/83
 17699
 17700
 17701 = FF14			SDP	=	*	;entry
 17702 FF14 8E 04 03			STX	DBUFLO	;low buffer address
 17703 FF17 8C 05 03			STY	DBUFHI	;high buffer address
 17704 FF1A A9 40			LDA	#PDEVN	;printer device bus ID
 17705 FF1C 8D 00 03			STA	DDEVIC	;device bus ID
 17706 FF1F A5 21			LDA	ICDNOZ	;device number
 17707 FF21 8D 01 03			STA	DUNIT	;unit number
 17708 FF24 A9 80			LDA	#$80	;SIO WRITE command
 17709 FF26 AE 02 03			LDX	DCOMND	;I/O direction
 17710 FF29 E0 53			CPX	#STATC	;STATUS command
 17711 FF2B D0 02			BNE	SDP1	;if STATUS command
 17712
 17713 FF2D A9 40			LDA	#$40	;SIO READ command
 17714
 17715 FF2F 8D 03 03		SDP1	STA	DSTATS	;SIO command
 17716 FF32 AD DF 02			LDA	PBUFSZ
 17717 FF35 8D 08 03			STA	DBYTLO	;low buffer size
 17718 FF38 A9 00			LDA	#0
 17719 FF3A 8D 09 03			STA	DBYTHI	;high buffer size
 17720 FF3D AD 14 03			LDA	PTIMOT
 17721 FF40 8D 06 03			STA	DTIMLO	;device timeout
 17722 FF43 60				RTS		;return
 17723 					;SPACE	4,10
 17724 				;	STS - Set Printer Timeout from Status
 17725 				*
 17726 				*	ENTRY	JSR	STS
 17727 				*
 17728 				*	NOTES
 17729 				*		Problem: bytes wasted by this code's being :
 17730 				*
 17731 				*	MODS
 17732 				*		Original Author Unknown
 17733 				*		1. Bring closer to Coding Standard (object unchanged).
 17734 				*		   R. K. Nordin	11/01/83
 17735
 17736
 17737 = FF44			STS	=	*		;entry
 17738 FF44 AD EC 02			LDA	DVSTAT+2	;timeout
 17739 FF47 8D 14 03			STA	PTIMOT		;set printer timeout
 17740 FF4A 60				RTS			;return
 17741 					;SPACE	4,10
 17742 				;	PPM - Process Print Mode
 17743 				*
 17744 				*	PPM sets up the DCB according to the print mode.
 17745 				*
 17746 				*	ENTRY	JSR	PPM
 17747 				*
 17748 				*	MODS
 17749 				*		Original Author Unknown
 17750 				*		1. Bring closer to Coding Standard (object unchanged).
 17751 				*		   R. K. Nordin	11/01/83
 17752
 17753
 17754 = FF4B			PPM	=	*	;entry
 17755
 17756 				;	Initialize.
 17757
 17758 FF4B A0 57			LDY	#WRITE	;WRITE command
 17759 FF4D A5 2B			LDA	ICAX2Z	;print mode
 17760
 17761 				;	Determine buffer size.
 17762
 17763 FF4F C9 4E		PPM1	CMP	#NORMAL	;NORMAL mode
 17764 FF51 D0 04			BNE	PPM2	;if not NORMAL mode
 17765
 17766 FF53 A2 28			LDX	#NBUFSZ	;NORMAL mode buffer size
 17767 FF55 D0 0E			BNE	PPM4	;set buffer size
 17768
 17769 FF57 C9 44		PPM2	CMP	#DOUBLE	;DOUBLE mode
 17770 FF59 D0 04			BNE	PPM3	;if not DOUBLE mode
 17771
 17772 FF5B A2 14			LDX	#DBUFSZ	;DOUBLE mode buffer size
 17773 FF5D D0 06			BNE	PPM4	;set buffer size
 17774
 17775 FF5F C9 53		PPM3	CMP	#SIDWAY	;SIDEWAYS mode
 17776 FF61 D0 0C			BNE	PPM5	;if not SIDEWAYS mode, assume NORMA:
 17777
 17778 FF63 A2 1D			LDX	#SBUFSZ	;SIDEWAYS mode buffer size
 17779
 17780 				;	Set buffer size.
 17781
 17782 FF65 8E DF 02		PPM4	STX	PBUFSZ	;set printer buffer size
 17783
 17784 				;	Set DCB command and mode.
 17785
 17786 FF68 8C 02 03			STY	DCOMND	;command
 17787 FF6B 8D 0A 03			STA	DAUX1	;print mode
 17788 FF6E 60				RTS		;return
 17789
 17790 				;	Assume NORMAL mode.
 17791
 17792 FF6F A9 4E		PPM5	LDA	#NORMAL	;NORMAL mode
 17793 FF71 D0 DC			BNE	PPM1	;set buffer size
 17794 				;	;SUBTTL	'Self-test, Part 4'
 17795 					;SPACE	4,10
 17796 				;	VFR - Verify First 8K ROM
 17797 				*
 17798 				*	ENTRY	JSR	VFR
 17799 				*
 17800 				*	EXIT
 17801 				*		C clear, if verified
 17802 				*		  set, if not verified
 17803 				*
 17804 				*	MODS
 17805 				*		Original Author Unknown
 17806 				*		1. Bring closer to Coding Standard (object unchanged).
 17807 				*		   R. K. Nordin	11/01/83
 17808
 17809
 17810 = FF73			VFR	=	*	;entry
 17811
 17812 				;	Initialize.
 17813
 17814 FF73 A2 00			LDX	#0	;offset to first region to checksum
 17815 FF75 86 8B			STX	STCHK	;initial sum is zero
 17816 FF77 86 8C			STX	STCHK+1
 17817
 17818 				;	Checksum ROM.
 17819
 17820 FF79 20 A9 FF		VFR1	JSR	CRR	;checksum region of ROM
 17821 FF7C E0 0C			CPX	#12
 17822 FF7E D0 F9			BNE	VFR1	;if not done
 17823
 17824 				;	Compare result.
 17825
 17826 FF80 AD 00 C0			LDA	$C000	;low checksum in ROM
 17827 FF83 AE 01 C0			LDX	$C001	;high checksum in ROM
 17828 				;	JMP	VCS	;verify checksum, return
 17829 					;SPACE	4,10
 17830 				;	VCS - Verify Checksum
 17831 				*
 17832 				*	ENTRY	JSR	VCS
 17833 				*
 17834 				*	MODS
 17835 				*		Original Author Unknown
 17836 				*		1. Bring closer to Coding Standard (object unchanged).
 17837 				*		   R. K. Nordin	11/01/83
 17838
 17839
 17840 = FF86			VCS	=	*	;entry
 17841 FF86 C5 8B			CMP	STCHK	;low checksum
 17842 FF88 D0 06			BNE	VCS1	;if low checksum bad
 17843
 17844 FF8A E4 8C			CPX	STCHK+1	;high checksum
 17845 FF8C D0 02			BNE	VCS1	;if high checksum bad
 17846
 17847 FF8E 18				CLC		;indicate verified
 17848 FF8F 60				RTS		;return
 17849
 17850 FF90 38			VCS1	SEC		;indicate not verified
 17851 FF91 60				RTS		;return
 17852 					;SPACE	4,10
 17853 				;	VSR - Verify Second 8K ROM
 17854 				*
 17855 				*	ENTRY	JSR	VSR
 17856 				*
 17857 				*	EXIT
 17858 				*		C clear, if verified
 17859 				*		  set, if not verified
 17860 				*
 17861 				*	MODS
 17862 				*		Original Author Unknown
 17863 				*		1. Bring closer to Coding Standard (object unchanged).
 17864 				*		   R. K. Nordin	11/01/83
 17865
 17866
 17867 = FF92			VSR	=	*	;entry
 17868 FF92 A2 00			LDX	#0
 17869 FF94 86 8B			STX	STCHK	;initial sum is zero
 17870 FF96 86 8C			STX	STCHK+1
 17871 FF98 A2 0C			LDX	#12	;offset to first region to checksum
 17872 FF9A 20 A9 FF			JSR	CRR	;checksum region of ROM
 17873 FF9D 20 A9 FF			JSR	CRR	;checksum region of ROM
 17874 FFA0 AD F8 FF			LDA	$FFF8	;low checksum from ROM
 17875 FFA3 AE F9 FF			LDX	$FFF9	;high checksum from ROM
 17876 FFA6 4C 86 FF			JMP	VCS	;verify checksum, return
 17877 					;SPACE	4,10
 17878 				;	CRR - Checksum Region of ROM
 17879 				*
 17880 				*	ENTRY	JSR	CRR
 17881 				*		X = offset
 17882 				*
 17883 				*	MODS
 17884 				*		Original Author Unknown
 17885 				*		1. Bring closer to Coding Standard (object unchanged).
 17886 				*		   R. K. Nordin	11/01/83
 17887
 17888
 17889 = FFA9			CRR	=	*	;entry
 17890
 17891 				;	Transfer range addresses.
 17892
 17893 FFA9 A0 00			LDY	#0
 17894
 17895 FFAB BD D7 FF		CRR1	LDA	TARV,X
 17896 FFAE 99 9E 00			STA	STADR1,Y
 17897 FFB1 E8				INX
 17898 FFB2 C8				INY
 17899 FFB3 C0 04			CPY	#4	;4 bytes for 2 addresses
 17900 FFB5 D0 F4			BNE	CRR1	;if not done
 17901
 17902 				;	Checksum range.
 17903
 17904 FFB7 A0 00			LDY	#0
 17905
 17906 FFB9 18			CRR2	CLC
 17907 FFBA B1 9E			LDA	(STADR1),Y
 17908 FFBC 65 8B			ADC	STCHK
 17909 FFBE 85 8B			STA	STCHK
 17910 FFC0 90 02			BCC	CRR3	;if low value non-zero
 17911
 17912 FFC2 E6 8C			INC	STCHK+1	;adjust high value
 17913
 17914 FFC4 E6 9E		CRR3	INC	STADR1	;advance address
 17915 FFC6 D0 02			BNE	CRR4	;if low address non-zero
 17916
 17917 FFC8 E6 9F			INC	STADR1+1	;adjust high address
 17918
 17919 FFCA A5 9E		CRR4	LDA	STADR1	;current address
 17920 FFCC C5 A0			CMP	STADR2	;end of range
 17921 FFCE D0 E9			BNE	CRR2	;if not done
 17922
 17923 FFD0 A5 9F			LDA	STADR1+1
 17924 FFD2 C5 A1			CMP	STADR2+1
 17925 FFD4 D0 E3			BNE	CRR2	;if not done
 17926
 17927 FFD6 60				RTS		;return
 17928 					;SPACE	4,10
 17929 				;	TARV - Table of Address Ranges to Verify
 17930
 17931
 17932 FFD7 02 C0 00 D0		TARV	.word	$C002,$D000	;first 8K ROM, $C002 - $CFFF
 17933 FFDB 00 50 00 58			.word	$5000,$5800	;first 8K ROM, $D000 - $D7FF
 17934 FFDF 00 D8 00 E0			.word	$D800,$E000	;first 8K ROM, $D800 - $DFFF
 17935
 17936 FFE3 00 E0 F8 FF			.word	$E000,$FFF8	;second 8K ROM, $E000 - $FFF7
 17937 FFE7 FA FF 00 00			.word	$FFFA,$0000	;second 8K ROM, $FFFA - $FFFF
 17938 				;	;SUBTTL	'Second 8K ROM Identification and Checksum'
 17939 					;SPACE	4,10
 17940 FFEB				ORG	$FFEE
 17941 					;SPACE	4,10
 17942 				;	Second 8K ROM Identification and Checksum
 17943
 17944
 17945 FFEE 10 05 83			.byte	IDDAY,IDMON,IDYEAR		;date (day, month, year)
 17946 FFF1 02				.byte	IDCPU				;CPU series
 17947 FFF2 42 42 00 00 01		.byte	IDPN1,IDPN2,IDPN3,IDPN4,IDPN5	;part number
 17948 FFF7 02				.byte	IDREV				;revision number
 17949 FFF8 8C 6C			.word	$6C8C				;reserved for checksum
 17950 				;	;SUBTTL	'6502 Machine Vectors'
 17951 					;SPACE	4,10
 17952 FFFA				ORG	$FFFA
 17953 					;SPACE	4,10
 17954 				;	6502 Machine Vectors
 17955
 17956
 17957 FFFA 18 C0			.word	NMI	;vector to process NMI
 17958 FFFC AA C2			.word	RES	;vector to process RESET
 17959 FFFE 2C C0			.word	IRQ	;vector to process IRQ
 17960 					;SPACE	4,10
